Index: cmake/modules/FindGIF.cmake
===================================================================
--- cmake/modules/FindGIF.cmake
+++ cmake/modules/FindGIF.cmake
@@ -16,7 +16,7 @@
 
 FIND_PATH(GIF_INCLUDE_DIR gif_lib.h)
 
-SET(POTENTIAL_GIF_LIBS gif libgif ungif libungif giflib)
+SET(POTENTIAL_GIF_LIBS gif libgif ungif libungif giflib gif4 giflib4)
 FIND_LIBRARY(GIF_LIBRARIES NAMES ${POTENTIAL_GIF_LIBS})
 
 IF (GIF_INCLUDE_DIR AND GIF_LIBRARIES)
Index: cmake/modules/FindWcecompat.cmake
===================================================================
--- cmake/modules/FindWcecompat.cmake
+++ cmake/modules/FindWcecompat.cmake
@@ -0,0 +1,33 @@
+# Try to find Wcecompat functionality
+# Once done this will define
+#
+#  WCECOMPAT_FOUND - system has Wcecompat
+#  WCECOMPAT_INCLUDE_DIR - Wcecompat include directory
+#  WCECOMPAT_LIBRARIES - Libraries needed to use Wcecompat
+#
+# Copyright (c) 2010, Andreas Holzammer, <andy@kdab.com>
+#
+# Redistribution and use is allowed according to the terms of the BSD license.
+
+if(WCECOMPAT_INCLUDE_DIR AND WCECOMPAT_LIB_FOUND)
+  set(Wcecompat_FIND_QUIETLY TRUE)
+endif(WCECOMPAT_INCLUDE_DIR AND WCECOMPAT_LIB_FOUND)
+
+find_path(WCECOMPAT_INCLUDE_DIR errno.h PATH_SUFFIXES wcecompat)
+
+set(WCECOMPAT_LIB_FOUND FALSE)
+
+if(WCECOMPAT_INCLUDE_DIR)
+    find_library(WCECOMPAT_LIBRARIES NAMES wcecompat wcecompatex )
+
+    if(WCECOMPAT_LIBRARIES)
+      set(WCECOMPAT_LIB_FOUND TRUE)
+    endif(WCECOMPAT_LIBRARIES)
+endif(WCECOMPAT_INCLUDE_DIR)
+
+# I have no idea what this is about, but it seems to be used quite often, so I add this here
+set(WCECOMPAT_CONST const)
+
+include(FindPackageHandleStandardArgs)
+find_package_handle_standard_args(Wcecompat  DEFAULT_MSG  WCECOMPAT_LIBRARIES  WCECOMPAT_LIB_FOUND)
+
Index: cmake/modules/FindKDEWin.cmake
===================================================================
--- cmake/modules/FindKDEWin.cmake
+++ cmake/modules/FindKDEWin.cmake
@@ -31,9 +31,9 @@
     else(CMAKE_BUILD_TYPE_TOLOWER MATCHES debug)
         set (LIBRARY_NAME kdewin)
     endif (CMAKE_BUILD_TYPE_TOLOWER MATCHES debug)
-    if (MSVC_IDE )
-        set (LIBRARY_NAME "kdewind")
-    endif (MSVC_IDE)
+    # if (MSVC_IDE )
+        # set (LIBRARY_NAME "kdewind")
+    # endif (MSVC_IDE)
 
     find_library(KDEWIN_LIBRARY
       NAMES ${LIBRARY_NAME}
@@ -48,7 +48,11 @@
   if (KDEWIN_LIBRARY AND KDEWIN_INCLUDE_DIR)
     set(KDEWIN_FOUND TRUE)
     # add needed system libs
-    set(KDEWIN_LIBRARIES ${KDEWIN_LIBRARY} user32 shell32 ws2_32 netapi32 userenv)
+    if(NOT WINCE)
+        set(KDEWIN_LIBRARIES ${KDEWIN_LIBRARY} user32 shell32 ws2_32 netapi32 userenv)
+    else(NOT WINCE)
+         set(KDEWIN_LIBRARIES ${KDEWIN_LIBRARY} ws2 )
+    endif(NOT WINCE)
 
     if (MINGW)
       #mingw compiler
@@ -57,7 +61,11 @@
       # msvc compiler
       # add the MS SDK include directory if available
       file(TO_CMAKE_PATH "$ENV{MSSDK}" MSSDK_DIR)
-      set(KDEWIN_INCLUDES ${KDEWIN_INCLUDE_DIR} ${KDEWIN_INCLUDE_DIR}/msvc  ${QT_INCLUDES} ${MSSDK_DIR})
+      if (WINCE)
+        set(KDEWIN_INCLUDES ${KDEWIN_INCLUDE_DIR} ${KDEWIN_INCLUDE_DIR}/msvc ${WCECOMPAT_INCLUDE_DIR} ${QT_INCLUDES} ${MSSDK_DIR})
+      else(WINCE)
+        set(KDEWIN_INCLUDES ${KDEWIN_INCLUDE_DIR} ${KDEWIN_INCLUDE_DIR}/msvc ${QT_INCLUDES} ${MSSDK_DIR})
+      endif(WINCE)
     endif (MINGW)
 
   endif (KDEWIN_LIBRARY AND KDEWIN_INCLUDE_DIR)
Index: cmake/modules/FindKDE4Internal.cmake
===================================================================
--- cmake/modules/FindKDE4Internal.cmake
+++ cmake/modules/FindKDE4Internal.cmake
@@ -435,9 +435,15 @@
    if (WIN32)
       set(LIBRARY_OUTPUT_PATH               ${EXECUTABLE_OUTPUT_PATH} )
       # CMAKE_CFG_INTDIR is the output subdirectory created e.g. by XCode and MSVC
-      set(KDE4_KCFGC_EXECUTABLE             ${EXECUTABLE_OUTPUT_PATH}/${CMAKE_CFG_INTDIR}/kconfig_compiler )
+      if (NOT WINCE)
+        set(KDE4_KCFGC_EXECUTABLE             ${EXECUTABLE_OUTPUT_PATH}/${CMAKE_CFG_INTDIR}/kconfig_compiler )
+        set(KDE4_MEINPROC_EXECUTABLE          ${EXECUTABLE_OUTPUT_PATH}/${CMAKE_CFG_INTDIR}/meinproc4 )
+      else (NOT WINCE)
+        set(KDE4_KCFGC_EXECUTABLE             ${HOST_BINDIR}/${CMAKE_CFG_INTDIR}/kconfig_compiler )
+        set(KDE4_MEINPROC_EXECUTABLE          ${HOST_BINDIR}/${CMAKE_CFG_INTDIR}/meinproc4 )
+      endif(NOT WINCE)
 
-      set(KDE4_MEINPROC_EXECUTABLE          ${EXECUTABLE_OUTPUT_PATH}/${CMAKE_CFG_INTDIR}/meinproc4 )
+      
       set(KDE4_KAUTH_POLICY_GEN_EXECUTABLE  ${EXECUTABLE_OUTPUT_PATH}/${CMAKE_CFG_INTDIR}/kauth-policy-gen )
       set(KDE4_MAKEKDEWIDGETS_EXECUTABLE    ${EXECUTABLE_OUTPUT_PATH}/${CMAKE_CFG_INTDIR}/makekdewidgets )
    else (WIN32)
Index: kross/CMakeLists.txt
===================================================================
--- kross/CMakeLists.txt
+++ kross/CMakeLists.txt
@@ -12,7 +12,9 @@
 
 # KDE Javascript using kjs and kjsembed
 # test kjsembed I think
+if (NOT WINCE)
 add_subdirectory( kjs )
+endif(NOT WINCE)
 
 # QtScript backend
 add_subdirectory( qts )
Index: kconf_update/kconf_update.cpp
===================================================================
--- kconf_update/kconf_update.cpp
+++ kconf_update/kconf_update.cpp
@@ -28,6 +28,9 @@
 #include <QtCore/QFile>
 #include <QtCore/QTextStream>
 #include <QtCore/QTextCodec>
+#ifdef _WIN32_WCE
+#include <QtCore/QDir>
+#endif
 
 #include <kconfig.h>
 #include <kconfiggroup.h>
@@ -819,12 +822,56 @@
            copyGroup(oldConfig1, oldGroup, &cfg, QString());
        }
        cfg.sync();
+#ifndef _WIN32_WCE
        result = system(QFile::encodeName(QString("%1 < %2 > %3 2> %4").arg(cmd, tmp1.fileName(), tmp2.fileName(), tmp3.fileName())));
+#else
+        QString path_ = QDir::convertSeparators ( QFileInfo ( cmd ).absoluteFilePath() );
+        QString file_ = QFileInfo ( cmd ).fileName();
+        SHELLEXECUTEINFO execInfo;
+        memset ( &execInfo,0,sizeof ( execInfo ) );
+        execInfo.cbSize = sizeof ( execInfo );
+        execInfo.fMask =  SEE_MASK_FLAG_NO_UI;
+        execInfo.lpVerb = L"open";
+        execInfo.lpFile = (LPCWSTR) path_.utf16();
+        execInfo.lpDirectory = (LPCWSTR) file_.utf16();
+        execInfo.lpParameters = (LPCWSTR) QString(" < %1 > %2 2> %3").arg( tmp1.fileName(), tmp2.fileName(), tmp3.fileName()).utf16();
+        result = ShellExecuteEx ( &execInfo );
+        if (result != 0)
+        {
+            result = 0;
+        }
+        else
+        {
+            result = -1;
+        }
+#endif
    }
    else
    {
+#ifndef _WIN32_WCE
        // No config file
        result = system(QFile::encodeName(QString("%1 2> %2").arg(cmd, tmp3.fileName())));
+#else
+        QString path_ = QDir::convertSeparators ( QFileInfo ( cmd ).absoluteFilePath() );
+        QString file_ = QFileInfo ( cmd ).fileName();
+        SHELLEXECUTEINFO execInfo;
+        memset ( &execInfo,0,sizeof ( execInfo ) );
+        execInfo.cbSize = sizeof ( execInfo );
+        execInfo.fMask =  SEE_MASK_FLAG_NO_UI;
+        execInfo.lpVerb = L"open";
+        execInfo.lpFile = (LPCWSTR) path_.utf16();
+        execInfo.lpDirectory = (LPCWSTR) file_.utf16();
+        execInfo.lpParameters = (LPCWSTR) QString(" 2> %1").arg( tmp3.fileName()).utf16();
+        result = ShellExecuteEx ( &execInfo );
+        if (result != 0)
+        {
+            result = 0;
+        }
+        else
+        {
+            result = -1;
+        }
+#endif
    }
 
    // Copy script stderr to log file
Index: kioslave/file/file.cpp
===================================================================
--- kioslave/file/file.cpp
+++ kioslave/file/file.cpp
@@ -904,7 +904,8 @@
 void FileProtocol::mount( bool _ro, const char *_fstype, const QString& _dev, const QString& _point )
 {
     kDebug(7101) << "fstype=" << _fstype;
-
+    
+#ifndef _WIN32_WCE
 #ifdef HAVE_VOLMGT
 	/*
 	 *  support for Solaris volume management
@@ -1039,11 +1040,18 @@
         }
     }
 #endif /* ! HAVE_VOLMGT */
+#else
+    QString err;
+    err = i18n("mounting is not supported by wince.");
+    error( KIO::ERR_COULD_NOT_MOUNT, err );
+#endif
+
 }
 
 
 void FileProtocol::unmount( const QString& _point )
 {
+#ifndef _WIN32_WCE
     QByteArray buffer;
 
     KTemporaryFile tmpFile;
@@ -1154,6 +1162,11 @@
         finished();
     else
         error( KIO::ERR_COULD_NOT_UNMOUNT, err );
+#else
+    QString err;
+    err = i18n("unmounting is not supported by wince.");
+    error( KIO::ERR_COULD_NOT_MOUNT, err );
+#endif
 }
 
 /*************************************
@@ -1164,6 +1177,7 @@
 
 bool FileProtocol::pmount(const QString &dev)
 {
+#ifndef _WIN32_WCE
     QString epath = QString::fromLocal8Bit(qgetenv("PATH"));
     QString path = QLatin1String("/sbin:/bin");
     if (!epath.isEmpty())
@@ -1179,10 +1193,14 @@
     int res = system( buffer.constData() );
 
     return res==0;
+#else
+    return false;
+#endif
 }
 
 bool FileProtocol::pumount(const QString &point)
 {
+#ifndef _WIN32_WCE
     KMountPoint::Ptr mp = KMountPoint::currentMountPoints(KMountPoint::NeedRealDeviceName).findByPath(point);
     if (!mp)
         return false;
@@ -1205,6 +1223,9 @@
     int res = system( buffer.data() );
 
     return res==0;
+#else
+    return false;
+#endif
 }
 
 /*************************************
Index: kioslave/file/CMakeLists.txt
===================================================================
--- kioslave/file/CMakeLists.txt
+++ kioslave/file/CMakeLists.txt
@@ -17,6 +17,10 @@
 
 target_link_libraries(kio_file  ${KDE4_KDECORE_LIBS} kio )
 
+if(WINCE)
+  target_link_libraries(kio_file ${WCECOMPAT_LIBRARIES})
+endif(WINCE)
+
 if (HAVE_VOLMGT AND CMAKE_SYSTEM_NAME MATCHES SunOS)
     target_link_libraries(kio_file -lvolmgt)
 endif (HAVE_VOLMGT AND CMAKE_SYSTEM_NAME MATCHES SunOS)
Index: kioslave/file/file_win.cpp
===================================================================
--- kioslave/file/file_win.cpp
+++ kioslave/file/file_win.cpp
@@ -241,11 +241,18 @@
            return;
         }
 
+#ifndef _WIN32_WCE
         dwFlags = MOVEFILE_REPLACE_EXISTING;
+#endif
     }
 
+ #ifndef _WIN32_WCE   
     if ( MoveFileExW( ( LPCWSTR ) _src.filePath().utf16(),
                       ( LPCWSTR ) _dest.filePath().utf16(), dwFlags) == 0 )
+#else
+    if ( MoveFileW( ( LPCWSTR ) _src.filePath().utf16(),
+                      ( LPCWSTR ) _dest.filePath().utf16()) == 0 )
+#endif
     {
         DWORD dwLastErr = GetLastError();
         if ( dwLastErr == ERROR_FILE_NOT_FOUND )
Index: kioslave/http/kcookiejar/CMakeLists.txt
===================================================================
--- kioslave/http/kcookiejar/CMakeLists.txt
+++ kioslave/http/kcookiejar/CMakeLists.txt
@@ -39,6 +39,9 @@
 kde4_add_plugin(kded_kcookiejar ${kded_kcookiejar_SRCS})
 
 target_link_libraries(kded_kcookiejar  ${KDE4_KIO_LIBS} ${X11_LIBRARIES})
+if(WINCE)
+  target_link_libraries(kded_kcookiejar ${WCECOMPAT_LIBRARIES})
+endif(WINCE)
 
 install(TARGETS kded_kcookiejar  DESTINATION ${PLUGIN_INSTALL_DIR} )
 
Index: kioslave/http/CMakeLists.txt
===================================================================
--- kioslave/http/CMakeLists.txt
+++ kioslave/http/CMakeLists.txt
@@ -39,6 +39,10 @@
 
 target_link_libraries(kdeinit_kio_http_cache_cleaner  ${KDE4_KIO_LIBS} ${ZLIB_LIBRARY})
 
+if(WINCE)
+  target_link_libraries(kio_http_cache_cleaner ${WCECOMPAT_LIBRARIES})
+endif(WINCE)
+
 install(TARGETS kdeinit_kio_http_cache_cleaner ${INSTALL_TARGETS_DEFAULT_ARGS})
 
 target_link_libraries( kio_http_cache_cleaner kdeinit_kio_http_cache_cleaner )
@@ -62,6 +66,10 @@
   target_link_libraries(kio_http ${GSSAPI_LIBS} )
 endif(GSSAPI_FOUND)
 
+if(WINCE)
+  target_link_libraries(kio_http ${WCECOMPAT_LIBRARIES})
+endif(WINCE)
+
 install(TARGETS  kio_http  DESTINATION ${PLUGIN_INSTALL_DIR} )
 
 
Index: kioslave/ftp/CMakeLists.txt
===================================================================
--- kioslave/ftp/CMakeLists.txt
+++ kioslave/ftp/CMakeLists.txt
@@ -15,6 +15,10 @@
 
 target_link_libraries(kio_ftp  ${KDE4_KDECORE_LIBS} kio )
 
+if(WINCE)
+  target_link_libraries(kio_ftp ${WCECOMPAT_LIBRARIES})
+endif(WINCE)
+
 install(TARGETS kio_ftp  DESTINATION ${PLUGIN_INSTALL_DIR} )
 
 
Index: kinit/kwrapper_win.cpp
===================================================================
--- kinit/kwrapper_win.cpp
+++ kinit/kwrapper_win.cpp
@@ -190,12 +190,20 @@
     {
         if (verbose)
             qDebug() << "\t" << a;
+#ifndef _WIN32_WCE
         if (SearchPathW((LPCWSTR)a.utf16(),(LPCWSTR)exeToStart.utf16(),
                         L".exe",MAX_PATH+1,(LPWSTR)_appName,NULL))
         {                        
             found = true;                        
             break;
-        }            
+        }
+#else
+        if (QFile::exists(a+"/"+exeToStart+".exe"))
+        {
+            found = true;                        
+            break;
+        }
+#endif
     }
     QString appName = QString::fromUtf16((unsigned short*)_appName);
 
Index: kinit/kioslave.cpp
===================================================================
--- kinit/kioslave.cpp
+++ kinit/kioslave.cpp
@@ -52,7 +52,9 @@
         fprintf(stderr, "Usage: kioslave <slave-lib> <protocol> <klauncher-socket> <app-socket>\n\nThis program is part of KDE.\n");
         exit(1);
      }
+#ifndef _WIN32_WCE
      setlocale(LC_ALL, "");
+#endif
      QString libpath = QFile::decodeName(argv[1]);
 
      if (libpath.isEmpty())
@@ -127,7 +129,7 @@
         Sleep(1000);
 # endif
      } 
-# ifdef Q_CC_MSVC
+# if defined(Q_CC_MSVC) && !defined(_WIN32_WCE)
      else {
         QString slaveDebugPopup( QString::fromLocal8Bit( qgetenv("KDE_SLAVE_DEBUG_POPUP") ) );
         if (slaveDebugPopup == QLatin1String("all") || slaveDebugPopup == argv[2]) {
Index: kinit/kinit_win.cpp
===================================================================
--- kinit/kinit_win.cpp
+++ kinit/kinit_win.cpp
@@ -30,12 +30,17 @@
 #include <string.h>
 
 #include <windows.h>
+#ifndef _WIN32_WCE
 #include <Sddl.h>
+#else
+#include <tlhelp32.h>
+#endif
 #include <psapi.h>
 
 
 #include <QtCore/QProcess>
 #include <QtCore/QFileInfo>
+#undef interface
 #include <QtDBus/QtDBus>
 
 #include <kcomponentdata.h>
@@ -66,14 +71,22 @@
            name = p.baseName();
            handle = _handle; 
            pid = _pid;
+//There are no users under wince
+#ifndef _WIN32_WCE
            DWORD length = GetLengthSid(_owner);
            owner = (PSID) malloc(length);
            CopySid(length, owner, _owner);
+#else
+           owner = 0;
+#endif
        }
 
        ~ProcessListEntry()
        {
+//There are no users under wince
+#ifndef _WIN32_WCE
            free(owner);
+#endif
            owner = 0;
        }
        
@@ -115,6 +128,7 @@
 
 void ProcessList::getProcessNameAndID( DWORD processID )
 {
+#ifndef _WIN32_WCE
     char szProcessName[MAX_PATH];
     // by default use the current process' uid
     KUser user;
@@ -189,6 +203,7 @@
         processList << new ProcessListEntry( hProcess, szProcessName, processID, processSid );
     }
     free(processSid);
+#endif
 }
 
 
@@ -197,6 +212,7 @@
 */
 void ProcessList::initProcessList()
 {
+#ifndef _WIN32_WCE
     // Get the list of process identifiers.
 
     DWORD aProcesses[1024], cbNeeded, cProcesses;
@@ -214,6 +230,29 @@
     for ( i = 0; i < cProcesses; i++ )
         if( aProcesses[i] != 0 )
             getProcessNameAndID( aProcesses[i] );
+#else
+    HANDLE h;
+    PROCESSENTRY32 pe32;
+
+    h = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
+    if (h == INVALID_HANDLE_VALUE) {
+        return;
+    }
+    pe32.dwSize = sizeof(PROCESSENTRY32);
+    if (!Process32First( h, &pe32 ))
+        return;
+      
+    do
+    {
+        HANDLE hProcess = OpenProcess( SYNCHRONIZE|PROCESS_QUERY_INFORMATION |
+                               PROCESS_VM_READ | PROCESS_TERMINATE,
+                               false, pe32.th32ProcessID );
+                               
+        processList << new ProcessListEntry( hProcess, QString::fromWCharArray(pe32.szExeFile).toAscii().data(), pe32.th32ProcessID, 0 );
+
+    } while( Process32Next( h, &pe32 ) );
+    CloseToolhelp32Snapshot(h);
+#endif
 }
 
 
@@ -238,6 +277,7 @@
             continue;
         }
         if (ple->name == name || ple->name == name + ".exe") {
+#ifndef _WIN32_WCE
             if(owner)
             {
                 // owner is set
@@ -249,6 +289,9 @@
                 KUser user;
                 if(EqualSid(user.uid(), ple->owner)) return ple;
             }
+#else
+            return ple;
+#endif
         }
     }
     return NULL;
Index: kinit/CMakeLists.txt
===================================================================
--- kinit/CMakeLists.txt
+++ kinit/CMakeLists.txt
@@ -30,7 +30,11 @@
 ########### kdeinit4 ###############
 if (WIN32)
   set(kdeinit_SRCS kinit_win.cpp klauncher_cmds.cpp )
-  set(kdeinit_LIBS kparts psapi)
+  if(NOT WINCE)
+    set(kdeinit_LIBS kparts psapi)
+  else(NOT WINCE)
+    set(kdeinit_LIBS Toolhelp.lib)
+  endif(NOT WINCE)
 else (WIN32)
   set(kdeinit_SRCS kinit.cpp proctitle.cpp klauncher_cmds.cpp )
   set(kdeinit_LIBS kparts)
@@ -148,6 +152,9 @@
 install(TARGETS kdeinit_klauncher ${INSTALL_TARGETS_DEFAULT_ARGS})
 
 target_link_libraries( klauncher kdeinit_klauncher )
+if(WINCE)
+  target_link_libraries(klauncher ${WCECOMPAT_LIBRARIES})
+endif(WINCE)
 install(TARGETS klauncher DESTINATION ${LIBEXEC_INSTALL_DIR} )
 
 ########### start_kdeinit ###############
Index: kio/kio/slave.cpp
===================================================================
--- kio/kio/slave.cpp
+++ kio/kio/slave.cpp
@@ -346,7 +346,11 @@
                  << "(" << QString(d->m_protocol) + "://" + d->m_host << ")";
     if (d->m_pid)
     {
+#ifndef _WIN32_WCE
        ::kill(d->m_pid, SIGTERM);
+#else
+        ::kill(d->m_pid, SIGKILL);
+#endif
     }
 }
 
Index: kio/kio/krun_win.cpp
===================================================================
--- kio/kio/krun_win.cpp
+++ kio/kio/krun_win.cpp
@@ -33,8 +33,14 @@
   if (!libHandle)
     return 0;
   typedef int (WINAPI *FunctionType)(HWND, HMODULE, LPCWSTR, int);
+#ifdef _WIN32_WCE
+  QString functionNamestr = QString(functionName);
   FunctionType function 
+    = (FunctionType)GetProcAddressW( libHandle, functionNamestr.utf16() );
+#else
+  FunctionType function 
     = (FunctionType)GetProcAddress( libHandle, functionName.constData() );
+#endif
   if (!function)
     return 0;
   int result = function((HWND)windowId, libHandle, (LPCWSTR)arguments.utf16(), SW_SHOW);
@@ -49,8 +55,14 @@
   if (!libHandle)
     return 0;
   typedef int (WINAPI *FunctionType)(HWND, HMODULE, LPCSTR, int);
+#ifdef _WIN32_WCE
+  QString functionNamestr = QString(functionName);
   FunctionType function 
+    = (FunctionType)GetProcAddressW( libHandle, functionNamestr.utf16() );
+#else
+  FunctionType function 
     = (FunctionType)GetProcAddress( libHandle, functionName.constData() );
+#endif
   if (!function)
     return 0;
   int result = function((HWND)windowId, libHandle, (LPCSTR)arguments.constData(), SW_SHOW);
Index: kio/kio/kmountpoint.cpp
===================================================================
--- kio/kio/kmountpoint.cpp
+++ kio/kio/kmountpoint.cpp
@@ -391,7 +391,7 @@
     }
 
     free( mntctl_buffer );
-#elif defined(Q_WS_WIN)
+#elif defined(Q_WS_WIN) && !defined(_WIN32_WCE)
 	//nothing fancy with infoNeeded but it gets the job done
     DWORD bits = GetLogicalDrives();
     if(!bits)
@@ -406,7 +406,10 @@
             result.append(mp);
         }
     }
-	
+#elif defined(_WIN32_WCE)
+	Ptr mp(new KMountPoint);
+    mp->d->mountPoint = QString("/");
+    result.append(mp);
 #else
    STRUCT_SETMNTENT mnttab;
    if ((mnttab = SETMNTENT(MNTTAB, "r")) == 0)
Index: kio/kio/kprotocolmanager.cpp
===================================================================
--- kio/kio/kprotocolmanager.cpp
+++ kio/kio/kprotocolmanager.cpp
@@ -497,7 +497,7 @@
   struct utsname unameBuf;
   if ( 0 != uname( &unameBuf ) )
     return false;
-#ifdef Q_WS_WIN
+#if defined(Q_WS_WIN) && !defined(_WIN32_WCE)
   // we do not use unameBuf.sysname information constructed in kdewin32
   // because we want to get separate name and version
   systemName = QLatin1String( "Windows" );
Index: kio/CMakeLists.txt
===================================================================
--- kio/CMakeLists.txt
+++ kio/CMakeLists.txt
@@ -256,6 +256,10 @@
 target_link_libraries(kio ${KDE4_KDEUI_LIBS} ${ZLIB_LIBRARY} ${STRIGI_STREAMANALYZER_LIBRARY} ${STRIGI_STREAMS_LIBRARY} ${KDE4_SOLID_LIBS} ${QT_QTNETWORK_LIBRARY} ${QT_QTXML_LIBRARY} ${X11_LIBRARIES})
 target_link_libraries(kio LINK_INTERFACE_LIBRARIES kdeui kdecore ${QT_QTNETWORK_LIBRARY} ${QT_QTXML_LIBRARY} ${QT_QTGUI_LIBRARY} )
 
+if(WINCE)
+  target_link_libraries(kio ${WCECOMPAT_LIBRARIES})
+endif(WINCE)
+
 set(SYS_INOTIFY_H_FOUND 0)
 if(SYS_INOTIFY_H_FOUND)
    macro_log_feature(FAM_FOUND "FAM" "File Alteration Monitor" "http://oss.sgi.com/projects/fam" FALSE "" "You have file alteration notification support built into your kernel, however you might consider installing FAM as it also supports NFS.")
Index: kutils/kprintpreview.cpp
===================================================================
--- kutils/kprintpreview.cpp
+++ kutils/kprintpreview.cpp
@@ -134,6 +134,8 @@
 {
     kDebug(500) << "kdeprint: creating preview dialog";
 
+    //There is no printing on wince
+#ifndef _WIN32_WCE
     // Set up the dialog
     setCaption(i18n("Print Preview"));
     setButtons(KDialog::Close);
@@ -143,6 +145,7 @@
     printer->setOutputFileName(d->filename);
 
     setInitialSize(QSize(600, 500));
+#endif
 }
 
 KPrintPreview::~KPrintPreview()
Index: kutils/kidletime/windowspoller.cpp
===================================================================
--- kutils/kidletime/windowspoller.cpp
+++ kutils/kidletime/windowspoller.cpp
@@ -34,6 +34,7 @@
 
 int WindowsPoller::getIdleTime()
 {
+#ifndef _WIN32_WCE
     int idle = 0;
 
     LASTINPUTINFO lii;
@@ -47,6 +48,9 @@
     }
 
     return idle;
+#else
+    return GetIdleTime();
+#endif
 }
 
 bool WindowsPoller::additionalSetUp()
Index: kdecore/kernel/ktoolinvocation_win.cpp
===================================================================
--- kdecore/kernel/ktoolinvocation_win.cpp
+++ kdecore/kernel/ktoolinvocation_win.cpp
@@ -36,8 +36,19 @@
 
 void KToolInvocation::invokeBrowser( const QString &url, const QByteArray& startup_id )
 {
+#ifndef _WIN32_WCE
    QString sOpen( "open" );
    ShellExecuteW(0, ( LPCWSTR )sOpen.utf16(), ( LPCWSTR )url.utf16(), 0, 0, SW_NORMAL);
+#else
+    SHELLEXECUTEINFO cShellExecuteInfo = {0};
+    cShellExecuteInfo.cbSize = sizeof(SHELLEXECUTEINFO);
+    cShellExecuteInfo.fMask = SEE_MASK_NOCLOSEPROCESS;
+    cShellExecuteInfo.hwnd = NULL;
+    cShellExecuteInfo.lpVerb = L"Open";
+    cShellExecuteInfo.lpFile = ( LPCWSTR )url.utf16();
+    cShellExecuteInfo.nShow = SW_SHOWNORMAL;
+    ShellExecuteEx(&cShellExecuteInfo);
+#endif
 }
 
 void KToolInvocation::invokeMailer(const QString &_to, const QString &_cc, const QString &_bcc,
@@ -53,8 +64,19 @@
   foreach (const QString& attachURL, attachURLs)
     url.addQueryItem("attach", QLatin1String( KUrl::toPercentEncoding(attachURL) ));
 
+#ifndef _WIN32_WCE
    QString sOpen( "open" );
    ShellExecuteW(0, ( LPCWSTR )sOpen.utf16(), ( LPCWSTR )url.url().utf16(), 0, 0, SW_NORMAL);
+#else
+    SHELLEXECUTEINFO cShellExecuteInfo = {0};
+    cShellExecuteInfo.cbSize = sizeof(SHELLEXECUTEINFO);
+    cShellExecuteInfo.fMask = SEE_MASK_NOCLOSEPROCESS;
+    cShellExecuteInfo.hwnd = NULL;
+    cShellExecuteInfo.lpVerb = L"Open";
+    cShellExecuteInfo.lpFile = ( LPCWSTR )url.url().utf16();
+    cShellExecuteInfo.nShow = SW_SHOWNORMAL;
+    ShellExecuteEx(&cShellExecuteInfo);
+#endif
 }
 
 void KToolInvocation::invokeTerminal(const QString &command, const QString &workdir, const QByteArray &startup_id)
Index: kdecore/kernel/kkernel_win.cpp
===================================================================
--- kdecore/kernel/kkernel_win.cpp
+++ kdecore/kernel/kkernel_win.cpp
@@ -55,14 +55,22 @@
 # define WIN32_CAST_CHAR (LPCWSTR)
 #endif
 
+#ifndef _WIN32_WCE
 static HINSTANCE kdecoreDllInstance = NULL;
+#else
+static HANDLE kdecoreDllInstance = NULL;
+#endif
 static wchar_t kde4prefixUtf16[MAX_PATH + 2];
 static QString *kde4Prefix = NULL;
 
 void initKde4prefixUtf16()
 {
     //the path is C:\some\path\kde4\bin\kdecore.dll
+#ifndef _WIN32_WCE
     GetModuleFileNameW(kdecoreDllInstance, kde4prefixUtf16, MAX_PATH + 1);
+#else
+    GetModuleFileNameW((HMODULE)kdecoreDllInstance, kde4prefixUtf16, MAX_PATH + 1);
+#endif
     int bs1 = 0, bs2 = 0;
 
     //we convert \ to / and remove \bin\kdecore.dll from the string
@@ -93,7 +101,11 @@
  * Maybe also some special initialization / cleanup can be done here
  **/
 extern "C"
+#ifndef _WIN32_WCE
 BOOL WINAPI DllMain ( HINSTANCE hinstDLL,DWORD fdwReason,LPVOID lpReserved)
+#else
+BOOL WINAPI DllMain ( HANDLE hinstDLL,DWORD fdwReason,LPVOID lpReserved)
+#endif
 {
     switch ( fdwReason ) {
     case DLL_PROCESS_ATTACH:
@@ -171,14 +183,28 @@
 {
     QString path_ = QDir::convertSeparators ( QFileInfo ( fileName ).absoluteFilePath() );
 
+#ifndef _WIN32_WCE
     SHELLEXECUTEINFOW execInfo;
+#else
+    SHELLEXECUTEINFO execInfo;
+#endif
     memset ( &execInfo,0,sizeof ( execInfo ) );
     execInfo.cbSize = sizeof ( execInfo );
+#ifndef _WIN32_WCE
     execInfo.fMask = SEE_MASK_INVOKEIDLIST | SEE_MASK_NOCLOSEPROCESS | SEE_MASK_FLAG_NO_UI;
+#else
+    execInfo.fMask = SEE_MASK_NOCLOSEPROCESS | SEE_MASK_FLAG_NO_UI;
+#endif
     const QString verb ( QLatin1String ( "properties" ) );
     execInfo.lpVerb = WIN32_CAST_CHAR verb.utf16();
     execInfo.lpFile = WIN32_CAST_CHAR path_.utf16();
+#ifndef _WIN32_WCE
     return ShellExecuteExW ( &execInfo );
+#else
+    return ShellExecuteEx ( &execInfo );
+    //There is no native file property dialog in wince
+   // return false;
+#endif
 }
 
 // note: QLocale().name().left(2).toLatin1() returns the same
@@ -236,7 +262,7 @@
             break;
     }
     strlcat(buf,"\n",BUFSIZE);
-    OutputDebugStringA(buf);
+    OutputDebugStringW( QString::fromAscii(buf).utf16());
     delete[] buf;
 }
 
@@ -283,6 +309,8 @@
 */ 
 static void redirectToConsole()
 {
+//FIXME: for wince we cannot set stdio buffers
+#ifndef _WIN32_WCE
     int hCrt;
     FILE *hf;
     int i;
@@ -310,6 +338,7 @@
     // make cout, wcout, cin, wcin, wcerr, cerr, wclog and clog
     // point to console as well
     ios::sync_with_stdio();
+#endif
 }
 
 #include <streambuf>
@@ -337,7 +366,7 @@
                 if (cc == '\n')
                 {
                     buf[index] = '\0';
-                    OutputDebugStringA((LPCSTR)buf);
+                    OutputDebugStringW(QString::fromAscii(buf).utf16());
                     index = rindex;
                 }
             }
Index: kdecore/kernel/kstandarddirs.cpp
===================================================================
--- kdecore/kernel/kstandarddirs.cpp
+++ kdecore/kernel/kstandarddirs.cpp
@@ -56,6 +56,9 @@
 #include <grp.h>
 #ifdef Q_WS_WIN
 #include <windows.h>
+#ifdef _WIN32_WCE
+#include <basetyps.h>
+#endif
 #include <shlobj.h>
 #include <QtCore/QVarLengthArray>
 #endif
@@ -1646,12 +1649,17 @@
 #if defined(Q_WS_MACX)
         localKdeDir =  QDir::homePath() + QLatin1String("/Library/Preferences/KDE/");
 #elif defined(Q_WS_WIN)
+//there is no SHGetFolderPathW defined for wince
+#ifndef _WIN32_WCE
         WCHAR wPath[MAX_PATH+1];
         if ( SHGetFolderPathW(NULL, CSIDL_APPDATA, NULL, SHGFP_TYPE_CURRENT, wPath) == S_OK) {
           localKdeDir = QDir::fromNativeSeparators(QString::fromUtf16((const ushort *) wPath)) + QLatin1Char('/') + KDE_DEFAULT_HOME + QLatin1Char('/');
         } else {
+#endif
           localKdeDir =  QDir::homePath() + QLatin1Char('/') + KDE_DEFAULT_HOME + QLatin1Char('/');
+#ifndef _WIN32_WCE         
         }
+#endif
 #else
         localKdeDir =  QDir::homePath() + QLatin1Char('/') + KDE_DEFAULT_HOME + QLatin1Char('/');
 #endif
Index: kdecore/services/kmimetype.cpp
===================================================================
--- kdecore/services/kmimetype.cpp
+++ kdecore/services/kmimetype.cpp
@@ -211,6 +211,8 @@
     // FIXME: distinguish between mounted & unmounted
     int size = path.size();
     if ( size == 2 || size == 3 ) {
+    //GetDriveTypeW is not defined in wince
+#ifndef _WIN32_WCE
         unsigned int type = GetDriveTypeW( (LPCWSTR) path.utf16() );
         switch( type ) {
             case DRIVE_REMOVABLE:
@@ -226,6 +228,9 @@
             default:
                 break;
         };
+#else
+        return KMimeType::mimeType( "media/hdd_mounted" );
+#endif
     }
 #endif
     // remote executable file? stop here (otherwise findFromContent can do that better for local files)
Index: kdecore/services/kservicegroup.cpp
===================================================================
--- kdecore/services/kservicegroup.cpp
+++ kdecore/services/kservicegroup.cpp
@@ -413,8 +413,8 @@
         const QByteArray nameStr = name.toLocal8Bit();
 
         QByteArray key;
-        // strxfrm() crashes on Solaris
-#ifndef USE_SOLARIS
+        // strxfrm() crashes on Solaris and strxfrm is not defined under wince
+#if !defined(USE_SOLARIS) && !defined(_WIN32_WCE)
         // maybe it'd be better to use wcsxfrm() where available
         key.resize( name.length() * 4 + 1 );
         size_t ln = strxfrm(key.data(), nameStr.constData(), key.size());
Index: kdecore/localization/klocale.cpp
===================================================================
--- kdecore/localization/klocale.cpp
+++ kdecore/localization/klocale.cpp
@@ -2573,10 +2573,15 @@
 #ifdef Q_WS_WIN
     if (0 == qstrcmp("System", codecForEncoding()->name())) {
         //win32 returns "System" codec name here but KDE apps expect a real name:
+        LPWSTR buffer;
+        
         strcpy(d->win32SystemEncoding, "cp ");
-        if (GetLocaleInfoA(MAKELCID(MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), SORT_DEFAULT),
-                           LOCALE_IDEFAULTANSICODEPAGE, d->win32SystemEncoding + 3,
-                           sizeof(d->win32SystemEncoding) - 3 - 1)) {
+        if (GetLocaleInfoW(MAKELCID(MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), SORT_DEFAULT),
+                           LOCALE_IDEFAULTANSICODEPAGE, buffer,
+                           sizeof(buffer))) {
+            QString localestr = QString::fromUtf16(buffer);
+            QByteArray localechar = localestr.toAscii();
+            strcpy(d->win32SystemEncoding, localechar.data() + 3);
             return d->win32SystemEncoding;
         }
     }
Index: kdecore/localization/kencodingprober.cpp
===================================================================
--- kdecore/localization/kencodingprober.cpp
+++ kdecore/localization/kencodingprober.cpp
@@ -197,7 +197,7 @@
 //DEPRECATED, do *not* use
 const char* KEncodingProber::encodingName() const
 {
-    return strdup(encoding().constData());
+    return qstrdup(encoding().constData());
 }
 
 QByteArray KEncodingProber::encoding() const
Index: kdecore/network/netsupp.cpp
===================================================================
--- kdecore/network/netsupp.cpp
+++ kdecore/network/netsupp.cpp
@@ -171,7 +171,7 @@
   p->ai_family = AF_UNIX;
   p->ai_addrlen = len;
   p->ai_addr = (sockaddr*)_sun;
-  p->ai_canonname = strdup(buf);
+  p->ai_canonname = qstrdup(buf);
 
   return p;
 }
@@ -491,7 +491,7 @@
 # endif
 
   if (hint->ai_flags & AI_CANONNAME)
-    q->ai_canonname = strdup(h->h_name);
+    q->ai_canonname = qstrdup(h->h_name);
   else
     q->ai_canonname = NULL;
 
@@ -542,7 +542,7 @@
 # endif
 
       if (q->ai_canonname != NULL)
-	q->ai_canonname = strdup(q->ai_canonname);
+	q->ai_canonname = qstrdup(q->ai_canonname);
 
       q->ai_next = p;
       p = q;
Index: kdecore/tests/kcalendartest.cpp
===================================================================
--- kdecore/tests/kcalendartest.cpp
+++ kdecore/tests/kcalendartest.cpp
@@ -542,7 +542,10 @@
     Note special cases 15 = 9 + 6 טו and 16 = 9 + 7 טז
 */
 
-    QString oldLocale = setlocale(LC_ALL, "he.utf8");
+    QString oldLocale;
+#ifndef _WIN32_WCE
+    oldLocale = setlocale(LC_ALL, "he.utf8");
+#endif
     KLocale *locale = new KLocale( *KGlobal::locale() );
     locale->setLanguage(QStringList() << "he");
     locale->setDateFormat( "%d %B %Y" );
@@ -571,7 +574,9 @@
     } else {
         kDebug() << "Cannot set Hebrew language, please install and re-test!";
     }
+#ifndef _WIN32_WCE
     setlocale( LC_ALL, oldLocale.toLatin1() );
+#endif
 }
 
 void KCalendarTest::testIsoWeekDate()
Index: kdecore/tests/CMakeLists.txt
===================================================================
--- kdecore/tests/CMakeLists.txt
+++ kdecore/tests/CMakeLists.txt
@@ -5,12 +5,18 @@
        FOREACH(_testname ${ARGN})
                kde4_add_unit_test(${_testname} NOGUI ${_testname}.cpp)
                target_link_libraries(${_testname} ${KDE4_KDECORE_LIBS} ${QT_QTTEST_LIBRARY} ${QT_QTNETWORK_LIBRARY})
+               if(WINCE)
+                target_link_libraries(${_testname} ${WCECOMPAT_LIBRARIES})
+               endif(WINCE)
        ENDFOREACH(_testname)
 ENDMACRO(KDECORE_UNIT_TESTS)
 MACRO(KDECORE_EXECUTABLE_TESTS)
        FOREACH(_testname ${ARGN})
                kde4_add_executable(${_testname} NOGUI TEST ${_testname}.cpp)
                target_link_libraries(${_testname} ${KDE4_KDECORE_LIBS} ${QT_QTTEST_LIBRARY})
+               if(WINCE)
+                target_link_libraries(${_testname} ${WCECOMPAT_LIBRARIES})
+               endif(WINCE)
        ENDFOREACH(_testname)
 ENDMACRO(KDECORE_EXECUTABLE_TESTS)
 
Index: kdecore/config/kconfiggroup.cpp
===================================================================
--- kdecore/config/kconfiggroup.cpp
+++ kdecore/config/kconfiggroup.cpp
@@ -402,12 +402,15 @@
             }
             newpath += oldpath;
             setenv( "PATH", newpath, 1/*overwrite*/ );
+// FIXME: wince does not have pipes
+#ifndef _WIN32_WCE
             FILE *fs = popen(QFile::encodeName(cmd).data(), "r");
             if (fs) {
                 QTextStream ts(fs, QIODevice::ReadOnly);
                 result = ts.readAll().trimmed();
                 pclose(fs);
             }
+#endif
             setenv( "PATH", oldpath, 1/*overwrite*/ );
             aValue.replace( nDollarPos, nEndPos-nDollarPos, result );
             nDollarPos += result.length();
Index: kdecore/io/kdebug.cpp
===================================================================
--- kdecore/io/kdebug.cpp
+++ kdecore/io/kdebug.cpp
@@ -36,7 +36,9 @@
 #ifdef Q_WS_WIN
 #include <fcntl.h>
 #include <windows.h>
+#ifndef _WIN32_WCE
 #include <wincon.h>
+#endif
 #else
 #include <unistd.h>
 #include <stdio.h>
Index: kdecore/io/ktempdir.cpp
===================================================================
--- kdecore/io/ktempdir.cpp
+++ kdecore/io/ktempdir.cpp
@@ -57,6 +57,10 @@
 extern QString mkdtemp_QString (const QString &_template);
 #endif
 
+#ifdef _WIN32_WCE
+#include <shellapi.h>
+#endif
+
 class KTempDir::Private
 {
 public:
@@ -270,7 +274,12 @@
     memset(&fileOp, 0, sizeof(SHFILEOPSTRUCTW) );
     fileOp.wFunc = FO_DELETE;
     fileOp.pFrom = (LPCWSTR)name.constData();
-    fileOp.fFlags = FOF_NOCONFIRMATION | FOF_NOERRORUI | FOF_SILENT;
+    fileOp.fFlags = FOF_NOCONFIRMATION | FOF_SILENT;
+#ifdef _WIN32_WCE
+    // FOF_NOERRORUI is not defined in wince
+#else
+    fileOp.fFlags |= FOF_NOERRORUI;
+#endif
     errno = SHFileOperationW( &fileOp );
     return (errno == 0);
 #else
Index: kdecore/io/kprocess.cpp
===================================================================
--- kdecore/io/kprocess.cpp
+++ kdecore/io/kprocess.cpp
@@ -41,15 +41,23 @@
 # define STD_ERROR_HANDLE 2
 #endif
 
+#ifdef _WIN32_WCE
+#include <stdio.h>
+#endif
+
 void KProcessPrivate::writeAll(const QByteArray &buf, int fd)
 {
 #ifdef Q_OS_WIN
+#ifndef _WIN32_WCE
     HANDLE h = GetStdHandle(fd);
     if (h) {
         DWORD wr;
         WriteFile(h, buf.data(), buf.size(), &wr, 0);
     }
 #else
+    fwrite(buf.data(), 1, buf.size(), (FILE*)fd);
+#endif
+#else
     int off = 0;
     do {
         int ret = ::write(fd, buf.data() + off, buf.size() - off);
@@ -75,12 +83,20 @@
 
 void KProcessPrivate::_k_forwardStdout()
 {
+#ifndef _WIN32_WCE
     forwardStd(KProcess::StandardOutput, STD_OUTPUT_HANDLE);
+#else
+    forwardStd(KProcess::StandardOutput, (int)stdout);
+#endif
 }
 
 void KProcessPrivate::_k_forwardStderr()
 {
+#ifndef _WIN32_WCE
     forwardStd(KProcess::StandardError, STD_ERROR_HANDLE);
+#else
+    forwardStd(KProcess::StandardError, (int)stderr);
+#endif
 }
 
 /////////////////////////////
@@ -290,6 +306,7 @@
     //see also TrollTechTaskTracker entry 88373.
     d->prog = KStandardDirs::findExe("kcmdwrapper");
 
+#ifndef _WIN32_WCE
     UINT size;
     WCHAR sysdir[MAX_PATH + 1];
     size = GetSystemDirectoryW(sysdir, MAX_PATH + 1);
@@ -297,7 +314,10 @@
     cmdexe.append("\\cmd.exe");
 
     d->args << cmdexe << cmd;
+#else
+    d->args << "\\windows\\cmd.exe" << cmd;
 #endif
+#endif
 }
 
 QStringList KProcess::program() const
Index: kdecore/date/ktimezone_win.cpp
===================================================================
--- kdecore/date/ktimezone_win.cpp
+++ kdecore/date/ktimezone_win.cpp
@@ -490,6 +490,8 @@
         return 0;
     const bool isDst = is_dst( tz, systemtime_to_qdatetime( utc ), utc.wYear );
     int result = effective_offset( tz, isDst );
+//FIXME: SystemTimeToTzSpecificLocalTime does not exsit on wince
+#ifndef _WIN32_WCE
     if ( secondOffset ) {
         const SYSTEMTIME utcplus1 = qdatetime_to_systemtime( systemtime_to_qdatetime( utc ).addSecs( OneHour ) );
         const SYSTEMTIME utcminus1 = qdatetime_to_systemtime( systemtime_to_qdatetime( utc ).addSecs( -OneHour ) );
@@ -505,6 +507,7 @@
                 qSwap( result, *secondOffset );
         }
     }
+#endif
     return result;
 }
 
Index: kdecore/util/kde_file_win.cpp
===================================================================
--- kdecore/util/kde_file_win.cpp
+++ kdecore/util/kde_file_win.cpp
@@ -157,9 +157,13 @@
 
   int rename(const QString &in, const QString &out)
   {
+#ifndef _WIN32_WCE
     // better than :waccess/_wunlink/_wrename
     bool ok = ( MoveFileExW( CONV(in), CONV(out),
                              MOVEFILE_REPLACE_EXISTING|MOVEFILE_COPY_ALLOWED ) != 0 );
+#else
+    bool ok = ( MoveFileW( CONV(in), CONV(out)) != 0 );
+#endif
 	return ok ? 0 : -1;
   }
 
@@ -167,8 +171,12 @@
   {
     int result;
 #ifdef Q_CC_MSVC
+#ifndef _WIN32_WCE
     struct _stat64 s64;
 #else
+    struct stat st;
+#endif
+#else
     struct __stat64 s64;
 #endif
     const int len = path.length();
@@ -177,34 +185,65 @@
         QString newPath(path);
     	if (len==2)
     		newPath += QLatin1Char('\\');
+#ifndef _WIN32_WCE
     	result = _wstat64( CONV(newPath), &s64 );
+#else
+    	result = wstat( CONV(newPath), &st );
+#endif
     } else
     if ( len > 1 && (path.endsWith(QLatin1Char('\\')) || path.endsWith(QLatin1Char('/'))) ) {
     	/* 2) */
         const QString newPath = path.left( len - 1 );
+#ifndef _WIN32_WCE
     	result = _wstat64( CONV(newPath), &s64 );
+#else
+    	result = wstat( CONV(newPath), &st );
+#endif
     } else {
         //TODO: is stat("/") ok?
+#ifndef _WIN32_WCE
         result = _wstat64( CONV(path), &s64 );
+#else
+        result = wstat( CONV(path), &st );
+#endif
     }
     if( result != 0 )
         return result;
     // KDE5: fixme!
+#ifndef _WIN32_WCE   
     buf->st_dev   = s64.st_dev;
     buf->st_ino   = s64.st_ino;
     buf->st_mode  = s64.st_mode;
     buf->st_nlink = s64.st_nlink;
+#else
+    buf->st_dev   = st.st_dev;
+    buf->st_ino   = st.st_ino;
+    buf->st_mode  = st.st_mode;
+    buf->st_nlink = st.st_nlink;
+#endif
     buf->st_uid   = -2; // be in sync with Qt4
     buf->st_gid   = -2; // be in sync with Qt4
+#ifndef _WIN32_WCE   
     buf->st_rdev  = s64.st_rdev;
     buf->st_size  = s64.st_size;
     buf->st_atime = s64.st_atime;
     buf->st_mtime = s64.st_mtime;
     buf->st_ctime = s64.st_ctime;
+#else
+    buf->st_rdev  = st.st_rdev;
+    buf->st_size  = st.st_size;
+    buf->st_atime = st.st_atime;
+    buf->st_mtime = st.st_mtime;
+    buf->st_ctime = st.st_ctime;
+#endif
     return result;
   }
   int utime(const QString &filename, struct utimbuf *buf)
   {
+#ifndef _WIN32_WCE
     return _wutime( CONV(filename), (struct _utimbuf*)buf );
+#else
+    return _wutime( CONV(filename), (struct utimbuf*)buf );
+#endif
   }
 };
Index: kdecore/util/kuser_wince.cpp
===================================================================
--- kdecore/util/kuser_wince.cpp
+++ kdecore/util/kuser_wince.cpp
@@ -0,0 +1,236 @@
+/*
+ *  KUser - represent a user/account (Windows)
+ *  Copyright (C) 2010 Andreas Holzammer <andreas.holzammer@kdab.com>
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public License
+ *  along with this library; see the file COPYING.LIB.  If not, write to
+ *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301, USA.
+ */
+
+#include "kuser.h"
+
+#include <QStringList>
+
+
+class KUser::Private : public KShared
+{
+};
+
+KUser::KUser(UIDMode mode)
+        : d(0)
+{
+    Q_UNUSED(mode)
+}
+
+KUser::KUser(K_UID uid)
+    : d(0)
+{
+    Q_UNUSED(uid)
+}
+
+KUser::KUser(const QString &name)
+    : d(0)
+{
+}
+
+KUser::KUser(const char *name)
+    :d(0)
+{
+}
+
+KUser::KUser(const KUser &user)
+    : d(user.d)
+{
+}
+
+KUser &KUser::operator=(const KUser &user)
+{
+    d = user.d;
+    return *this;
+}
+
+bool KUser::operator==(const KUser &user) const
+{
+    if (!isValid() || !user.isValid())
+        return false;
+    return true;
+}
+
+bool KUser::operator !=(const KUser &user) const
+{
+    return !operator==(user);
+}
+
+bool KUser::isValid() const
+{
+    return true;
+}
+
+bool KUser::isSuperUser() const
+{
+    return true;
+}
+
+QString KUser::loginName() const
+{
+    return QString("default");
+}
+
+QString KUser::fullName() const
+{
+    return QString("default");
+}
+
+QString KUser::homeDir() const
+{
+	return QString("\\Documents and Settings\\default");
+}
+
+QString KUser::faceIconPath() const
+{
+    return QString();
+}
+
+QString KUser::shell() const
+{
+    return QString::fromAscii("cmd.exe");
+}
+
+QList<KUserGroup> KUser::groups() const
+{
+    return QList<KUserGroup>();
+}
+
+QStringList KUser::groupNames() const
+{
+    return QStringList();
+}
+
+K_UID KUser::uid() const
+{
+    return (K_UID)100;
+}
+
+QVariant KUser::property(UserProperty which) const
+{
+    return QVariant();
+}
+
+QList<KUser> KUser::allUsers()
+{
+    QList<KUser> result;
+
+    result.append(KUser());
+
+    return result;
+}
+
+QStringList KUser::allUserNames()
+{
+    QStringList result;
+
+    result.append("wince");
+
+    return result;
+}
+
+KUser::~KUser()
+{
+}
+
+class KUserGroup::Private : public KShared
+{
+};
+
+KUserGroup::KUserGroup(const QString &_name)
+    : d(0)
+{
+}
+
+KUserGroup::KUserGroup(const char *_name)
+    : d(0)
+{
+}
+
+KUserGroup::KUserGroup(const KUserGroup &group)
+    : d(0)
+{
+}
+
+KUserGroup& KUserGroup::operator =(const KUserGroup &group)
+{
+    d = group.d;
+    return *this;
+}
+
+bool KUserGroup::operator==(const KUserGroup &group) const
+{
+
+    return true;
+}
+
+bool KUserGroup::operator!=(const KUserGroup &group) const
+{
+    return !operator==(group);
+}
+
+bool KUserGroup::isValid() const
+{
+    return true;
+}
+
+QString KUserGroup::name() const
+{
+    return QString("wince");
+}
+
+QList<KUser> KUserGroup::users() const
+{
+    QList<KUser> Result;
+
+    Result.append(KUser());
+
+    return Result;
+}
+
+QStringList KUserGroup::userNames() const
+{
+    QStringList result;
+
+    result.append("default");
+
+    return result;
+}
+
+QList<KUserGroup> KUserGroup::allGroups()
+{
+    QList<KUserGroup> result;
+
+    result.append(KUserGroup(""));
+
+    return result;
+}
+
+QStringList KUserGroup::allGroupNames()
+{
+    QStringList result;
+
+    result.append("wince");
+
+    return result;
+}
+
+KUserGroup::~KUserGroup()
+{
+}
Index: kdecore/CMakeLists.txt
===================================================================
--- kdecore/CMakeLists.txt
+++ kdecore/CMakeLists.txt
@@ -83,9 +83,17 @@
       util/kde_file_win.cpp
       util/kmacroexpander_win.cpp
       util/kshell_win.cpp
-      util/kuser_win.cpp
       date/ktimezone_win.cpp
    )
+   if(NOT WINCE)
+       LIST(APPEND kdecore_OPTIONAL_SRCS
+          util/kuser_win.cpp
+       )
+   else(NOT WINCE)
+       LIST(APPEND kdecore_OPTIONAL_SRCS
+          util/kuser_wince.cpp
+       )
+   endif(NOT WINCE)
    if(NOT MSVC)
       LIST(APPEND kdecore_OPTIONAL_SRCS
          network/netsupp.cpp
@@ -309,6 +317,10 @@
 
 target_link_libraries(kdecore ${QT_QTCORE_LIBRARY} ${QT_QTNETWORK_LIBRARY} ${QT_QTDBUS_LIBRARY} ${QT_QTXML_LIBRARY} ${ZLIB_LIBRARY} ${kdecore_OPTIONAL_LIBS})
 
+if(WINCE)
+  target_link_libraries(kdecore ${WCECOMPAT_LIBRARIES} Ceshell.lib)
+endif(WINCE)
+
 if(WIN32)
   set(kdecore_LINK_INTERFACE_LIBRARIES  ${QT_QTDBUS_LIBRARY} ${QT_QTCORE_LIBRARY} ${KDEWIN_LIBRARIES})
 else(WIN32)
@@ -387,16 +399,18 @@
 
 ########### next target ###############
 
-if (WIN32)
+if (WIN32 AND NOT WINCE)
     kde4_add_executable(kcmdwrapper NOGUI io/kcmdwrapper.cpp )
 
     target_link_libraries(kcmdwrapper kernel32 shell32 )
 
     install(TARGETS kcmdwrapper DESTINATION ${LIBEXEC_INSTALL_DIR} )
-endif (WIN32)
+endif (WIN32 AND NOT WINCE)
 
 ########### next target ###############
 
+if(NOT WINCE)
+
 # kjs hash stuff for transcript plugin
 set( CREATE_HASH_TABLE ${CMAKE_SOURCE_DIR}/kjs/create_hash_table )
 
@@ -427,6 +441,8 @@
 
 install( TARGETS ktranscript DESTINATION ${PLUGIN_INSTALL_DIR} )
 
+endif(NOT WINCE)
+
 ########### install files ###############
 install( FILES ${CMAKE_CURRENT_BINARY_DIR}/all_languages DESTINATION ${LOCALE_INSTALL_DIR}  )
 install( FILES kdebug.areas kdebugrc DESTINATION ${CONFIG_INSTALL_DIR} )
Index: knewstuff/knewstuff3/core/installation.cpp
===================================================================
--- knewstuff/knewstuff3/core/installation.cpp
+++ knewstuff/knewstuff3/core/installation.cpp
@@ -370,12 +370,16 @@
         }
         if (!d->installPath.isEmpty()) {
 #if defined(Q_WS_WIN)
+#ifndef _WIN32_WCE
             WCHAR wPath[MAX_PATH+1];
             if ( SHGetFolderPathW(NULL, CSIDL_APPDATA, NULL, SHGFP_TYPE_CURRENT, wPath) == S_OK) {
                 installdir = QString::fromUtf16((const ushort *) wPath) + QLatin1Char('/') + installpath + QLatin1Char('/');
             } else {
+#endif
                 installdir =  QDir::home().path() + QLatin1Char('/') + d->installPath + QLatin1Char('/');
+#ifndef _WIN32_WCE
             }
+#endif
 #else
             installdir = QDir::home().path() + '/' + d->installPath + '/';
 #endif
Index: knewstuff/knewstuff2/core/coreengine.cpp
===================================================================
--- knewstuff/knewstuff2/core/coreengine.cpp
+++ knewstuff/knewstuff2/core/coreengine.cpp
@@ -1407,12 +1407,16 @@
         }
         if (!m_installation->installPath().isEmpty()) {
 #if defined(Q_WS_WIN)
+#ifndef _WIN32_WCE
             WCHAR wPath[MAX_PATH+1];
             if ( SHGetFolderPathW(NULL, CSIDL_APPDATA, NULL, SHGFP_TYPE_CURRENT, wPath) == S_OK) {
                 installdir = QString::fromUtf16((const ushort *) wPath) + QLatin1Char('/') + m_installation->installPath() + QLatin1Char('/');
             } else {
+#endif
                 installdir =  QDir::home().path() + QLatin1Char('/') + m_installation->installPath() + QLatin1Char('/');
+#ifndef _WIN32_WCE
             }
+#endif
 #else
             installdir = QDir::home().path() + '/' + m_installation->installPath() + '/';
 #endif
Index: kdoctools/CMakeLists.txt
===================================================================
--- kdoctools/CMakeLists.txt
+++ kdoctools/CMakeLists.txt
@@ -29,6 +29,10 @@
 
 target_link_libraries(kio_help  ${KDE4_KDECORE_LIBS} kio ${LIBXML2_LIBRARIES} ${LIBXSLT_LIBRARIES} )
 
+if(WINCE)
+  target_link_libraries(kio_help ${WCECOMPAT_LIBRARIES})
+endif(WINCE)
+
 install(TARGETS kio_help  DESTINATION ${PLUGIN_INSTALL_DIR} )
 
 
@@ -41,6 +45,10 @@
 
 target_link_libraries(kio_ghelp  ${KDE4_KDECORE_LIBS} kio ${LIBXML2_LIBRARIES} ${LIBXSLT_LIBRARIES} )
 
+if(WINCE)
+  target_link_libraries(kio_ghelp ${WCECOMPAT_LIBRARIES})
+endif(WINCE)
+
 install(TARGETS kio_ghelp  DESTINATION ${PLUGIN_INSTALL_DIR} )
 
 
Index: kded/kded.cpp
===================================================================
--- kded/kded.cpp
+++ kded/kded.cpp
@@ -880,7 +880,7 @@
      KCmdLineArgs::addCmdLineOptions( options );
 
      // WABA: Make sure not to enable session management.
-     putenv(strdup("SESSION_MANAGER="));
+     putenv(qstrdup("SESSION_MANAGER="));
 
      // Parse command line before checking DCOP
      KCmdLineArgs *args = KCmdLineArgs::parsedArgs();
@@ -917,7 +917,9 @@
 
      Kded *kded = new Kded(); // Build data base
 
+#ifndef _WIN32_WCE
      KDE_signal(SIGTERM, sighandler);
+#endif
      KDE_signal(SIGHUP, sighandler);
      KDEDApplication k;
      k.setQuitOnLastWindowClosed(false);
Index: kded/CMakeLists.txt
===================================================================
--- kded/CMakeLists.txt
+++ kded/CMakeLists.txt
@@ -26,7 +26,11 @@
 target_link_libraries( kded4 kdeinit_kded4 )
 install(TARGETS kded4 ${INSTALL_TARGETS_DEFAULT_ARGS} )
 
+if(WINCE)
+  target_link_libraries(kded4 ${WCECOMPAT_LIBRARIES})
+endif(WINCE)
 
+
 qt4_generate_dbus_interface( kdedadaptor.h org.kde.kded.xml )
 install(FILES ${CMAKE_CURRENT_BINARY_DIR}/org.kde.kded.xml DESTINATION ${DBUS_INTERFACES_INSTALL_DIR})
 
@@ -58,6 +62,9 @@
 install(TARGETS kdeinit_kbuildsycoca4 ${INSTALL_TARGETS_DEFAULT_ARGS})
 
 target_link_libraries( kbuildsycoca4 kdeinit_kbuildsycoca4 )
+if(WINCE)
+  target_link_libraries(kbuildsycoca4 ${WCECOMPAT_LIBRARIES})
+endif(WINCE)
 install(TARGETS kbuildsycoca4 ${INSTALL_TARGETS_DEFAULT_ARGS} )
 
 ########### next target ###############
Index: solid/solid/CMakeLists.txt
===================================================================
--- solid/solid/CMakeLists.txt
+++ solid/solid/CMakeLists.txt
@@ -170,7 +170,7 @@
 endif(APPLE)
 
 # TODO: mingw
-if(MSVC)
+if(MSVC AND NOT WINCE)
    message(STATUS "-- Building Solid WMI backend." )
 
    set(solid_LIB_SRCS ${solid_LIB_SRCS}
@@ -197,7 +197,7 @@
    backends/wmi/wmivolume.cpp
 
    )
-endif(MSVC)
+endif(MSVC AND NOT WINCE)
 
 set_source_files_properties( org.freedesktop.PowerManagement.xml
                              org.freedesktop.PowerManagement.Inhibit.xml
@@ -224,6 +224,10 @@
 target_link_libraries(solid ${QT_QTCORE_LIBRARY} ${QT_QTDBUS_LIBRARY} ${QT_QTXML_LIBRARY} ${QT_QTGUI_LIBRARY} ${solid_OPTIONAL_LIBS})
 target_link_libraries(solid LINK_INTERFACE_LIBRARIES ${QT_CORE_LIBRARY} )
 
+if (WINCE)
+   target_link_libraries(solid ${WCECOMPAT_LIBRARIES})
+endif(WINCE)
+
 set_target_properties(solid PROPERTIES
    VERSION ${GENERIC_LIB_VERSION}
    SOVERSION ${GENERIC_LIB_SOVERSION}
Index: solid/solid/managerbase.cpp
===================================================================
--- solid/solid/managerbase.cpp
+++ solid/solid/managerbase.cpp
@@ -27,7 +27,7 @@
 #include "backends/iokit/iokitmanager.h"
 #elif defined (Q_OS_UNIX)
 #include "backends/hal/halmanager.h"
-#elif defined (_MSC_VER) // TODO: mingw
+#elif defined (_MSC_VER) && !defined(_WIN32_WCE) // TODO: mingw
 #include "backends/wmi/wmimanager.h"
 #endif
 
@@ -52,7 +52,7 @@
             m_backend = new Solid::Backends::IOKit::IOKitManager(0);
 #        elif defined (Q_OS_UNIX)
             m_backend = new Solid::Backends::Hal::HalManager(0);
-#        elif defined (_MSC_VER) // TODO: mingw
+#        elif defined (_MSC_VER) && !defined(_WIN32_WCE) // TODO: mingw
             m_backend = new Solid::Backends::Wmi::WmiManager(0);
 #        endif
     }
Index: CMakeLists.txt
===================================================================
--- CMakeLists.txt
+++ CMakeLists.txt
@@ -16,6 +16,13 @@
 
 set (KDE_DISTRIBUTION_TEXT "compiled sources" CACHE STRING "Indicate the distribution in bug reports" )
 
+IF(WINCE)
+    FIND_PACKAGE(WCECOMPAT REQUIRED)
+    #INCLUDE_DIRECTORIES(${WCECOMPAT_INCLUDE_DIR})
+    #SET(CMAKE_REQUIRED_INCLUDES ${CMAKE_REQUIRED_INCLUDES} ${WCECOMPAT_INCLUDE_DIR})
+    #SET(CMAKE_REQUIRED_LIBRARIES ${CMAKE_REQUIRED_LIBRARIES} ${WCECOMPAT_LIBRARIES})
+ENDIF(WINCE)
+
 # win32: give kde home in debug mode a different name as the  release home dir because the settings and caches are different
 if (WIN32 AND CMAKE_BUILD_TYPE STREQUAL "Debug")
     set (_KDE_DEFAULT_HOME_POSTFIX "-debug" CACHE STRING "default KDE home directory postfix" )
@@ -105,6 +112,11 @@
 macro_optional_find_package(QCA2)
 macro_log_feature(QCA2_FOUND "QCA2" "Qt Cryptographic Architecture" "http://delta.affinix.com/qca" FALSE "2.0.0" "Needed for the plasma remote widgets functionality.")
 
+if(WINCE)
+    SET(QT_DBUSCPP2XML_EXECUTABLE ${HOST_BINDIR}/qdbuscpp2xml.exe)
+    SET(QT_DBUSXML2CPP_EXECUTABLE ${HOST_BINDIR}/qdbusxml2cpp.exe)
+endif(WINCE)
+
 ################# Disallow in-source build #################
 
 macro_ensure_out_of_source_build("kdelibs requires an out of source build. Please create a separate build directory and run 'cmake path_to_kdelibs [options]' there.")
@@ -140,8 +152,12 @@
 set(KDE4_KJS_INCLUDES ${CMAKE_SOURCE_DIR}/kjs
                       ${CMAKE_BINARY_DIR}/kjs)
 
+if(NOT WINCE)
+    set(KDE4_KDECORE_INCLUDES ${KDE4_KJS_INCLUDES} )
+endif(NOT WINCE)
+
 # kdecore depends on Qt (need only headers from kjs)
-set(KDE4_KDECORE_INCLUDES ${KDE4_KJS_INCLUDES}
+set(KDE4_KDECORE_INCLUDES ${KDE4_KDECORE_INCLUDES}
                           ${CMAKE_SOURCE_DIR}/kdecore
                           ${CMAKE_BINARY_DIR}/kdecore
                           ${CMAKE_SOURCE_DIR}/kdecore/compression
@@ -204,7 +220,9 @@
                               ${CMAKE_SOURCE_DIR}/kde3support/kio
                               ${KDE4_KPARTS_INCLUDES})
 
+if(NOT WINCE)
 set(KDE4_KHTML_INCLUDES ${CMAKE_SOURCE_DIR}/khtml)
+endif(NOT WINCE)
 
 
 ################# configure checks and create the configured files #################
@@ -246,8 +264,10 @@
    add_subdirectory( kpty )
    add_subdirectory( kdesu )
 endif (UNIX)
+if(NOT WINCE)
 add_subdirectory( kjs )
 add_subdirectory( kjsembed )
+endif(NOT WINCE)
 add_subdirectory( kio )
 add_subdirectory( solid )
 add_subdirectory( kded       )
@@ -256,7 +276,9 @@
 endif (QT_QT3SUPPORT_FOUND)
 add_subdirectory( kfile )
 add_subdirectory( kconf_update )
+if(NOT WINCE)
 add_subdirectory( kdoctools  )
+endif(NOT WINCE)
 add_subdirectory( kioslave   )
 add_subdirectory( knewstuff  )
 add_subdirectory( kparts     )
@@ -266,12 +288,18 @@
 add_subdirectory( kinit  )
 add_subdirectory( threadweaver )
 add_subdirectory( sonnet  )
+if(NOT WINCE)
 add_subdirectory( khtml  )
+endif(NOT WINCE)
 add_subdirectory( interfaces  )
 add_subdirectory( kdewidgets  )
+if(NOT WINCE)
 add_subdirectory( kate  )
+endif(NOT WINCE)
 add_subdirectory( knotify )
+if(NOT WINCE)
 add_subdirectory( kimgio )
+endif(NOT WINCE)
 add_subdirectory( dnssd )
 add_subdirectory( kross )
 add_subdirectory( security )
@@ -280,7 +308,9 @@
 add_subdirectory( kdewebkit )
 add_subdirectory( includes )
 
+if(NOT WINCE)
 macro_optional_add_subdirectory( doc  )
+endif(NOT WINCE)
 
 ################# write dependency file which will be installed #################
 
Index: kdeui/kernel/kuniqueapplication.cpp
===================================================================
--- kdeui/kernel/kuniqueapplication.cpp
+++ kdeui/kernel/kuniqueapplication.cpp
@@ -77,7 +77,9 @@
 #ifdef Q_WS_WIN
 QString KUniqueApplication::Private::s_dbusServiceName;
 /* private helpers from kapplication_win.cpp */
+#ifndef _WIN32_WCE
 void KApplication_activateWindowForProcess( const QString& executableName );
+#endif
 bool KApplication_dbusIsPatched();
 #endif
 
@@ -165,7 +167,7 @@
      {
         kError() << "KUniqueApplication: Can't setup D-Bus service. Probably already running."
                  << endl;
-#ifdef Q_WS_WIN
+#if defined(Q_WS_WIN) && !defined(_WIN32_WCE)
         KApplication_activateWindowForProcess(KCmdLineArgs::aboutData()->appName());
 #endif
         ::exit(255);
Index: kdeui/kernel/kapplication_win.cpp
===================================================================
--- kdeui/kernel/kapplication_win.cpp
+++ kdeui/kernel/kapplication_win.cpp
@@ -56,8 +56,9 @@
 
     // For apps like KMail which have lots of open files, the default is too low
 	// so increase it to the maximum.
+#ifndef _WIN32_WCE
     _setmaxstdio(2048);
-
+#endif
 }
 
 // <copy of kdepim/libkdepim/utils.cpp, TODO: move to a shared helper library>
@@ -119,6 +120,7 @@
     : QString::fromUcs4((uint *)string, size);
 }
 
+#ifndef _WIN32_WCE
 void KApplication_getProcessesIdForName( const QString& processName, QList<int>& pids )
 {
   qDebug() << "KApplication_getProcessesIdForName" << processName;
@@ -258,6 +260,7 @@
     return;
   KWindowSystem::forceActiveWindow( winStruct.windowId, 0 );
 }
+#endif
 
 // </copy>
 
Index: kdeui/kernel/kglobalsettings.cpp
===================================================================
--- kdeui/kernel/kglobalsettings.cpp
+++ kdeui/kernel/kglobalsettings.cpp
@@ -578,10 +578,15 @@
     }
 #ifdef Q_WS_WIN
     //not cached
+#ifndef _WIN32_WCE
     mMouseSettings->handed = (GetSystemMetrics(SM_SWAPBUTTON) ?
         KGlobalSettings::KMouseSettings::LeftHanded :
         KGlobalSettings::KMouseSettings::RightHanded);
+#else
+// There is no mice under wince
+    mMouseSettings->handed =KGlobalSettings::KMouseSettings::RightHanded;
 #endif
+#endif
     return *mMouseSettings;
 }
 // KDE5: make this a const return?
Index: kdeui/windowmanagement/kwindowsystem_win.cpp
===================================================================
--- kdeui/windowmanagement/kwindowsystem_win.cpp
+++ kdeui/windowmanagement/kwindowsystem_win.cpp
@@ -34,7 +34,6 @@
 #include <windows.h>
 #include <windowsx.h>
 
-
 //function to register us as taskmanager
 #define RSH_UNREGISTER  0
 #define RSH_REGISTER    1
@@ -223,9 +222,12 @@
             KWindowSystem::s_d_func()->windowRemoved(reinterpret_cast<WId>(message->lParam));
             break;
           case HSHELL_WINDOWACTIVATED:
+#ifndef _WIN32_WCE
           case HSHELL_RUDEAPPACTIVATED:
+#endif
             KWindowSystem::s_d_func()->windowActivated(reinterpret_cast<WId>(message->lParam));
             break;
+#ifndef _WIN32_WCE
           case HSHELL_GETMINRECT:
             KWindowSystem::s_d_func()->windowStateChanged(reinterpret_cast<WId>(message->lParam));
             break;
@@ -235,6 +237,7 @@
           case HSHELL_FLASH:
             KWindowSystem::s_d_func()->windowFlash(reinterpret_cast<WId>(message->lParam));
             break;
+#endif
         }
     }
     return QWidget::winEvent(message,result);
@@ -242,13 +245,13 @@
 
 bool CALLBACK KWindowSystemPrivate::EnumWindProc(WId hWnd, LPARAM lparam)
 {
-    QByteArray windowText = QByteArray ( GetWindowTextLength(hWnd)+1, 0 ) ;
-    GetWindowTextA(hWnd, windowText.data(), windowText.size());
+    QByteArray windowText = QByteArray ( (GetWindowTextLength(hWnd)+1) * sizeof(wchar_t), 0 ) ;
+    GetWindowTextW(hWnd, (LPWSTR)windowText.data(), windowText.size());
 	DWORD ex_style = GetWindowExStyle(hWnd);
     KWindowSystemPrivate *p = KWindowSystem::s_d_func();
 
     QString add;
-    if( !QString(windowText).trimmed().isEmpty() && IsWindowVisible( hWnd ) && !(ex_style&WS_EX_TOOLWINDOW)
+    if( !QString::fromWCharArray((wchar_t*)windowText.data()).trimmed().isEmpty() && IsWindowVisible( hWnd ) && !(ex_style&WS_EX_TOOLWINDOW)
        && !GetParent(hWnd) && !GetWindow(hWnd,GW_OWNER) && !p->winInfos.contains(hWnd) ) {
 
 //        kDebug()<<"Adding window to windowList " << add + QString(windowText).trimmed();
@@ -264,15 +267,17 @@
 
 void KWindowSystemPrivate::readWindowInfo ( WId hWnd , InternalWindowInfo *winfo)
 {
-    QByteArray windowText = QByteArray ( GetWindowTextLength(hWnd)+1, 0 ) ;
-    GetWindowTextA(hWnd, windowText.data(), windowText.size());
+    QByteArray windowText = QByteArray ( (GetWindowTextLength(hWnd)+1) * sizeof(wchar_t), 0 ) ;
+    GetWindowTextW(hWnd, (LPWSTR)windowText.data(), windowText.size());
      //maybe use SendMessageTimout here?
     QPixmap smallIcon;
     HICON hSmallIcon = (HICON)SendMessage(hWnd, WM_GETICON, ICON_SMALL, 0);
     //if(!hSmallIcon) hSmallIcon = (HICON)SendMessage(hWnd, WM_GETICON, ICON_SMALL2, 0);
     if(!hSmallIcon) hSmallIcon = (HICON)SendMessage(hWnd, WM_GETICON, ICON_BIG, 0);
+#ifndef _WIN32_WCE
     if(!hSmallIcon) hSmallIcon = (HICON)GetClassLong(hWnd, GCL_HICONSM);
     if(!hSmallIcon) hSmallIcon = (HICON)GetClassLong(hWnd, GCL_HICON);
+#endif
     if(!hSmallIcon) hSmallIcon = (HICON)SendMessage(hWnd, WM_QUERYDRAGICON, 0, 0);
     if(hSmallIcon)  smallIcon  = HIcon2QPixmap(hSmallIcon);
 
@@ -280,14 +285,16 @@
     HICON hBigIcon = (HICON)SendMessage(hWnd, WM_GETICON, ICON_BIG, 0);
     //if(!hBigIcon) hBigIcon = (HICON)SendMessage(hWnd, WM_GETICON, ICON_SMALL2, 0);
     if(!hBigIcon) hBigIcon = (HICON)SendMessage(hWnd, WM_GETICON, ICON_SMALL, 0);
+#ifndef _WIN32_WCE
     if(!hBigIcon) hBigIcon = (HICON)GetClassLong(hWnd, GCL_HICON);
     if(!hBigIcon) hBigIcon = (HICON)GetClassLong(hWnd, GCL_HICONSM);
+#endif
     if(!hBigIcon) hBigIcon = (HICON)SendMessage(hWnd, WM_QUERYDRAGICON, 0, 0);
     if(hBigIcon)  bigIcon  = HIcon2QPixmap(hBigIcon);
 
     winfo->bigIcon    = bigIcon;
     winfo->smallIcon  = smallIcon;
-    winfo->windowName = QString(windowText).trimmed();
+    winfo->windowName = QString::fromWCharArray((wchar_t*)windowText.data()).trimmed();
 }
 
 
@@ -427,17 +434,21 @@
     // But the mouse cursor still acts as if the widgets were there (e.g. button clicking works),
     // which indicates the issue is at the window/backingstore level.
     // This is probably a side effect of bypassing Qt's internal window state handling.
+#ifndef _WIN32_WCE
     if ( IsIconic( win ) /*|| !IsWindowVisible( win ) */) {
         // Do not activate the window as we restore it,
         // otherwise the window appears see-through (contents not updated).
         ShowWindow( win, SW_SHOWNOACTIVATE );
     }
+#endif
     // Puts the window in front and activates it.
     SetForegroundWindow( win );
 }
 
 void KWindowSystem::demandAttention( WId win, bool set )
 {
+// One can not flash a windows in wince
+#ifndef _WIN32_WCE
     FLASHWINFO fi;
     fi.cbSize = sizeof( FLASHWINFO );
     fi.hwnd = win;
@@ -446,6 +457,7 @@
     fi.dwTimeout = 0;
 
     FlashWindowEx( &fi );
+#endif
 }
 
 
@@ -500,11 +512,13 @@
 void KWindowSystem::setState( WId win, unsigned long state )
 {
     bool got = false;
+#ifndef _WIN32_WCE
     if (state & NET::SkipTaskbar) {
         got = true;
         LONG_PTR lp = GetWindowLongPtr(win, GWL_EXSTYLE);
         SetWindowLongPtr(win, GWL_EXSTYLE, lp | WS_EX_TOOLWINDOW);
     }
+#endif
     if (state & NET::KeepAbove) {
         got = true;
         SetWindowPos(win, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
@@ -525,11 +539,13 @@
 {
     bool got = false;
 
+#ifndef _WIN32_WCE
     if (state & NET::SkipTaskbar) {
         got = true;
         LONG_PTR lp = GetWindowLongPtr(win, GWL_EXSTYLE);
         SetWindowLongPtr(win, GWL_EXSTYLE, lp & ~WS_EX_TOOLWINDOW);
     }
+#endif
     if (state & NET::KeepAbove) {
         got = true;
         //lets hope this remove the topmost
@@ -686,7 +702,9 @@
 
 void KWindowSystem::allowExternalProcessWindowActivation( int pid )
 {
+#ifndef _WIN32_WCE
     AllowSetForegroundWindow( pid == -1 ? ASFW_ANY : pid );
+#endif
 }
 
 #include "kwindowsystem.moc"
Index: kdeui/windowmanagement/kwindowinfo_win.cpp
===================================================================
--- kdeui/windowmanagement/kwindowinfo_win.cpp
+++ kdeui/windowmanagement/kwindowinfo_win.cpp
@@ -99,14 +99,18 @@
 unsigned long KWindowInfo::state() const
 {
     unsigned long state = 0;
+#ifndef _WIN32_WCE
      if(IsZoomed(d->win_))
         state |= NET::Max;
+#endif
      if(!IsWindowVisible(d->win_))
         state |= NET::Hidden;
-        
+     
+#ifndef _WIN32_WCE     
     LONG_PTR lp = GetWindowLongPtr(d->win_, GWL_EXSTYLE);
     if(lp & WS_EX_TOOLWINDOW)
         state |= NET::SkipTaskbar;
+#endif
         
     return state;
 }
@@ -118,13 +122,19 @@
 
 bool KWindowInfo::isMinimized() const
 {
+#ifndef _WIN32_WCE
     return IsIconic(d->win_);
+#else
+    return false;
+#endif
 }
 
 NET::MappingState KWindowInfo::mappingState() const
 {    
+#ifndef _WIN32_WCE
     if(IsIconic(d->win_))
         return NET::Iconic;  
+#endif
     if(!IsWindowVisible(d->win_)) 
         return NET::Withdrawn;
     return NET::Visible;
@@ -165,9 +175,9 @@
 
 QString KWindowInfo::name() const
 {
-    QByteArray windowText = QByteArray ( GetWindowTextLength(d->win_)+1, 0 ) ;
-    GetWindowTextA(d->win_, windowText.data(), windowText.size());
-    return QString(windowText);
+    QByteArray windowText = QByteArray ( (GetWindowTextLength(d->win_)+1) * sizeof(wchar_t), 0 ) ;
+    GetWindowTextW(d->win_, (LPWSTR)windowText.data(), windowText.size());
+    return QString::fromWCharArray((wchar_t*)windowText.data());
 }
 
 QString KWindowInfo::visibleIconNameWithState() const
Index: kdeui/CMakeLists.txt
===================================================================
--- kdeui/CMakeLists.txt
+++ kdeui/CMakeLists.txt
@@ -68,7 +68,6 @@
  dialogs/kconfigdialog.cpp
  dialogs/kconfigdialogmanager.cpp
  dialogs/kbugreport.cpp
- dialogs/kdeprintdialog.cpp
  dialogs/kdialog.cpp
  dialogs/kedittoolbar.cpp
  dialogs/kinputdialog.cpp
@@ -252,6 +251,13 @@
  xmlgui/kxmlguiversionhandler.cpp
 )
 
+if(NOT WINCE)
+set(kdeui_LIB_SRCS
+ ${kdeui_LIB_SRCS}
+ dialogs/kdeprintdialog.cpp
+)
+endif(NOT WINCE)
+
 if (Q_WS_X11)
     set(kdeui_LIB_SRCS ${kdeui_LIB_SRCS} util/kkeyserver_x11.cpp
                                          dialogs/kcupsoptionswidget_p.cpp
@@ -369,6 +375,10 @@
    target_link_libraries(kdeui ${X11_Xrender_LIB})
 endif(X11_Xrender_FOUND)
 
+if (WINCE)
+   target_link_libraries(kdeui ${WCECOMPAT_LIBRARIES})
+endif(WINCE)
+
 target_link_libraries(kdeui LINK_INTERFACE_LIBRARIES kdecore ${QT_QTSVG_LIBRARY} ${QT_QTGUI_LIBRARY})
 
 set_target_properties(kdeui PROPERTIES VERSION ${KDE_NON_GENERIC_LIB_VERSION} 
Index: kdeui/dialogs/kshortcutseditor.cpp
===================================================================
--- kdeui/dialogs/kshortcutseditor.cpp
+++ kdeui/dialogs/kshortcutseditor.cpp
@@ -613,6 +613,8 @@
 */
 void KShortcutsEditorPrivate::printShortcuts() const
 {
+// One cant print on wince
+#ifndef _WIN32_WCE
     QTreeWidgetItem* root = ui.list->invisibleRootItem();
     QTextDocument doc;
     doc.setDefaultFont(KGlobalSettings::generalFont());
@@ -716,6 +718,7 @@
         doc.print(&printer);
     }
     delete dlg;
+#endif
 }
 
 #include "kshortcutseditor.moc"
Index: kdeui/util/kkeyserver_win.cpp
===================================================================
--- kdeui/util/kkeyserver_win.cpp
+++ kdeui/util/kkeyserver_win.cpp
@@ -43,7 +43,10 @@
         { Qt::Key_Pause,            VK_PAUSE },
         { Qt::Key_CapsLock,         VK_CAPITAL },
         { Qt::Key_Escape,           VK_ESCAPE },
+//FIXME: under wince VK_MODECHANGE is not defined
+#ifndef _WIN32_WCE
         { Qt::Key_Mode_switch,          VK_MODECHANGE },
+#endif
         { Qt::Key_Space,            VK_SPACE },
         { Qt::Key_PageUp,           VK_PRIOR },
         { Qt::Key_PageDown,         VK_NEXT },
