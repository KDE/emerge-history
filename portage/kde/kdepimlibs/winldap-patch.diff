Index: kldap/ldapconnection.cpp
===================================================================
--- kldap/ldapconnection.cpp	(revision 1200316)
+++ kldap/ldapconnection.cpp	(working copy)
@@ -43,8 +43,12 @@
 #endif
 
 #ifdef LDAP_FOUND
-#include <lber.h>
-#include <ldap.h>
+# ifndef HAVE_WINLDAP_H
+#  include <lber.h>
+#  include <ldap.h>
+#else
+# include <w32-ldap-help.h>
+#endif // HAVE_WINLDAP_H
 
 #ifndef LDAP_OPT_SUCCESS
 #define LDAP_OPT_SUCCESS 0
Index: kldap/ldapoperation.cpp
===================================================================
--- kldap/ldapoperation.cpp	(revision 1200316)
+++ kldap/ldapoperation.cpp	(working copy)
@@ -35,9 +35,13 @@
 #endif
 
 #ifdef LDAP_FOUND
-#include <lber.h>
-#include <ldap.h>
-#endif
+# ifndef HAVE_WINLDAP_H
+#  include <lber.h>
+#  include <ldap.h>
+# else
+#  include <w32-ldap-help.h>
+# endif // HAVE_WINLDAP_H
+#endif // LDAP_FOUND
 
 #include "ldapdefs.h"
 
@@ -245,7 +249,7 @@
   int ret;
 
   if ( server.auth() == LdapServer::SASL ) {
-#ifdef SASL2_FOUND
+#if defined( SASL2_FOUND ) && !defined( HAVE_WINLDAP_H )
     sasl_conn_t *saslconn = (sasl_conn_t *)mConnection->saslHandle();
     sasl_interact_t *client_interact = NULL;
     const char *out = NULL;
@@ -333,7 +337,7 @@
     } while ( !async && ret == KLDAP_SASL_BIND_IN_PROGRESS );
 #else
     kError() << "SASL authentication is not available "
-             << "(re-compile kldap with cyrus-sasl development).";
+             << "(re-compile kldap with cyrus-sasl and OpenLDAP development).";
     return KLDAP_SASL_ERROR;
 #endif
   } else { //simple auth
@@ -350,15 +354,21 @@
     if ( async ) {
       kDebug() << "ldap_sasl_bind (simple)";
       int msgid;
+#ifndef HAVE_WINLDAP_H
       ret = ldap_sasl_bind( ld, bindname.data(), 0, &ccred, 0, 0, &msgid );
-//    ret = ldap_simple_bind( ld, bindname.data(),pass.data() );
+#else
+      ret = ldap_simple_bind( ld, bindname.data(),pass.data() );
+#endif
       if ( ret == 0 ) {
         ret = msgid;
       }
     } else {
       kDebug() << "ldap_sasl_bind_s (simple)";
+#ifndef HAVE_WINLDAP_H
       ret = ldap_sasl_bind_s( ld, bindname.data(), 0, &ccred, 0, 0, 0 );
-//    ret = ldap_simple_bind_s( ld, bindname.data(), pass.data() );
+#else
+      ret = ldap_simple_bind_s( ld, bindname.data(), pass.data() );
+#endif
     }
   }
   return ret;
@@ -430,16 +440,25 @@
   }
   case RES_BIND:
   {
-    struct berval *servercred;
+    struct berval *servercred = 0;
+#ifndef HAVE_WINLDAP_H
+    // FIXME: Error handling Winldap does not have ldap_parse_sasl_bind_result
     retval = ldap_parse_sasl_bind_result( ld, msg, &servercred, 0 );
+#else
+    retval = KLDAP_SUCCESS;
+#endif
     if ( retval != KLDAP_SUCCESS && retval != KLDAP_SASL_BIND_IN_PROGRESS ) {
-      kDebug() << "RES_BIND error: " << retval;
+      qDebug() << "RES_BIND error: " << retval;
       ldap_msgfree( msg );
       return -1;
     }
-    kDebug() << "RES_BIND rescode" << rescode << "retval:" << retval;
-    mServerCred = servercred ? QByteArray( servercred->bv_val, servercred->bv_len ) : QByteArray();
-    ber_bvfree( servercred );
+    qDebug() << "RES_BIND rescode" << rescode << "retval:" << retval;
+    if ( servercred ) {
+      mServerCred = QByteArray( servercred->bv_val, servercred->bv_len );
+      ber_bvfree( servercred );
+    } else {
+      mServerCred = QByteArray();
+    }
     break;
   }
   default:
Index: kldap/kldap_config.h.cmake
===================================================================
--- kldap/kldap_config.h.cmake	(revision 1200316)
+++ kldap/kldap_config.h.cmake	(working copy)
@@ -1,5 +1,7 @@
 #cmakedefine LDAP_FOUND
 #cmakedefine SASL2_FOUND
+#cmakedefine HAVE_WINLDAP_H
+#cmakedefine HAVE_LDAP_H
 #cmakedefine HAVE_SYS_TIME_H
 #cmakedefine HAVE_LDAP_START_TLS_S
 #cmakedefine HAVE_LDAP_INITIALIZE
Index: kldap/ber.cpp
===================================================================
--- kldap/ber.cpp	(revision 1200316)
+++ kldap/ber.cpp	(working copy)
@@ -34,15 +34,23 @@
 #define BC31 1
 #endif
 
+#ifndef HAVE_WINLDAP_H
 #include <lber.h>
 #include <ldap.h>
+#else
+#include <w32-ldap-help.h>
+#endif
 
 #ifndef LBER_USE_DER
 #define LBER_USE_DER 1
 #endif
 
 #ifndef HAVE_BER_MEMFREE
-#define ber_memfree(x) ldap_memfree(x)
+# ifndef HAVE_WINLDAP_H
+#  define ber_memfree(x) ldap_memfree(x)
+# else
+#  define ber_memfree(x) win_ldap_memfree(x)
+# endif
 #endif
 
 #endif
Index: kldap/w32-ldap-help.h
===================================================================
--- kldap/w32-ldap-help.h	(revision 0)
+++ kldap/w32-ldap-help.h	(revision 0)
@@ -0,0 +1,1006 @@
+/* w32-ldap-help.h - Map utf8 based API into a wchar_t API.
+
+  Copyright (c) 2010 Andre Heinecke <aheinecke@intevation.de>
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Library General  Public
+  License as published by the Free Software Foundation; either
+  version 2 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Library General Public License for more details.
+
+  You should have received a copy of the GNU Library General Public License
+  along with this library; see the file COPYING.LIB.  If not, write to
+  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+  Boston, MA 02110-1301, USA.
+ */
+
+#ifndef W32_LDAP_HELP_H
+#define W32_LDAP_HELP_H
+
+#include <windows.h>
+#ifdef UNICODE
+# undef UNICODE
+# include <winldap.h>
+# include <winber.h>
+# define UNICODE
+#else
+# include <winldap.h>
+# include <winber.h>
+#endif // UNICODE
+
+// Redirect used ldap functions to functions with win_ prefix
+//#define ldap_err2string(a) win_ldap_err2string(a)
+#define ldap_init(a,b) win_ldap_init(a,b)
+#define ldap_sasl_bind(a, b, c, d, e, f, g) \
+        win_ldap_sasl_bind(a, b, c, d, e, f, g)
+#define ldap_sasl_bind_s(a, b, c, d, e, f, g) \
+        win_ldap_sasl_bind_s(a, b, c, d, e, f, g)
+#define ldap_parse_sasl_bind_result ( a, b, c, d, e ) \
+        win_ldap_parse_sasl_bind_result((a), (b), (c), (d), (e))
+#define ldap_get_dn(a, b) win_ldap_get_dn(a,b)
+#define ldap_memfree(a)      win_ldap_memfree(a)
+#define ldap_mods_free(a, b) win_ldap_mods_free(a, b)
+#define ldap_first_attribute(a, b, c) \
+        win_ldap_first_attribute(a, b, c)
+#define ldap_get_values_len(a, b, c) \
+        win_ldap_get_values_len(a, b, c)
+#define ldap_next_attribute(a, b, c ) \
+        win_ldap_next_attribute(a, b, c)
+#define ldap_parse_result(a, b, c, d, e, f, g, h) \
+        win_ldap_parse_result(a, b, c, d, e, f, g, h)
+#define ldap_parse_extended_result(a, b, c, d, e) \
+        win_ldap_parse_extended_result(a, b, c, d, e)
+#define ldap_add_ext(a, b, c, d, e, f) \
+        win_ldap_add_ext((a), (b), (c), (d), (e), (f))
+#define ldap_add_ext_s(a, b, c, d, e) \
+        win_ldap_add_ext_s((a), (b), (c), (d), (e))
+# define ldap_compare_ext_s(a, b, c, d, e, f) \
+  win_ldap_compare_ext_s((a), (b), (c), (d), (e), (f))
+# define ldap_compare_ext(a, b, c, d, e, f, g) \
+  win_ldap_compare_ext((a), (b), (c), (d), (e), (f), (g))
+# define ldap_modify_ext_s(a, b, c, d, e ) \
+  win_ldap_modify_ext_s((a), (b), (c), (d), (e))
+# define ldap_search_ext(a, b, c, d, e, f, g, h, i, j, k) \
+  win_ldap_search_ext((a), (b), (c), (d), (e), (f), (g), (h), (i), (j), (k))
+#define ldap_rename_ext( a,  b,  c,  d,  e,  f,  g,  h  ) \
+  win_ldap_rename_ext((a), (b), (c), (d), (e), (f), (g), (h) )
+#define ldap_rename( a,  b,  c,  d,  e,  f,  g,  h  ) \
+  ldap_rename_ext((a), (b), (c), (d), (e), (f), (g), (h) )
+#define ldap_delete_ext(a,  b,  c,  d,  e  ) \
+  win_ldap_delete_ext((a), (b), (c), (d), (e) )
+#define ldap_modify_ext(a,  b,  c,  d,  e,  f ) \
+  win_ldap_modify_ext( (a), (b), (c), (d), (e), (f))
+#define ldap_abandon_ext(a, b, c, d) \
+  win_ldap_abandon_ext((a), (b), (c), (d))
+#define ldap_controls_free(a) win_ldap_controls_free(a)
+#ifndef WIN32_WCE
+# define LDAPControl LDAPControlA
+# define LDAPMod LDAPModA
+#endif
+
+
+// Use the functions that are available on the platform
+// or redirect to wrapper functions
+#ifdef _WIN32_WCE
+#include "wce-ldap-help.h"
+# define win_ldap_init(a,b)                      \
+  my_win_ldap_initA ((a), (b))
+# define win_ldap_simple_bind_s(a,b,c)           \
+  my_win_ldap_simple_bind_sA ((a),(b),(c))
+/*# define win_ldap_sasl_bind(a, b, c, d, e, f, g) \
+  ldap_sasl_bindA(a, b, c, d, e, f, g)
+# define win_ldap_sasl_bind_result ( a, b, c, d, e ) \
+  my_win_ldap_sasl_bind_result (((a), (b), (c), (d), (e))
+# define win_ldap_sasl_bind_s(a, b, c, d, e, f, g) \
+  ldap_sasl_bind_s(a, b, c, d, e, f, g)*/
+# define win_ldap_search_st(a,b,c,d,e,f,g,h)     \
+  my_win_ldap_search_stA ((a), (b), (c), (d), (e), (f), (g), (h))
+# define win_ldap_first_attribute(a,b,c)         \
+  my_win_ldap_first_attributeA ((a),(b),(c))
+# define win_ldap_next_attribute(a,b,c)          \
+  my_win_ldap_next_attributeA ((a),(b),(c))
+# define win_ldap_get_values_len(a,b,c)          \
+  my_win_ldap_get_values_lenA ((a),(b),(c))
+# define win_ldap_get_dn(a,b)                    \
+  my_win_ldap_get_dnA((a),(b))
+# define win_ldap_parse_extended_result(a, b, c, d, e ) \
+  my_win_ldap_parse_extended_resultA((a), (b), (c), (d), (e))
+# define win_ldap_memfree(a) strfreeA(a)
+# define win_ldap_controls_free(a)              \
+  my_win_ldap_controls_freeA((a))
+# define win_ldap_mods_free(a, b)               \
+  my_win_ldap_mods_freeA((a), (b))
+# define win_ldap_parse_result(a, b, c, d, e, f, g, h ) \
+  my_win_ldap_parse_resultA((a), (b), ((ulong *) c), (d), (e), (f), (g), (h))
+# define win_ldap_search_ext(a, b, c, d, e, f, g, h, i, j, k) \
+  my_win_ldap_search_extA((a), (b), (c), (d), (e), (f), (g), (h), (i), (j), (k))
+# define win_ldap_add_ext_s(a, b, c, d, e) \
+  my_win_ldap_add_ext_sA((a), (b), (c), (d), (e))
+# define win_ldap_add_ext(a, b, c, d, e, f) \
+  my_win_ldap_add_extA((a), (b), (c), (d), (e), ( (ulong * ) f))
+#define win_ldap_rename_ext( a,  b,  c,  d,  e,  f,  g,  h  ) \
+  ldap_rename_extA((a), (b), (c), (d), (e), (f), (g), ( ( ulong * ) h) )
+#define win_ldap_delete_ext( a,  b,  c,  d,  e  ) \
+  ldap_delete_extA((a), (b), (c), (d), ( ( ulong* ) e) )
+#define win_ldap_modify_ext(  a,  b,  c,  d,  e,  f  ) \
+  ldap_modify_extA( (a), (b), (c), (d), (e), ( ( ulong * ) f) )
+#define win_ldap_modify_ext_s(  a,  b,  c,  d,  e ) \
+  ldap_modify_ext_sA( (a), (b), (c), (d),  (e) )
+# define win_ldap_compare_ext(a, b, c, d, e, f, g) \
+  my_win_ldap_compare_extA((a), (b), (c), NULL, (d), (e), (f), ( ( ulong* ) g))
+#define win_ldap_compare_ext_s(a, b, c, d, e, f) \
+  my_win_ldap_compare_ext_sA( (a), (b), (c), NULL, (d), (e), (f) )
+#define win_ldap_abandon_ext(a, b, c, d) \
+  ldap_abandon((a), (b))
+#else
+// Use ASCII Variants if possibile
+# define win_ldap_init(a,b)              ldap_initA ((a), (b))
+# define win_ldap_simple_bind_s(a,b,c)   ldap_simple_bind_sA ((a), (b), (c))
+# define win_ldap_sasl_bind(a, b, c, d, e, f, g) \
+  ldap_sasl_bindA(a, b, c, d, e, f, g)
+# define win_ldap_sasl_bind_s(a, b, c, d, e, f, g) \
+  ldap_sasl_bind_sA(a, b, c, d, e, f, g)
+# define win_ldap_search_st(a,b,c,d,e,f,g,h)     \
+  ldap_search_stA ((a), (b), (c), (d), (e), (f), (g), (h))
+# define win_ldap_search_ext(a, b, c, d, e, f, g, h, i, j, k) \
+  my_win_ldap_search_ext((a), (b), (c), (d), (e), (f), (g), (h), (i), (j), (k))
+# define win_ldap_get_dn(a, b)           ldap_get_dnA((a), (b))
+# define win_ldap_first_attribute(a,b,c) ldap_first_attributeA ((a), (b), (c))
+# define win_ldap_next_attribute(a,b,c)  ldap_next_attributeA ((a), (b), (c))
+# define win_ldap_get_values_len(a,b,c)  ldap_get_values_lenA ((a), (b), (c))
+# define win_ldap_memfree(a)             ldap_memfreeA ((a))
+# define win_ldap_err2string(a)          ldap_err2stringA((a))
+# define win_ldap_controls_free(a)       ldap_controls_freeA((a))
+# define win_ldap_mods_free(a, b)        ldap_mods_freeA((a), (b))
+# define win_ldap_add_ext(a, b, c, d, e, f) \
+  ldap_add_extA((a), (b), (c), (d), (e), ((ulong*)f))
+# define win_ldap_add_ext_s(a, b, c, d, e) \
+  ldap_add_ext_sA((a), (b), (c), (d), (e))
+# define win_ldap_parse_extended_result(a, b, c, d, e ) \
+  ldap_parse_extended_resultA((*a), (b), (c), (d), (e))
+# define win_ldap_parse_result(a, b, c, d, e, f, g, h ) \
+  ldap_parse_resultA((a), (b), ((ulong *)c), (d), (e), (f), (g), (h))
+# define win_ldap_modify_ext_s(a, b, c, d, e ) \
+  ldap_modify_ext_sW((a), (b), (c), (d), (e))
+# define win_ldap_compare_ext_s(a, b, c, d, e, f ) \
+  ldap_compare_ext_sA((a), (b), (c), (d), (e), (f))
+#endif /*WIN32_WCE*/
+
+/*
+ * From the openldap manpage:
+ * ber_len_t  is an unsigned integer of at least 32 bits used to represent
+ * a length.  It is commonly equivalent to a size_t.   ber_slen_t  is  the
+ *  signed variant to ber_len_t. 
+ */
+
+typedef ULONG ber_len_t;
+
+#ifndef timeval
+#define timeval l_timeval
+#endif
+
+#ifdef _WIN32_WCE
+static inline ULONG my_win_ldap_compare_ext_sA( LDAP *ld, PCHAR dn, PCHAR attr, PCHAR value,
+    struct berval *data, PLDAPControlA *serverctrls, PLDAPControlA *clientctrls )
+{
+    ULONG ret = LDAP_NOT_SUPPORTED;
+    WCHAR *dnW = NULL, *attrW = NULL, *valueW = NULL;
+    LDAPControlW **serverctrlsW = NULL, **clientctrlsW = NULL;
+
+    ret = LDAP_NO_MEMORY;
+
+    if (!ld) return LDAP_PARAM_ERROR;
+
+    if (dn) {
+        dnW = strAtoW( dn );
+        if (!dnW) goto exit;
+    }
+    if (attr) {
+        attrW = strAtoW( attr );
+        if (!attrW) goto exit;
+    }
+    if (value) {
+        valueW = strAtoW( value );
+        if (!valueW) goto exit;
+    }
+    if (serverctrls) {
+        serverctrlsW = controlarrayAtoW( serverctrls );
+        if (!serverctrlsW) goto exit;
+    }
+    if (clientctrls) {
+        clientctrlsW = controlarrayAtoW( clientctrls );
+        if (!clientctrlsW) goto exit;
+    }
+
+    ret = ldap_compare_ext_sW( ld, dnW, attrW, valueW, data, serverctrlsW,
+                               clientctrlsW );
+
+exit:
+    strfreeW( dnW );
+    strfreeW( attrW );
+    strfreeW( valueW );
+    controlarrayfreeW( serverctrlsW );
+    controlarrayfreeW( clientctrlsW );
+
+    return ret;
+}
+
+static inline ULONG my_win_ldap_compare_extA( LDAP *ld, PCHAR dn, PCHAR attr, PCHAR value,
+    struct berval *data, PLDAPControlA *serverctrls, PLDAPControlA *clientctrls,
+    ULONG *message )
+{
+    ULONG ret = LDAP_NOT_SUPPORTED;
+    WCHAR *dnW = NULL, *attrW = NULL, *valueW = NULL;
+    LDAPControlW **serverctrlsW = NULL, **clientctrlsW = NULL;
+
+    ret = LDAP_NO_MEMORY;
+
+    if (!ld || !message) return LDAP_PARAM_ERROR;
+
+    if (dn) {
+        dnW = strAtoW( dn );
+        if (!dnW) goto exit;
+    }
+    if (attr) {
+        attrW = strAtoW( attr );
+        if (!attrW) goto exit;
+    }
+    if (value) {
+        valueW = strAtoW( value );
+        if (!valueW) goto exit;
+    }
+    if (serverctrls) {
+        serverctrlsW = controlarrayAtoW( serverctrls );
+        if (!serverctrlsW) goto exit;
+    }
+    if (clientctrls) {
+        clientctrlsW = controlarrayAtoW( clientctrls );
+        if (!clientctrlsW) goto exit;
+    }
+
+    ret = ldap_compare_extW( ld, dnW, attrW, valueW, data,
+                             serverctrlsW, clientctrlsW, message );
+
+exit:
+    strfreeW( dnW );
+    strfreeW( attrW );
+    strfreeW( valueW );
+    controlarrayfreeW( serverctrlsW );
+    controlarrayfreeW( clientctrlsW );
+
+    return ret;
+}
+
+static inline ULONG my_win_ldap_modify_ext_sA( LDAP *ld, PCHAR dn, LDAPModA *mods[],
+    PLDAPControlA *serverctrls, PLDAPControlA *clientctrls )
+{
+    ULONG ret = LDAP_NOT_SUPPORTED;
+    WCHAR *dnW = NULL;
+    LDAPModW **modsW = NULL;
+    LDAPControlW **serverctrlsW = NULL, **clientctrlsW = NULL;
+
+    ret = LDAP_NO_MEMORY;
+
+    if (!ld) return LDAP_PARAM_ERROR;
+
+    if (dn) {
+        dnW = strAtoW( dn );
+        if (!dnW) goto exit;
+    }
+    if (mods) {
+        modsW = modarrayAtoW( mods );
+        if (!modsW) goto exit;
+    }
+    if (serverctrls) {
+        serverctrlsW = controlarrayAtoW( serverctrls );
+        if (!serverctrlsW) goto exit;
+    }
+    if (clientctrls) {
+        clientctrlsW = controlarrayAtoW( clientctrls );
+        if (!clientctrlsW) goto exit;
+    }
+
+    ret = ldap_modify_ext_sW( ld, dnW, modsW, serverctrlsW, clientctrlsW );
+
+exit:
+    strfreeW( dnW );
+    modarrayfreeW( modsW );
+    controlarrayfreeW( serverctrlsW );
+    controlarrayfreeW( clientctrlsW );
+
+    return ret;
+}
+
+static inline ULONG my_win_ldap_add_ext_sA( LDAP *ld, PCHAR dn, LDAPModA *attrs[],
+    PLDAPControlA *serverctrls, PLDAPControlA *clientctrls )
+{
+    ULONG ret = LDAP_NOT_SUPPORTED;
+    WCHAR *dnW = NULL;
+    LDAPModW **attrsW = NULL;
+    LDAPControlW **serverctrlsW = NULL, **clientctrlsW = NULL;
+
+    ret = LDAP_NO_MEMORY;
+
+    if (!ld) return LDAP_PARAM_ERROR;
+
+    if (dn) {
+        dnW = strAtoW( dn );
+        if (!dnW) goto exit;
+    }
+    if (attrs) {
+        attrsW = modarrayAtoW( attrs );
+        if (!attrsW) goto exit;
+    }
+    if (serverctrls) {
+        serverctrlsW = controlarrayAtoW( serverctrls );
+        if (!serverctrlsW) goto exit;
+    }
+    if (clientctrls) {
+        clientctrlsW = controlarrayAtoW( clientctrls );
+        if (!clientctrlsW) goto exit;
+    }
+
+    ret = ldap_add_ext_sW( ld, dnW, attrsW, serverctrlsW, clientctrlsW );
+
+exit:
+    strfreeW( dnW );
+    modarrayfreeW( attrsW );
+    controlarrayfreeW( serverctrlsW );
+    controlarrayfreeW( clientctrlsW );
+
+    return ret;
+}
+
+static inline ULONG my_win_ldap_add_extA( LDAP *ld, PCHAR dn, LDAPModA *attrs[],
+    PLDAPControlA *serverctrls, PLDAPControlA *clientctrls, ULONG *message )
+{
+    ULONG ret = LDAP_NOT_SUPPORTED;
+    WCHAR *dnW = NULL;
+    LDAPModW **attrsW = NULL;
+    LDAPControlW **serverctrlsW = NULL, **clientctrlsW = NULL;
+
+    ret = LDAP_NO_MEMORY;
+
+    if (!ld) return LDAP_PARAM_ERROR;
+
+    if (dn) {
+        dnW = strAtoW( dn );
+        if (!dnW) goto exit;
+    }
+    if (attrs) {
+        attrsW = modarrayAtoW( attrs );
+        if (!attrsW) goto exit;
+    }
+    if (serverctrls) {
+        serverctrlsW = controlarrayAtoW( serverctrls );
+        if (!serverctrlsW) goto exit;
+    }
+    if (clientctrls) {
+        clientctrlsW = controlarrayAtoW( clientctrls );
+        if (!clientctrlsW) goto exit;
+    }
+
+    ret = ldap_add_extW( ld, dnW, attrsW, serverctrlsW, clientctrlsW, message );
+
+exit:
+    strfreeW( dnW );
+    modarrayfreeW( attrsW );
+    controlarrayfreeW( serverctrlsW );
+    controlarrayfreeW( clientctrlsW );
+
+    return ret;
+}
+
+static void my_win_ldap_mods_freeA(LDAPMod  **mods, int freemods)
+{
+    modarrayfreeU( mods );
+    if ( freemods ) {
+      free( mods );
+    }
+}
+
+static inline ULONG my_win_ldap_parse_resultA( LDAP *ld, LDAPMessage *result,
+    ULONG *retcode, PCHAR *matched, PCHAR *error, PCHAR **referrals,
+    PLDAPControlA **serverctrls, BOOLEAN free )
+{
+    ULONG ret = LDAP_NOT_SUPPORTED;
+    WCHAR *matchedW = NULL, *errorW = NULL, **referralsW = NULL;
+    LDAPControlW **serverctrlsW = NULL;
+
+    if (!ld) return LDAP_PARAM_ERROR;
+
+    ret = ldap_parse_resultW( ld, result, retcode, &matchedW, &errorW,
+                              &referralsW, &serverctrlsW, free );
+
+    if (matched) *matched = strWtoA( matchedW );
+    if (error) *error = strWtoA( errorW );
+
+    if (referrals) *referrals = strarrayWtoA( referralsW );
+    if (serverctrls) *serverctrls = controlarrayWtoA( serverctrlsW );
+
+    ldap_memfreeW( matchedW );
+    ldap_memfreeW( errorW );
+    ldap_value_freeW( referralsW );
+    ldap_controls_freeW( serverctrlsW );
+
+    return ret;
+}
+
+static inline ULONG my_win_ldap_controls_freeA( LDAPControlA **controls )
+{
+    ULONG ret = LDAP_SUCCESS;
+
+    controlarrayfreeA( controls );
+
+    return ret;
+}
+/*
+BerElement *ber_alloc_t( int options )
+{
+   BerElement   *ber;
+
+   ber = (BerElement *) calloc( 1, sizeof(BerElement) );
+
+   if ( ber == NULL ) {
+      return NULL;
+   }
+
+   ber->ber_valid = LBER_VALID_BERELEMENT;
+   ber->ber_tag = LBER_DEFAULT;
+   ber->ber_options = options;
+   ber->ber_debug = ber_int_debug;
+
+   return ber;
+}
+
+static inline BerElement *ber_dup( BerElement *ber )
+{
+   BerElement   *new;
+
+   if ( (new = ber_alloc_t( ber->ber_options )) == NULL ) {
+      return NULL;
+   }
+
+   *new = *ber;
+
+   return( new );
+}
+
+static inline int my_win_ldap_parse_sasl_bind_result(
+   LDAP         *ld,
+   LDAPMessage      *res,
+   struct berval   **servercredp,
+   int            freeit )
+{
+   ber_int_t errcode;
+   struct berval* scred;
+
+   ber_tag_t tag;
+   BerElement   *ber;
+
+   if( servercredp != NULL ) {
+      if( ld->ld_version < LDAP_VERSION2 ) {
+         return LDAP_NOT_SUPPORTED;
+      }
+      *servercredp = NULL;
+   }
+
+   if( res->lm_msgtype != LDAP_RES_BIND ) {
+      ld->ld_errno = LDAP_PARAM_ERROR;
+      return ld->ld_errno;
+   }
+
+   scred = NULL;
+
+   if ( ld->ld_error ) {
+      ldap_memfreeA( ld->ld_error );
+      ld->ld_error = NULL;
+   }
+   if ( ld->ld_matched ) {
+      ldap_memfreeA( ld->ld_matched );
+      ld->ld_matched = NULL;
+   }
+
+   ber = ber_dup( res->lm_ber );
+
+   if( ber == NULL ) {
+      ld->ld_errno = LDAP_NO_MEMORY;
+      return ld->ld_errno;
+   }
+
+   if ( ld->ld_version < LDAP_VERSION2 ) {
+      tag = ber_scanf( ber, "{iA}",
+         &errcode, &ld->ld_error );
+
+      if( tag == LBER_ERROR ) {
+         ber_free( ber, 0 );
+         ld->ld_errno = LDAP_DECODING_ERROR;
+         return ld->ld_errno;
+      }
+
+   } else {
+      ber_len_t len;
+
+      tag = ber_scanf( ber, "{eAA" 
+         &errcode, &ld->ld_matched, &ld->ld_error );
+
+      if( tag == LBER_ERROR ) {
+         ber_free( ber, 0 );
+         ld->ld_errno = LDAP_DECODING_ERROR;
+         return ld->ld_errno;
+      }
+
+      tag = ber_peek_tag(ber, &len);
+
+      if( tag == LDAP_TAG_REFERRAL ) {
+         if( ber_scanf( ber, "x" ) == LBER_ERROR ) {
+            ber_free( ber, 0 );
+            ld->ld_errno = LDAP_DECODING_ERROR;
+            return ld->ld_errno;
+         }
+
+         tag = ber_peek_tag(ber, &len);
+      }
+
+      if( tag == LDAP_TAG_SASL_RES_CREDS ) {
+         if( ber_scanf( ber, "O", &scred ) == LBER_ERROR ) {
+            ber_free( ber, 0 );
+            ld->ld_errno = LDAP_DECODING_ERROR;
+            return ld->ld_errno;
+         }
+      }
+   }
+
+   ber_free( ber, 0 );
+
+   if ( servercredp != NULL ) {
+      *servercredp = scred;
+
+   } else if ( scred != NULL ) {
+      ber_bvfree( scred );
+   }
+
+   ld->ld_errno = errcode;
+
+   if ( freeit ) {
+      ldap_msgfree( res );
+   }
+
+   return( LDAP_SUCCESS );
+}
+
+static inline int
+my_win_ldap_sasl_bind(
+   LDAP         *ld,
+   const char   *dn,
+   const char   *mechanism,
+   struct berval   *cred,
+   LDAPControl      **sctrls,
+   LDAPControl      **cctrls,
+   int            *msgidp )
+{
+   BerElement   *ber;
+   int rc;
+   ber_int_t id;
+
+   rc = ldap_int_client_controls( ld, cctrls );
+   if( rc != LDAP_SUCCESS ) return rc;
+
+   if( mechanism == LDAP_SASL_SIMPLE ) {
+      if( dn == NULL && cred != NULL && cred->bv_len ) {
+         dn = ld->ld_defbinddn;
+      }
+
+   } else if( ld->ld_version < LDAP_VERSION3 ) {
+      ld->ld_errno = LDAP_NOT_SUPPORTED;
+      return ld->ld_errno;
+   }
+
+   if ( dn == NULL ) {
+      dn = "";
+   }
+
+   if ( (ber = ldap_alloc_ber_with_options( ld )) == NULL ) {
+      ld->ld_errno = LDAP_NO_MEMORY;
+      return ld->ld_errno;
+   }
+
+   LDAP_NEXT_MSGID( ld, id );
+   if( mechanism == LDAP_SASL_SIMPLE ) {
+      rc = ber_printf( ber, "{it{istON}" ,
+         id, LDAP_REQ_BIND,
+         ld->ld_version, dn, LDAP_AUTH_SIMPLE,
+         cred );
+
+   } else if ( cred == NULL || cred->bv_val == NULL ) {
+      rc = ber_printf( ber, "{it{ist{sN}N}" ,
+         id, LDAP_REQ_BIND,
+         ld->ld_version, dn, LDAP_AUTH_SASL,
+         mechanism );
+
+   } else {
+      rc = ber_printf( ber, "{it{ist{sON}N}" ,
+         id, LDAP_REQ_BIND,
+         ld->ld_version, dn, LDAP_AUTH_SASL,
+         mechanism, cred );
+   }
+
+   if( rc == -1 ) {
+      ld->ld_errno = LDAP_ENCODING_ERROR;
+      ber_free( ber, 1 );
+      return( -1 );
+   }
+
+   if( ldap_int_put_controls( ld, sctrls, ber ) != LDAP_SUCCESS ) {
+      ber_free( ber, 1 );
+      return ld->ld_errno;
+   }
+
+   if ( ber_printf( ber, "N}" ) == -1 ) {
+      ld->ld_errno = LDAP_ENCODING_ERROR;
+      ber_free( ber, 1 );
+      return ld->ld_errno;
+   }
+
+
+   *msgidp = ldap_send_initial_request( ld, LDAP_REQ_BIND, dn, ber, id );
+
+   if(*msgidp < 0)
+      return ld->ld_errno;
+
+   return LDAP_SUCCESS;
+}
+
+
+static inline int
+my_win_ldap_sasl_bind_s(
+   LDAP         *ld,
+   LDAP_CONST char   *dn,
+   LDAP_CONST char   *mechanism,
+   struct berval   *cred,
+   LDAPControl      **sctrls,
+   LDAPControl      **cctrls,
+   struct berval   **servercredp )
+{
+   int   rc, msgid;
+   LDAPMessage   *result;
+   struct berval   *scredp = NULL;
+
+   Debug( LDAP_DEBUG_TRACE, "ldap_sasl_bind_s\n", 0, 0, 0 );
+
+   if( servercredp != NULL ) {
+      if (ld->ld_version < LDAP_VERSION3) {
+         ld->ld_errno = LDAP_NOT_SUPPORTED;
+         return ld->ld_errno;
+      }
+      *servercredp = NULL;
+   }
+
+   rc = ldap_sasl_bind( ld, dn, mechanism, cred, sctrls, cctrls, &msgid );
+
+   if ( rc != LDAP_SUCCESS ) {
+      return( rc );
+   }
+
+#ifdef LDAP_CONNECTIONLESS
+   if (LDAP_IS_UDP(ld)) {
+      return( rc );
+   }
+#endif
+
+   if ( ldap_result( ld, msgid, LDAP_MSG_ALL, NULL, &result ) == -1 || !result ) {
+      return( ld->ld_errno );
+   }
+
+   scredp = NULL;
+   if( servercredp != NULL ) {
+      rc = ldap_parse_sasl_bind_result( ld, result, &scredp, 0 );
+   }
+
+   if ( rc != LDAP_SUCCESS ) {
+      ldap_msgfree( result );
+      return( rc );
+   }
+
+   rc = ldap_result2error( ld, result, 1 );
+
+   if ( rc == LDAP_SUCCESS || rc == LDAP_SASL_BIND_IN_PROGRESS ) {
+      if( servercredp != NULL ) {
+         *servercredp = scredp;
+         scredp = NULL;
+      }
+   }
+
+   if ( scredp != NULL ) {
+      ber_bvfree(scredp);
+   }
+
+   return rc;
+}
+*/
+
+static inline ULONG my_win_ldap_sasl_bind_sA( LDAP *ld, const PCHAR dn,
+    const PCHAR mechanism, const BERVAL *cred, PLDAPControlA *serverctrls,
+    PLDAPControlA *clientctrls, PBERVAL *serverdata )
+{
+    ULONG ret = LDAP_NOT_SUPPORTED;
+    WCHAR *dnW, *mechanismW = NULL;
+    LDAPControlW **serverctrlsW = NULL, **clientctrlsW = NULL;
+
+    ret = LDAP_NO_MEMORY;
+
+    if (!ld || !dn || !mechanism || !cred || !serverdata)
+        return LDAP_PARAM_ERROR;
+
+    dnW = strAtoW( dn );
+    if (!dnW) goto exit;
+
+    mechanismW = strAtoW( mechanism );
+    if (!mechanismW) goto exit;
+
+    if (serverctrls) {
+        serverctrlsW = controlarrayAtoW( serverctrls );
+        if (!serverctrlsW) goto exit;
+    }
+    if (clientctrls) {
+        clientctrlsW = controlarrayAtoW( clientctrls );
+        if (!clientctrlsW) goto exit;
+    }
+
+    ret = ldap_sasl_bind_sW( ld, dnW, mechanismW, cred, serverctrlsW, clientctrlsW, serverdata );
+
+exit:
+    strfreeW( dnW );
+    strfreeW( mechanismW );
+    controlarrayfreeW( serverctrlsW );
+    controlarrayfreeW( clientctrlsW );
+
+    return ret;
+}
+
+static inline ULONG my_win_ldap_sasl_bindA( LDAP *ld, const PCHAR dn,
+    const PCHAR mechanism, const BERVAL *cred, PLDAPControlA *serverctrls,
+    PLDAPControlA *clientctrls, int *message )
+{
+    ULONG ret = LDAP_NOT_SUPPORTED;
+
+    WCHAR *dnW, *mechanismW = NULL;
+    LDAPControlW **serverctrlsW = NULL, **clientctrlsW = NULL;
+
+    ret = LDAP_NO_MEMORY;
+
+    if (!ld || !dn || !mechanism || !cred || !message)
+        return LDAP_PARAM_ERROR;
+
+    dnW = strAtoW( dn );
+    if (!dnW) goto exit;
+
+    mechanismW = strAtoW( mechanism );
+    if (!mechanismW) goto exit;
+
+    if (serverctrls) {
+        serverctrlsW = controlarrayAtoW( serverctrls );
+        if (!serverctrlsW) goto exit;
+    }
+    if (clientctrls) {
+        clientctrlsW = controlarrayAtoW( clientctrls );
+        if (!clientctrlsW) goto exit;
+    }
+
+    ret = ldap_sasl_bindW( ld, dnW, mechanismW, cred, serverctrlsW, clientctrlsW, message );
+
+exit:
+    strfreeW( dnW );
+    strfreeW( mechanismW );
+    controlarrayfreeW( serverctrlsW );
+    controlarrayfreeW( clientctrlsW );
+
+    return ret;
+}
+
+static inline PCHAR my_win_ldap_get_dnA( LDAP *ld, LDAPMessage *entry )
+{
+    PCHAR ret = NULL;
+    PWCHAR retW;
+
+    if (!ld || !entry) return NULL;
+
+    retW = ldap_get_dnW( ld, entry );
+
+    ret = strWtoA( retW );
+    ldap_memfreeW( retW );
+
+    return ret;
+}
+
+static inline ULONG my_win_ldap_parse_extended_resultA( LDAP *ld,
+    LDAPMessage *result,
+    PCHAR *oid, struct berval **data, BOOLEAN free )
+{
+    ULONG ret = LDAP_NOT_SUPPORTED;
+    WCHAR *oidW = NULL;
+
+    if (!ld) return LDAP_PARAM_ERROR;
+    if (!result) return LDAP_NO_RESULTS_RETURNED;
+
+    ret = ldap_parse_extended_resultW( ld, result, &oidW, data, free );
+
+    if (oid) {
+        *oid = strWtoA( oidW );
+        if (!*oid) ret = LDAP_NO_MEMORY;
+        ldap_memfreeW( oidW );
+    }
+
+    return ret;
+}
+
+static inline LDAP *
+my_win_ldap_initA (const char *host, unsigned short port)
+{
+  LDAP *ld;
+  wchar_t *whost = NULL;
+
+  if (host)
+    {
+      whost = strAtoW (host);
+      if (!whost)
+        return NULL;
+    }
+  ld = ldap_initW (whost, port);
+  free (whost);
+  return ld;
+}
+
+static inline ULONG
+my_win_ldap_simple_bind_sA (LDAP *ld, const char *user, const char *pass)
+{
+  ULONG ret;
+  wchar_t *wuser, *wpass;
+
+  wuser = user? strAtoW (user) : NULL;
+  wpass = pass? strAtoW (pass) : NULL;
+  /* We can't easily map errnos to ldap_errno, thus we pass a NULL to
+     the function in the hope that the server will throw an error.  */
+  ret = ldap_simple_bind_sW (ld, wuser, wpass);
+  strfreeW (wpass);
+  strfreeW (wuser);
+  return ret;
+}
+
+static inline ULONG my_win_ldap_search_extA( LDAP *ld, PCHAR base, ULONG scope,
+    PCHAR filter, PCHAR attrs[], ULONG attrsonly, PLDAPControlA *serverctrls,
+    PLDAPControlA *clientctrls, ULONG timelimit, ULONG sizelimit, int *message )
+{
+    ULONG ret = LDAP_NOT_SUPPORTED;
+    WCHAR *baseW = NULL, *filterW = NULL, **attrsW = NULL;
+    LDAPControlW **serverctrlsW = NULL, **clientctrlsW = NULL;
+
+    ret = LDAP_NO_MEMORY;
+
+    if (!ld) return LDAP_PARAM_ERROR;
+
+    if (base) {
+        baseW = strAtoW( base );
+        if (!baseW) goto exit;
+    }
+    if (filter)
+    {
+        filterW = strAtoW( filter );
+        if (!filterW) goto exit;
+    }
+    if (attrs) {
+        attrsW = strarrayAtoW( attrs );
+        if (!attrsW) goto exit;
+    }
+    if (serverctrls) {
+        serverctrlsW = controlarrayAtoW( serverctrls );
+        if (!serverctrlsW) goto exit;
+    }
+    if (clientctrls) {
+        clientctrlsW = controlarrayAtoW( clientctrls );
+        if (!clientctrlsW) goto exit;
+    }
+
+    ret = ldap_search_extW( ld, baseW, scope, filterW, attrsW, attrsonly,
+                            serverctrlsW, clientctrlsW, timelimit, sizelimit, ( ULONG* )message );
+
+exit:
+    strfreeW( baseW );
+    strfreeW( filterW );
+    strarrayfreeW( attrsW );
+    controlarrayfreeW( serverctrlsW );
+    controlarrayfreeW( clientctrlsW );
+
+    return ret;
+}
+
+static inline ULONG my_win_ldap_search_stA( LDAP *ld, const PCHAR base, ULONG scope,
+    const PCHAR filter, PCHAR attrs[], ULONG attrsonly,
+    struct l_timeval *timeout, LDAPMessage **res )
+{
+    ULONG ret = LDAP_NOT_SUPPORTED;
+    WCHAR *baseW = NULL, *filterW = NULL, **attrsW = NULL;
+
+    ret = LDAP_NO_MEMORY;
+
+    if (!ld || !res) return LDAP_PARAM_ERROR;
+
+    if (base) {
+        baseW = strAtoW( base );
+        if (!baseW) goto exit;
+    }
+    if (filter) {
+        filterW = strAtoW( filter );
+        if (!filterW) goto exit;
+    }
+    if (attrs) {
+        attrsW = strarrayAtoW( attrs );
+        if (!attrsW) goto exit;
+    }
+
+    ret = ldap_search_stW( ld, baseW, scope, filterW, attrsW, attrsonly,
+                           timeout, res );
+
+exit:
+    strfreeW( baseW );
+    strfreeW( filterW );
+    strarrayfreeW( attrsW );
+
+    return ret;
+}
+
+static inline char *
+my_win_ldap_first_attributeA (LDAP *ld, LDAPMessage *msg, BerElement **elem)
+{
+  wchar_t *wattr;
+  char *attr;
+
+  wattr = ldap_first_attributeW (ld, msg, elem);
+  if (!wattr)
+    return NULL;
+  attr = strWtoA (wattr);
+  ldap_memfreeW (wattr);
+  return attr;
+}
+
+
+static inline char *
+my_win_ldap_next_attributeA (LDAP *ld, LDAPMessage *msg, BerElement *elem)
+{
+  wchar_t *wattr;
+  char *attr;
+
+  wattr = ldap_next_attributeW (ld, msg, elem);
+  if (!wattr)
+    return NULL;
+  attr = strWtoA (wattr);
+  ldap_memfreeW (wattr);
+  return attr;
+}
+
+static inline BerValue **
+my_win_ldap_get_values_lenA (LDAP *ld, LDAPMessage *msg, const char *attr)
+{
+  BerValue **ret;
+  wchar_t *wattr;
+
+  if (attr)
+    {
+      wattr = strAtoW (attr);
+      if (!wattr)
+        return NULL;
+    }
+  else
+    wattr = NULL;
+
+  ret = ldap_get_values_lenW (ld, msg, wattr);
+  free (wattr);
+
+  return ret;
+}
+#endif /*_WIN32_WCE*/
+#endif /*W32_LDAP_HELP_H*/
Index: kldap/CMakeLists.txt
===================================================================
--- kldap/CMakeLists.txt	(revision 1200316)
+++ kldap/CMakeLists.txt	(working copy)
@@ -3,13 +3,15 @@
 include(CheckSymbolExists)
 
 add_definitions( -DKDE_DEFAULT_DEBUG_AREA=5322 )
-
 macro_optional_find_package(Ldap)
-macro_log_feature(LDAP_FOUND "OpenLDAP" "LDAP support" "http://www.openldap.org" FALSE "" "STRONGLY RECOMMENDED: Without this, the KLDAP library will be useless" )
-
+if (NOT WIN32)
+    macro_log_feature(LDAP_FOUND "OpenLDAP" "LDAP (Lightweight Directory Access Protocol) libraries" "http://www.openldap.org" FALSE "" "STRONGLY RECOMMENDED: Needed to provide LDAP functionality in KDE" )
+else (NOT WIN32)
+    macro_log_feature(LDAP_FOUND "OpenLDAP" "LDAP (Lightweight Directory Access Protocol) libraries" "http://www.openldap.org" FALSE "" "Used for additional LDAP Features on Windows Systems\nSystem LDAP used as fallback for KDE" )
+endif(NOT WIN32)
 #look for Sasl2 in the top-level CMakeLists.txt file now
 #macro_optional_find_package(Sasl2)
-#macro_log_feature(SASL2_FOUND "cyrus-sasl" "Support for authentication over LDAP" "http://asg.web.cmu.edu/sasl/sasl-library.html" FALSE "" "" )
+#macro_log_feature(SASL2_FOUND "cyrus-sasl" "Cyrus SASL API" "http://asg.web.cmu.edu/sasl/sasl-library.html" FALSE "" "Needed to support authentication of logins" )
 
 check_include_files(sys/time.h    HAVE_SYS_TIME_H)
 
@@ -19,7 +21,7 @@
 if (LDAP_FOUND)
    set(kldap_EXTRA_LIBS ${LDAP_LIBRARIES})
    set(kldap_EXTRA_INCLUDES ${LDAP_INCLUDE_DIR})
-
+   set(HAVE_LDAP_H)
    set(CMAKE_REQUIRED_INCLUDES lber.h ldap.h)
    set(CMAKE_REQUIRED_LIBRARIES ${LDAP_LIBRARIES})
    check_function_exists(ldap_start_tls_s HAVE_LDAP_START_TLS_S)
@@ -30,8 +32,24 @@
    check_function_exists(ldap_extended_operation_s HAVE_LDAP_EXTENDED_OPERATION_S)
    check_symbol_exists(ldap_extended_operation ldap.h HAVE_LDAP_EXTENDED_OPERATION_PROTOTYPE)
    check_symbol_exists(ldap_extended_operation_s ldap.h HAVE_LDAP_EXTENDED_OPERATION_S_PROTOTYPE)
-
-
+else (LDAP_FOUND)
+   if (WIN32)
+      MESSAGE(STATUS "No LDAP implementation found, using System LDAP")
+      set(LDAP_FOUND TRUE)
+      set(HAVE_WINLDAP_H TRUE)
+      set(CMAKE_REQUIRED_INCLUDES winldap.h w32-ldap-help.h)
+      set(CMAKE_REQUIRED_LIBRARIES wldap32)
+      set(kldap_EXTRA_LIBS ${kldap_EXTRA_LIBS} wldap32)
+      # Checks left in for compatibilty
+      check_function_exists(ldap_start_tls_s HAVE_LDAP_START_TLS_S)
+      check_function_exists(ldap_initialize HAVE_LDAP_INITIALIZE)
+      check_function_exists(ber_memfree HAVE_BER_MEMFREE)
+      check_function_exists(ldap_unbind_ext HAVE_LDAP_UNBIND_EXT)
+      check_function_exists(ldap_extended_operation HAVE_LDAP_EXTENDED_OPERATION)
+      check_function_exists(ldap_extended_operation_s HAVE_LDAP_EXTENDED_OPERATION_S)
+      check_symbol_exists(ldap_extended_operation winldap.h HAVE_LDAP_EXTENDED_OPERATION_PROTOTYPE)
+      check_symbol_exists(ldap_extended_operation_s winldap.h HAVE_LDAP_EXTENDED_OPERATION_S_PROTOTYPE)
+   endif (WIN32)
 endif (LDAP_FOUND)
 
 if (SASL2_FOUND)
Index: kldap/wce-ldap-help.h
===================================================================
--- kldap/wce-ldap-help.h	(revision 0)
+++ kldap/wce-ldap-help.h	(revision 0)
@@ -0,0 +1,862 @@
+/*
+ * winceldap - LDAP helper functions for Windows CE
+ * Copyright 2010 Andre Heinecke
+ *
+ * Derived from:
+ *
+ * WLDAP32 - LDAP support for Wine
+ *
+ * Copyright 2005 Hans Leidekker
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+#ifndef WINCELDAP_H
+#define WINCELDAP_H
+ULONG map_error( int );
+
+/* A set of helper functions to convert LDAP data structures
+ * to and from ansi (A), wide character (W) and utf8 (U) encodings.
+ */
+
+static inline char *strdupU( const char *src )
+{
+    char *dst;
+
+    if (!src) return NULL;
+    dst = ( char * )HeapAlloc( GetProcessHeap(), 0, (strlen( src ) + 1) * sizeof(char) );
+    if (dst)
+        strcpy( dst, src );
+    return dst;
+}
+
+static inline LPWSTR strAtoW( LPCSTR str )
+{
+    LPWSTR ret = NULL;
+    if (str)
+    {
+        DWORD len = MultiByteToWideChar( CP_ACP, 0, str, -1, NULL, 0 );
+        if ((ret = ( WCHAR* )HeapAlloc( GetProcessHeap(), 0, len * sizeof(WCHAR) )))
+            MultiByteToWideChar( CP_ACP, 0, str, -1, ret, len );
+    }
+    return ret;
+}
+
+static inline LPSTR strWtoA( LPCWSTR str )
+{
+    LPSTR ret = NULL;
+    if (str)
+    {
+        DWORD len = WideCharToMultiByte( CP_ACP, 0, str, -1, NULL, 0, NULL, NULL );
+        if ((ret = ( char* )HeapAlloc( GetProcessHeap(), 0, len )))
+            WideCharToMultiByte( CP_ACP, 0, str, -1, ret, len, NULL, NULL );
+    }
+    return ret;
+}
+
+static inline char *strWtoU( LPCWSTR str )
+{
+    LPSTR ret = NULL;
+    if (str)
+    {
+        DWORD len = WideCharToMultiByte( CP_UTF8, 0, str, -1, NULL, 0, NULL, NULL );
+        if ((ret = ( char * )HeapAlloc( GetProcessHeap(), 0, len )))
+            WideCharToMultiByte( CP_UTF8, 0, str, -1, ret, len, NULL, NULL );
+    }
+    return ret;
+}
+
+static inline LPWSTR strUtoW( char *str )
+{
+    LPWSTR ret = NULL;
+    if (str)
+    {
+        DWORD len = MultiByteToWideChar( CP_UTF8, 0, str, -1, NULL, 0 );
+        if ((ret = ( WCHAR* )HeapAlloc( GetProcessHeap(), 0, len * sizeof(WCHAR) )))
+            MultiByteToWideChar( CP_UTF8, 0, str, -1, ret, len );
+    }
+    return ret;
+}
+
+static inline void strfreeA( LPSTR str )
+{
+    HeapFree( GetProcessHeap(), 0, str );
+}
+
+static inline void strfreeW( LPWSTR str )
+{
+    HeapFree( GetProcessHeap(), 0, str );
+}
+
+static inline void strfreeU( char *str )
+{
+    HeapFree( GetProcessHeap(), 0, str );
+}
+
+static inline DWORD strarraylenA( LPSTR *strarray )
+{
+    LPSTR *p = strarray;
+    while (*p) p++;
+    return p - strarray;
+}
+
+static inline DWORD strarraylenW( LPWSTR *strarray )
+{
+    LPWSTR *p = strarray;
+    while (*p) p++;
+    return p - strarray;
+}
+
+static inline DWORD strarraylenU( char **strarray )
+{
+    char **p = strarray;
+    while (*p) p++;
+    return p - strarray;
+}
+
+static inline LPWSTR *strarrayAtoW( LPSTR *strarray )
+{
+    LPWSTR *strarrayW = NULL;
+    DWORD size;
+
+    if (strarray)
+    {
+        size  = sizeof(WCHAR*) * (strarraylenA( strarray ) + 1);
+        strarrayW = ( WCHAR** )HeapAlloc( GetProcessHeap(), 0, size );
+
+        if (strarrayW)
+        {
+            LPSTR *p = strarray;
+            LPWSTR *q = strarrayW;
+
+            while (*p) *q++ = strAtoW( *p++ );
+            *q = NULL;
+        }
+    }
+    return strarrayW;
+}
+
+static inline LPSTR *strarrayWtoA( LPWSTR *strarray )
+{
+    LPSTR *strarrayA = NULL;
+    DWORD size;
+
+    if (strarray)
+    {
+        size = sizeof(LPSTR) * (strarraylenW( strarray ) + 1);
+        strarrayA = ( char** )HeapAlloc( GetProcessHeap(), 0, size );
+
+        if (strarrayA)
+        {
+            LPWSTR *p = strarray;
+            LPSTR *q = strarrayA;
+
+            while (*p) *q++ = strWtoA( *p++ );
+            *q = NULL;
+        }
+    }
+    return strarrayA;
+}
+
+static inline char **strarrayWtoU( LPWSTR *strarray )
+{
+    char **strarrayU = NULL;
+    DWORD size;
+
+    if (strarray)
+    {
+        size = sizeof(char*) * (strarraylenW( strarray ) + 1);
+        strarrayU = ( char** )HeapAlloc( GetProcessHeap(), 0, size );
+
+        if (strarrayU)
+        {
+            LPWSTR *p = strarray;
+            char **q = strarrayU;
+
+            while (*p) *q++ = strWtoU( *p++ );
+            *q = NULL;
+        }
+    }
+    return strarrayU;
+}
+
+static inline LPWSTR *strarrayUtoW( char **strarray )
+{
+    LPWSTR *strarrayW = NULL;
+    DWORD size;
+
+    if (strarray)
+    {
+        size = sizeof(WCHAR*) * (strarraylenU( strarray ) + 1);
+        strarrayW = ( WCHAR ** )HeapAlloc( GetProcessHeap(), 0, size );
+
+        if (strarrayW)
+        {
+            char **p = strarray;
+            LPWSTR *q = strarrayW;
+
+            while (*p) *q++ = strUtoW( *p++ );
+            *q = NULL;
+        }
+    }
+    return strarrayW;
+}
+
+static inline void strarrayfreeA( LPSTR *strarray )
+{
+    if (strarray)
+    {
+        LPSTR *p = strarray;
+        while (*p) strfreeA( *p++ );
+        HeapFree( GetProcessHeap(), 0, strarray );
+    }
+}
+
+static inline void strarrayfreeW( LPWSTR *strarray )
+{
+    if (strarray)
+    {
+        LPWSTR *p = strarray;
+        while (*p) strfreeW( *p++ );
+        HeapFree( GetProcessHeap(), 0, strarray );
+    }
+}
+
+static inline void strarrayfreeU( char **strarray )
+{
+    if (strarray)
+    {
+        char **p = strarray;
+        while (*p) strfreeU( *p++ );
+        HeapFree( GetProcessHeap(), 0, strarray );
+    }
+}
+
+static inline struct berval *bvdup( struct berval *bv )
+{
+    struct berval *berval;
+    DWORD size = sizeof(struct berval) + bv->bv_len;
+
+    berval = ( struct berval * )HeapAlloc( GetProcessHeap(), 0, size );
+    if (berval)
+    {
+        char *val = (char *)berval + sizeof(struct berval);
+
+        berval->bv_len = bv->bv_len;
+        berval->bv_val = val;
+        memcpy( val, bv->bv_val, bv->bv_len );
+    }
+    return berval;
+}
+
+static inline DWORD bvarraylen( struct berval **bv )
+{
+    struct berval **p = bv;
+    while (*p) p++;
+    return p - bv;
+}
+
+static inline struct berval **bvarraydup( struct berval **bv )
+{
+    struct berval **berval = NULL;
+    DWORD size;
+
+    if (bv)
+    {
+        size = sizeof(struct berval *) * (bvarraylen( bv ) + 1);
+        berval = ( struct berval ** )HeapAlloc( GetProcessHeap(), 0, size );
+
+        if (berval)
+        {
+            struct berval **p = bv;
+            struct berval **q = berval;
+
+            while (*p) *q++ = bvdup( *p++ );
+            *q = NULL;
+        }
+    }
+    return berval;
+}
+
+static inline void bvarrayfree( struct berval **bv )
+{
+    struct berval **p = bv;
+    while (*p) HeapFree( GetProcessHeap(), 0, *p++ );
+    HeapFree( GetProcessHeap(), 0, bv );
+}
+
+static inline LDAPModW *modAtoW( LDAPModA *mod )
+{
+    LDAPModW *modW;
+
+    modW = ( LDAPModW *)HeapAlloc( GetProcessHeap(), 0, sizeof(LDAPModW) );
+    if (modW)
+    {
+        modW->mod_op = mod->mod_op;
+        modW->mod_type = strAtoW( mod->mod_type );
+
+        if (mod->mod_op & LDAP_MOD_BVALUES)
+            modW->mod_vals.modv_bvals = bvarraydup( mod->mod_vals.modv_bvals );
+        else
+            modW->mod_vals.modv_strvals = strarrayAtoW( mod->mod_vals.modv_strvals );
+    }
+    return modW;
+}
+
+static inline LDAPMod *modWtoU( LDAPModW *mod )
+{
+    LDAPMod *modU;
+
+    modU = ( LDAPMod * )HeapAlloc( GetProcessHeap(), 0, sizeof(LDAPMod) );
+    if (modU)
+    {
+        modU->mod_op = mod->mod_op;
+        modU->mod_type = strWtoU( mod->mod_type );
+
+        if (mod->mod_op & LDAP_MOD_BVALUES)
+            modU->mod_vals.modv_bvals = bvarraydup( mod->mod_vals.modv_bvals );
+        else
+            modU->mod_vals.modv_strvals = strarrayWtoU( mod->mod_vals.modv_strvals );
+    }
+    return modU;
+}
+
+static inline void modfreeW( LDAPModW *mod )
+{
+    if (mod->mod_op & LDAP_MOD_BVALUES)
+        bvarrayfree( mod->mod_vals.modv_bvals );
+    else
+        strarrayfreeW( mod->mod_vals.modv_strvals );
+    HeapFree( GetProcessHeap(), 0, mod );
+}
+
+static inline void modfreeU( LDAPMod *mod )
+{
+    if (mod->mod_op & LDAP_MOD_BVALUES)
+        bvarrayfree( mod->mod_vals.modv_bvals );
+    else
+        strarrayfreeU( mod->mod_vals.modv_strvals );
+    HeapFree( GetProcessHeap(), 0, mod );
+}
+
+static inline DWORD modarraylenA( LDAPModA **modarray )
+{
+    LDAPModA **p = modarray;
+    while (*p) p++;
+    return p - modarray;
+}
+
+static inline DWORD modarraylenW( LDAPModW **modarray )
+{
+    LDAPModW **p = modarray;
+    while (*p) p++;
+    return p - modarray;
+}
+
+static inline LDAPModW **modarrayAtoW( LDAPModA **modarray )
+{
+    LDAPModW **modarrayW = NULL;
+    DWORD size;
+
+    if (modarray)
+    {
+        size = sizeof(LDAPModW*) * (modarraylenA( modarray ) + 1);
+        modarrayW = ( LDAPModW**)HeapAlloc( GetProcessHeap(), 0, size );
+
+        if (modarrayW)
+        {
+            LDAPModA **p = modarray;
+            LDAPModW **q = modarrayW;
+
+            while (*p) *q++ = modAtoW( *p++ );
+            *q = NULL;
+        }
+    }
+    return modarrayW;
+}
+
+static inline LDAPMod **modarrayWtoU( LDAPModW **modarray )
+{
+    LDAPMod **modarrayU = NULL;
+    DWORD size;
+
+    if (modarray)
+    {
+        size = sizeof(LDAPMod*) * (modarraylenW( modarray ) + 1);
+        modarrayU = ( LDAPMod** )HeapAlloc( GetProcessHeap(), 0, size );
+
+        if (modarrayU)
+        {
+            LDAPModW **p = modarray;
+            LDAPMod **q = modarrayU;
+
+            while (*p) *q++ = modWtoU( *p++ );
+            *q = NULL;
+        }
+    }
+    return modarrayU;
+}
+
+static inline void modarrayfreeW( LDAPModW **modarray )
+{
+    if (modarray)
+    {
+        LDAPModW **p = modarray;
+        while (*p) modfreeW( *p++ );
+        HeapFree( GetProcessHeap(), 0, modarray );
+    }
+}
+
+static inline void modarrayfreeU( LDAPMod **modarray )
+{
+    if (modarray)
+    {
+        LDAPMod **p = modarray;
+        while (*p) modfreeU( *p++ );
+        HeapFree( GetProcessHeap(), 0, modarray );
+    }
+}
+
+static inline LDAPControlW *controlAtoW( LDAPControlA *control )
+{
+    LDAPControlW *controlW;
+    DWORD len = control->ldctl_value.bv_len;
+    char *val = NULL;
+
+    if (control->ldctl_value.bv_val)
+    {
+        val = ( char* )HeapAlloc( GetProcessHeap(), 0, len );
+        if (!val) return NULL;
+        memcpy( val, control->ldctl_value.bv_val, len );
+    }
+
+    controlW = ( LDAPControlW* )HeapAlloc( GetProcessHeap(), 0, sizeof(LDAPControlW) );
+    if (!controlW)
+    {
+        HeapFree( GetProcessHeap(), 0, val );
+        return NULL;
+    }
+
+    controlW->ldctl_oid = strAtoW( control->ldctl_oid );
+    controlW->ldctl_value.bv_len = len; 
+    controlW->ldctl_value.bv_val = val; 
+    controlW->ldctl_iscritical = control->ldctl_iscritical;
+
+    return controlW;
+}
+
+static inline LDAPControlA *controlWtoA( LDAPControlW *control )
+{
+    LDAPControlA *controlA;
+    DWORD len = control->ldctl_value.bv_len;
+    char *val = NULL;
+
+    if (control->ldctl_value.bv_val)
+    {
+        val = ( char* )HeapAlloc( GetProcessHeap(), 0, len );
+        if (!val) return NULL;
+        memcpy( val, control->ldctl_value.bv_val, len );
+    }
+
+    controlA = ( LDAPControlA* )HeapAlloc( GetProcessHeap(), 0, sizeof(LDAPControlA) );
+    if (!controlA)
+    {
+        HeapFree( GetProcessHeap(), 0, val );
+        return NULL;
+    }
+
+    controlA->ldctl_oid = strWtoA( control->ldctl_oid );
+    controlA->ldctl_value.bv_len = len; 
+    controlA->ldctl_value.bv_val = val;
+    controlA->ldctl_iscritical = control->ldctl_iscritical;
+
+    return controlA;
+}
+
+static inline LDAPControl *controlWtoU( LDAPControlW *control )
+{
+    LDAPControl *controlU;
+    DWORD len = control->ldctl_value.bv_len;
+    char *val = NULL;
+
+    if (control->ldctl_value.bv_val)
+    {
+        val = ( char * )HeapAlloc( GetProcessHeap(), 0, len );
+        if (!val) return NULL;
+        memcpy( val, control->ldctl_value.bv_val, len );
+    }
+
+    controlU = ( LDAPControl* )HeapAlloc( GetProcessHeap(), 0, sizeof(LDAPControl) );
+    if (!controlU)
+    {
+        HeapFree( GetProcessHeap(), 0, val );
+        return NULL;
+    }
+
+    controlU->ldctl_oid = strWtoU( control->ldctl_oid );
+    controlU->ldctl_value.bv_len = len; 
+    controlU->ldctl_value.bv_val = val; 
+    controlU->ldctl_iscritical = control->ldctl_iscritical;
+
+    return controlU;
+}
+
+static inline LDAPControlW *controlUtoW( LDAPControl *control )
+{
+    LDAPControlW *controlW;
+    DWORD len = control->ldctl_value.bv_len;
+    char *val = NULL;
+
+    if (control->ldctl_value.bv_val)
+    {
+        val = ( char* )HeapAlloc( GetProcessHeap(), 0, len );
+        if (!val) return NULL;
+        memcpy( val, control->ldctl_value.bv_val, len );
+    }
+
+    controlW = ( LDAPControlW* )HeapAlloc( GetProcessHeap(), 0, sizeof(LDAPControlW) );
+    if (!controlW)
+    {
+        HeapFree( GetProcessHeap(), 0, val );
+        return NULL;
+    }
+
+    controlW->ldctl_oid = strUtoW( control->ldctl_oid );
+    controlW->ldctl_value.bv_len = len; 
+    controlW->ldctl_value.bv_val = val; 
+    controlW->ldctl_iscritical = control->ldctl_iscritical;
+ 
+    return controlW;
+}
+
+static inline void controlfreeA( LDAPControlA *control )
+{
+    if (control)
+    {
+        strfreeA( control->ldctl_oid );
+        HeapFree( GetProcessHeap(), 0, control->ldctl_value.bv_val );
+        HeapFree( GetProcessHeap(), 0, control );
+    }
+}
+
+static inline void controlfreeW( LDAPControlW *control )
+{
+    if (control)
+    {
+        strfreeW( control->ldctl_oid );
+        HeapFree( GetProcessHeap(), 0, control->ldctl_value.bv_val );
+        HeapFree( GetProcessHeap(), 0, control );
+    }
+}
+
+static inline void controlfreeU( LDAPControl *control )
+{
+    if (control)
+    {
+        strfreeU( control->ldctl_oid );
+        HeapFree( GetProcessHeap(), 0, control->ldctl_value.bv_val );
+        HeapFree( GetProcessHeap(), 0, control );
+    }
+}
+
+static inline DWORD controlarraylenA( LDAPControlA **controlarray )
+{
+    LDAPControlA **p = controlarray;
+    while (*p) p++;
+    return p - controlarray;
+}
+
+static inline DWORD controlarraylenW( LDAPControlW **controlarray )
+{
+    LDAPControlW **p = controlarray;
+    while (*p) p++;
+    return p - controlarray;
+}
+
+static inline DWORD controlarraylenU( LDAPControl **controlarray )
+{
+    LDAPControl **p = controlarray;
+    while (*p) p++;
+    return p - controlarray;
+}
+
+static inline LDAPControlW **controlarrayAtoW( LDAPControlA **controlarray )
+{
+    LDAPControlW **controlarrayW = NULL;
+    DWORD size;
+
+    if (controlarray)
+    {
+        size = sizeof(LDAPControlW*) * (controlarraylenA( controlarray ) + 1);
+        controlarrayW = ( LDAPControlW ** )HeapAlloc( GetProcessHeap(), 0, size );
+
+        if (controlarrayW)
+        {
+            LDAPControlA **p = controlarray;
+            LDAPControlW **q = controlarrayW;
+
+            while (*p) *q++ = controlAtoW( *p++ );
+            *q = NULL;
+        }
+    }
+    return controlarrayW;
+}
+
+static inline LDAPControlA **controlarrayWtoA( LDAPControlW **controlarray )
+{
+    LDAPControlA **controlarrayA = NULL;
+    DWORD size;
+
+    if (controlarray)
+    {
+        size = sizeof(LDAPControl*) * (controlarraylenW( controlarray ) + 1);
+        controlarrayA = ( LDAPControlA** )HeapAlloc( GetProcessHeap(), 0, size );
+
+        if (controlarrayA)
+        {
+            LDAPControlW **p = controlarray;
+            LDAPControlA **q = controlarrayA;
+
+            while (*p) *q++ = controlWtoA( *p++ );
+            *q = NULL;
+        }
+    }
+    return controlarrayA;
+}
+
+static inline LDAPControl **controlarrayWtoU( LDAPControlW **controlarray )
+{
+    LDAPControl **controlarrayU = NULL;
+    DWORD size;
+
+    if (controlarray)
+    {
+        size = sizeof(LDAPControl*) * (controlarraylenW( controlarray ) + 1);
+        controlarrayU = ( LDAPControl ** )HeapAlloc( GetProcessHeap(), 0, size );
+
+        if (controlarrayU)
+        {
+            LDAPControlW **p = controlarray;
+            LDAPControl **q = controlarrayU;
+
+            while (*p) *q++ = controlWtoU( *p++ );
+            *q = NULL;
+        }
+    }
+    return controlarrayU;
+}
+
+static inline LDAPControlW **controlarrayUtoW( LDAPControl **controlarray )
+{
+    LDAPControlW **controlarrayW = NULL;
+    DWORD size;
+
+    if (controlarray)
+    {
+        size = sizeof(LDAPControlW*) * (controlarraylenU( controlarray ) + 1);
+        controlarrayW = (LDAPControlW** )HeapAlloc( GetProcessHeap(), 0, size );
+
+        if (controlarrayW)
+        {
+            LDAPControl **p = controlarray;
+            LDAPControlW **q = controlarrayW;
+
+            while (*p) *q++ = controlUtoW( *p++ );
+            *q = NULL;
+        }
+    }
+    return controlarrayW;
+}
+
+static inline void controlarrayfreeA( LDAPControlA **controlarray )
+{
+    if (controlarray)
+    {
+        LDAPControlA **p = controlarray;
+        while (*p) controlfreeA( *p++ );
+        HeapFree( GetProcessHeap(), 0, controlarray );
+    }
+}
+
+static inline void controlarrayfreeW( LDAPControlW **controlarray )
+{
+    if (controlarray)
+    {
+        LDAPControlW **p = controlarray;
+        while (*p) controlfreeW( *p++ );
+        HeapFree( GetProcessHeap(), 0, controlarray );
+    }
+}
+
+static inline void controlarrayfreeU( LDAPControl **controlarray )
+{
+    if (controlarray)
+    {
+        LDAPControl **p = controlarray;
+        while (*p) controlfreeU( *p++ );
+        HeapFree( GetProcessHeap(), 0, controlarray );
+    }
+}
+/*
+static inline LDAPSortKeyW *sortkeyAtoW( LDAPSortKeyA *sortkey )
+{
+    LDAPSortKeyW *sortkeyW;
+
+    sortkeyW = ( LDAPSortKeyW* )HeapAlloc( GetProcessHeap(), 0, sizeof(LDAPSortKeyW) );
+    if (sortkeyW)
+    {
+        sortkeyW->sk_attrtype = strAtoW( sortkey->sk_attrtype );
+        sortkeyW->sk_matchruleoid = strAtoW( sortkey->sk_matchruleoid );
+        sortkeyW->sk_reverseorder = sortkey->sk_reverseorder;
+    }
+    return sortkeyW;
+}
+
+static inline LDAPSortKeyA *sortkeyWtoA( LDAPSortKeyW *sortkey )
+{
+    LDAPSortKeyA *sortkeyA;
+
+    sortkeyA = ( LDAPSortKeyA* )HeapAlloc( GetProcessHeap(), 0, sizeof(LDAPSortKeyA) );
+    if (sortkeyA)
+    {
+        sortkeyA->sk_attrtype = strWtoA( sortkey->sk_attrtype );
+        sortkeyA->sk_matchruleoid = strWtoA( sortkey->sk_matchruleoid );
+        sortkeyA->sk_reverseorder = sortkey->sk_reverseorder;
+    }
+    return sortkeyA;
+}
+
+static inline LDAPSortKey *sortkeyWtoU( LDAPSortKeyW *sortkey )
+{
+    LDAPSortKey *sortkeyU;
+
+    sortkeyU = ( LDAPSortKey* )HeapAlloc( GetProcessHeap(), 0, sizeof(LDAPSortKey) );
+    if (sortkeyU)
+    {
+        sortkeyU->attributeType = strWtoU( sortkey->sk_attrtype );
+        sortkeyU->orderingRule = strWtoU( sortkey->sk_matchruleoid );
+        sortkeyU->reverseOrder = sortkey->sk_reverseorder;
+    }
+    return sortkeyU;
+}
+
+static inline void sortkeyfreeA( LDAPSortKeyA *sortkey )
+{
+    if (sortkey)
+    {
+        strfreeA( sortkey->sk_attrtype );
+        strfreeA( sortkey->sk_matchruleoid );
+        HeapFree( GetProcessHeap(), 0, sortkey );
+    }
+}
+
+static inline void sortkeyfreeW( LDAPSortKeyW *sortkey )
+{
+    if (sortkey)
+    {
+        strfreeW( sortkey->sk_attrtype );
+        strfreeW( sortkey->sk_matchruleoid );
+        HeapFree( GetProcessHeap(), 0, sortkey );
+    }
+}
+
+static inline void sortkeyfreeU( LDAPSortKey *sortkey )
+{
+    if (sortkey)
+    {
+        strfreeU( sortkey->attributeType );
+        strfreeU( sortkey->orderingRule );
+        HeapFree( GetProcessHeap(), 0, sortkey );
+    }
+}
+
+static inline DWORD sortkeyarraylenA( LDAPSortKeyA **sortkeyarray )
+{
+    LDAPSortKeyA **p = sortkeyarray;
+    while (*p) p++;
+    return p - sortkeyarray;
+}
+
+static inline DWORD sortkeyarraylenW( LDAPSortKeyW **sortkeyarray )
+{
+    LDAPSortKeyW **p = sortkeyarray;
+    while (*p) p++;
+    return p - sortkeyarray;
+}
+
+static inline LDAPSortKeyW **sortkeyarrayAtoW( LDAPSortKeyA **sortkeyarray )
+{
+    LDAPSortKeyW **sortkeyarrayW = NULL;
+    DWORD size;
+
+    if (sortkeyarray)
+    {
+        size = sizeof(LDAPSortKeyW*) * (sortkeyarraylenA( sortkeyarray ) + 1);
+        sortkeyarrayW = ( LDAPSortKeyW** )HeapAlloc( GetProcessHeap(), 0, size );
+
+        if (sortkeyarrayW)
+        {
+            LDAPSortKeyA **p = sortkeyarray;
+            LDAPSortKeyW **q = sortkeyarrayW;
+
+            while (*p) *q++ = sortkeyAtoW( *p++ );
+            *q = NULL;
+        }
+    }
+    return sortkeyarrayW;
+}
+
+static inline LDAPSortKey **sortkeyarrayWtoU( LDAPSortKeyW **sortkeyarray )
+{
+    LDAPSortKey **sortkeyarrayU = NULL;
+    DWORD size;
+
+    if (sortkeyarray)
+    {
+        size = sizeof(LDAPSortKey*) * (sortkeyarraylenW( sortkeyarray ) + 1);
+        sortkeyarrayU = ( LDAPSortKey ** )HeapAlloc( GetProcessHeap(), 0, size );
+
+        if (sortkeyarrayU)
+        {
+            LDAPSortKeyW **p = sortkeyarray;
+            LDAPSortKey **q = sortkeyarrayU;
+
+            while (*p) *q++ = sortkeyWtoU( *p++ );
+            *q = NULL;
+        }
+    }
+    return sortkeyarrayU;
+}
+
+static inline void sortkeyarrayfreeW( LDAPSortKeyW **sortkeyarray )
+{
+    if (sortkeyarray)
+    {
+        LDAPSortKeyW **p = sortkeyarray;
+        while (*p) sortkeyfreeW( *p++ );
+        HeapFree( GetProcessHeap(), 0, sortkeyarray );
+    }
+}
+
+static inline void sortkeyarrayfreeU( LDAPSortKey **sortkeyarray )
+{
+    if (sortkeyarray)
+    {
+        LDAPSortKey **p = sortkeyarray;
+        while (*p) sortkeyfreeU( *p++ );
+        HeapFree( GetProcessHeap(), 0, sortkeyarray );
+    }
+}
+*/
+#endif // WINCELDAP_H
