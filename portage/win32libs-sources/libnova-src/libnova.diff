diff -N -r -u libnova-0.12.1/Makefile.in libnova-0.12.1w/Makefile.in
--- libnova-0.12.1/Makefile.in	2007-01-19 11:10:03.000000000 +0100
+++ libnova-0.12.1w/Makefile.in	2007-11-25 23:32:37.812500000 +0100
@@ -93,7 +93,7 @@
 STRIP = @STRIP@
 VERSION = @VERSION@
 
-SUBDIRS = src lntest doc examples
+SUBDIRS = src doc examples
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
 CONFIG_HEADER = config.h
diff -N -r -u libnova-0.12.1/src/julian_day.c libnova-0.12.1w/src/julian_day.c
--- libnova-0.12.1/src/julian_day.c	2007-01-17 01:16:02.000000000 +0100
+++ libnova-0.12.1w/src/julian_day.c	2007-11-25 21:33:49.281250000 +0100
@@ -286,8 +286,8 @@
 #ifndef __WIN32__
 	time_t curtime;
 	struct tm *loctime;
-	long gmtoff;
 #endif
+	long gmtoff;
 	
 	ln_get_date (JD, &date);
 
diff -N -r -u libnova-0.12.1/src/utility.c libnova-0.12.1w/src/utility.c
--- libnova-0.12.1/src/utility.c	2007-01-17 01:16:02.000000000 +0100
+++ libnova-0.12.1w/src/utility.c	2007-11-25 23:40:53.000000000 +0100
@@ -728,6 +728,7 @@
 #ifdef __WIN32__
 
 /* Catches calls to the POSIX gettimeofday and converts them to a related WIN32 version. */
+/*
 int gettimeofday(struct timeval *tv, struct timezone *tz)
 {
 	struct _timeb timeptr;
@@ -742,19 +743,48 @@
 
 	return 0;
 }
+*/
 
 /* Catches calls to the POSIX gmtime_r and converts them to a related WIN32 version. */
+/*
 struct tm *gmtime_r (time_t *t, struct tm *gmt)
 {
 	gmtime_s (gmt, t);
 
 	return gmt;
 }
+*/
 
 /* Catches calls to the POSIX strtok_r and converts them to a related WIN32 version. */
-char *strtok_r(char *str, const char *sep, char **last)
+
+char *strtok_r(char *s, const char *delim, char **save_ptr)
 {
-	return strtok_s(str, sep, last);
+  char *token;
+
+  if (s == NULL)
+    s = *save_ptr;
+
+  /* Scan leading delimiters.  */
+  s += strspn (s, delim);
+  if (*s == '\0')
+    {
+      *save_ptr = s;
+      return NULL;
+    }
+
+  /* Find the end of the token.  */
+  token = s;
+  s = strpbrk (token, delim);
+  if (s == NULL)
+    /* This token finishes the string.  */
+    *save_ptr = strchr (token, '\0');
+  else
+    {
+      /* Terminate the token and make *SAVE_PTR point past it.  */
+      *s = '\0';
+      *save_ptr = s + 1;
+    }
+  return token;
 }
 
 #endif /* __WIN32__ */
