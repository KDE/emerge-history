diff -Nru libsndfile-1.0.21.orig/CMakeLists.txt libsndfile-1.0.21/CMakeLists.txt
--- libsndfile-1.0.21.orig/CMakeLists.txt	Thu Jan  1 02:00:00 1970
+++ libsndfile-1.0.21/CMakeLists.txt	Wed Jul  7 18:47:41 2010
@@ -0,0 +1,5 @@
+project (libsndfile)
+
+cmake_minimum_required (VERSION 2.6)
+
+add_subdirectory(src)
diff -Nru libsndfile-1.0.21.orig/src/CMakeLists.txt libsndfile-1.0.21/src/CMakeLists.txt
--- libsndfile-1.0.21.orig/src/CMakeLists.txt	Thu Jan  1 02:00:00 1970
+++ libsndfile-1.0.21/src/CMakeLists.txt	Wed Jul  7 18:56:50 2010
@@ -0,0 +1,9 @@
+add_definitions(/wd 4244 /D_CRT_SECURE_NO_WARNINGS)
+add_library (sndfile SHARED sndfile.c common.c file_io.c command.c pcm.c ulaw.c alaw.c float32.c double64.c ima_adpcm.c ms_adpcm.c gsm610.c dwvw.c vox_adpcm.c interleave.c strings.c dither.c broadcast.c aiff.c au.c g72x.c avr.c caf.c ircam.c macbinary3.c macos.c mat4.c mat5.c nist.c paf.c pvf.c raw.c svx.c voc.c htk.c dwd.c ogg.c rx2.c sd2.c sds.c txw.c wve.c w64.c wav_w64.c wav.c xi.c flac.c G72x/g72x.c G72x/g721.c G72x/g723_16.c G72x/g723_24.c G72x/g723_40.c GSM610/add.c GSM610/decode.c GSM610/gsm_decode.c GSM610/gsm_encode.c GSM610/long_term.c GSM610/preprocess.c GSM610/short_term.c GSM610/code.c GSM610/gsm_create.c GSM610/gsm_destroy.c GSM610/gsm_option.c GSM610/lpc.c GSM610/rpe.c GSM610/table.c sndfile.def libsndfile.rc)
+
+include_directories(.)
+
+install(TARGETS sndfile RUNTIME DESTINATION bin
+                           LIBRARY DESTINATION lib
+                           ARCHIVE DESTINATION lib)
+install(FILES sndfile.h DESTINATION include)
diff -Nru libsndfile-1.0.21.orig/src/GSM610/gsm610_priv.h libsndfile-1.0.21/src/GSM610/gsm610_priv.h
--- libsndfile-1.0.21.orig/src/GSM610/gsm610_priv.h	Sun Mar 22 21:17:14 2009
+++ libsndfile-1.0.21/src/GSM610/gsm610_priv.h	Wed Jul  7 17:50:42 2010
@@ -1,301 +1,305 @@
-/*
- * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
- * Universitaet Berlin.  See the accompanying file "COPYRIGHT" for
- * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
- */
-
-#ifndef	PRIVATE_H
-#define	PRIVATE_H
-
-/* Added by Erik de Castro Lopo */
-#define	USE_FLOAT_MUL
-#define	FAST
-#define	WAV49
-
-#ifdef __cplusplus
-#error "This code is not designed to be compiled with a C++ compiler."
-#endif
-/* Added by Erik de Castro Lopo */
-
-
-
-typedef short				word;		/* 16 bit signed int	*/
-typedef int					longword;	/* 32 bit signed int	*/
-
-typedef unsigned short		uword;		/* unsigned word	*/
-typedef unsigned int		ulongword;	/* unsigned longword	*/
-
-struct gsm_state
-{	word			dp0[ 280 ] ;
-
-	word			z1;			/* preprocessing.c, Offset_com. */
-	longword		L_z2;		/*                  Offset_com. */
-	int				mp;			/*                  Preemphasis	*/
-
-	word			u[8] ;			/* short_term_aly_filter.c	*/
-	word			LARpp[2][8] ; 	/*                              */
-	word			j;				/*                              */
-
-	word	        ltp_cut;        /* long_term.c, LTP crosscorr.  */
-	word			nrp; 			/* 40 */	/* long_term.c, synthesis	*/
-	word			v[9] ;			/* short_term.c, synthesis	*/
-	word			msr;			/* decoder.c,	Postprocessing	*/
-
-	char			verbose;		/* only used if !NDEBUG		*/
-	char			fast;			/* only used if FAST		*/
-
-	char			wav_fmt;		/* only used if WAV49 defined	*/
-	unsigned char	frame_index;	/*            odd/even chaining	*/
-	unsigned char	frame_chain;	/*   half-byte to carry forward	*/
-
-	/* Moved here from code.c where it was defined as static */
-	word e[50] ;
-} ;
-
-typedef struct gsm_state GSM_STATE ;
-
-#define	MIN_WORD	(-32767 - 1)
-#define	MAX_WORD	  32767
-
-#define	MIN_LONGWORD	(-2147483647 - 1)
-#define	MAX_LONGWORD	  2147483647
-
-/* Signed arithmetic shift right. */
-static inline word
-SASR_W (word x, word by)
-{	return (x >> by) ;
-} /* SASR */
-
-static inline longword
-SASR_L (longword x, word by)
-{	return (x >> by) ;
-} /* SASR */
-
-/*
- *	Prototypes from add.c
- */
-word	gsm_mult 		(word a, word b) ;
-longword gsm_L_mult 	(word a, word b) ;
-word	gsm_mult_r		(word a, word b) ;
-
-word	gsm_div  		(word num, word denum) ;
-
-word	gsm_add 		(word a, word b ) ;
-longword gsm_L_add 	(longword a, longword b ) ;
-
-word	gsm_sub 		(word a, word b) ;
-longword gsm_L_sub 	(longword a, longword b) ;
-
-word	gsm_abs 		(word a) ;
-
-word	gsm_norm 		(longword a ) ;
-
-longword gsm_L_asl  	(longword a, int n) ;
-word	gsm_asl 		(word a, int n) ;
-
-longword gsm_L_asr  	(longword a, int n) ;
-word	gsm_asr  		(word a, int n) ;
-
-/*
- *  Inlined functions from add.h
- */
-
-static inline longword
-GSM_MULT_R (word a, word b)
-{	return (((longword) (a)) * ((longword) (b)) + 16384) >> 15 ;
-} /* GSM_MULT_R */
-
-static inline longword
-GSM_MULT (word a, word b)
-{	return (((longword) (a)) * ((longword) (b))) >> 15 ;
-} /* GSM_MULT */
-
-static inline longword
-GSM_L_MULT (word a, word b)
-{	return ((longword) (a)) * ((longword) (b)) << 1 ;
-} /* GSM_L_MULT */
-
-static inline longword
-GSM_L_ADD (longword a, longword b)
-{	ulongword utmp ;
-
-	if (a < 0 && b < 0)
-	{	utmp = (ulongword)-((a) + 1) + (ulongword)-((b) + 1) ;
-		return (utmp >= (ulongword) MAX_LONGWORD) ? MIN_LONGWORD : -(longword)utmp-2 ;
-		} ;
-
-	if (a > 0 && b > 0)
-	{	utmp = (ulongword) a + (ulongword) b ;
-		return (utmp >= (ulongword) MAX_LONGWORD) ? MAX_LONGWORD : utmp ;
-		} ;
-
-	return a + b ;
-} /* GSM_L_ADD */
-
-static inline longword
-GSM_ADD (word a, word b)
-{	longword ltmp ;
-
-	ltmp = ((longword) a) + ((longword) b) ;
-
-	if (ltmp >= MAX_WORD)
-		return MAX_WORD ;
-	if (ltmp <= MIN_WORD)
-		return MIN_WORD ;
-
-	return ltmp ;
-} /* GSM_ADD */
-
-static inline longword
-GSM_SUB (word a, word b)
-{	longword ltmp ;
-
-	ltmp = ((longword) a) - ((longword) b) ;
-
-	if (ltmp >= MAX_WORD)
-		ltmp = MAX_WORD ;
-	else if (ltmp <= MIN_WORD)
-		ltmp = MIN_WORD ;
-
-	return ltmp ;
-} /* GSM_SUB */
-
-static inline word
-GSM_ABS (word a)
-{
-	if (a > 0)
-		return a ;
-	if (a == MIN_WORD)
-		return MAX_WORD ;
-	return -a ;
-} /* GSM_ADD */
-
-
-/*
- *  More prototypes from implementations..
- */
-void Gsm_Coder (
-		struct gsm_state	* S,
-		word	* s,	/* [0..159] samples		IN	*/
-		word	* LARc,	/* [0..7] LAR coefficients	OUT	*/
-		word	* Nc,	/* [0..3] LTP lag		OUT 	*/
-		word	* bc,	/* [0..3] coded LTP gain	OUT 	*/
-		word	* Mc,	/* [0..3] RPE grid selection	OUT     */
-		word	* xmaxc,/* [0..3] Coded maximum amplitude OUT	*/
-		word	* xMc) ;/* [13*4] normalized RPE samples OUT	*/
-
-void Gsm_Long_Term_Predictor (		/* 4x for 160 samples */
-		struct gsm_state * S,
-		word	* d,	/* [0..39]   residual signal	IN	*/
-		word	* dp,	/* [-120..-1] d'		IN	*/
-		word	* e,	/* [0..40] 			OUT	*/
-		word	* dpp,	/* [0..40] 			OUT	*/
-		word	* Nc,	/* correlation lag		OUT	*/
-		word	* bc) ;	/* gain factor			OUT	*/
-
-void Gsm_LPC_Analysis (
-		struct gsm_state * S,
-		word * s,		/* 0..159 signals	IN/OUT	*/
-		word * LARc) ;   /* 0..7   LARc's	OUT	*/
-
-void Gsm_Preprocess (
-		struct gsm_state * S,
-		word * s, word * so) ;
-
-void Gsm_Encoding (
-		struct gsm_state * S,
-		word	* e,
-		word	* ep,
-		word	* xmaxc,
-		word	* Mc,
-		word	* xMc) ;
-
-void Gsm_Short_Term_Analysis_Filter (
-		struct gsm_state * S,
-		word	* LARc,	/* coded log area ratio [0..7]  IN	*/
-		word	* d) ;	/* st res. signal [0..159]	IN/OUT	*/
-
-void Gsm_Decoder (
-		struct gsm_state * S,
-		word	* LARcr,	/* [0..7]		IN	*/
-		word	* Ncr,		/* [0..3] 		IN 	*/
-		word	* bcr,		/* [0..3]		IN	*/
-		word	* Mcr,		/* [0..3] 		IN 	*/
-		word	* xmaxcr,	/* [0..3]		IN 	*/
-		word	* xMcr,		/* [0..13*4]		IN	*/
-		word	* s) ;		/* [0..159]		OUT 	*/
-
-void Gsm_Decoding (
-		struct gsm_state * S,
-		word 	xmaxcr,
-		word	Mcr,
-		word	* xMcr,  	/* [0..12]		IN	*/
-		word	* erp) ; 	/* [0..39]		OUT 	*/
-
-void Gsm_Long_Term_Synthesis_Filtering (
-		struct gsm_state* S,
-		word	Ncr,
-		word	bcr,
-		word	* erp,		/* [0..39]		  IN 	*/
-		word	* drp) ; 	/* [-120..-1] IN, [0..40] OUT 	*/
-
-void Gsm_RPE_Decoding (
-	/*-struct gsm_state *S,-*/
-		word xmaxcr,
-		word Mcr,
-		word * xMcr,  /* [0..12], 3 bits             IN      */
-		word * erp) ; /* [0..39]                     OUT     */
-
-void Gsm_RPE_Encoding (
-		/*-struct gsm_state * S,-*/
-		word    * e,            /* -5..-1][0..39][40..44     IN/OUT  */
-		word    * xmaxc,        /*                              OUT */
-		word    * Mc,           /*                              OUT */
-		word    * xMc) ;        /* [0..12]                      OUT */
-
-void Gsm_Short_Term_Synthesis_Filter (
-		struct gsm_state * S,
-		word	* LARcr, 	/* log area ratios [0..7]  IN	*/
-		word	* drp,		/* received d [0...39]	   IN	*/
-		word	* s) ;		/* signal   s [0..159]	  OUT	*/
-
-void Gsm_Update_of_reconstructed_short_time_residual_signal (
-		word	* dpp,		/* [0...39]	IN	*/
-		word	* ep,		/* [0...39]	IN	*/
-		word	* dp) ;		/* [-120...-1]  IN/OUT 	*/
-
-/*
- *  Tables from table.c
- */
-#ifndef	GSM_TABLE_C
-
-extern word gsm_A [8], gsm_B [8], gsm_MIC [8], gsm_MAC [8] ;
-extern word gsm_INVA [8] ;
-extern word gsm_DLB [4], gsm_QLB [4] ;
-extern word gsm_H [11] ;
-extern word gsm_NRFAC [8] ;
-extern word gsm_FAC [8] ;
-
-#endif	/* GSM_TABLE_C */
-
-/*
- *  Debugging
- */
-#ifdef NDEBUG
-
-#	define	gsm_debug_words(a, b, c, d)		/* nil */
-#	define	gsm_debug_longwords(a, b, c, d)		/* nil */
-#	define	gsm_debug_word(a, b)			/* nil */
-#	define	gsm_debug_longword(a, b)		/* nil */
-
-#else	/* !NDEBUG => DEBUG */
-
-	void  gsm_debug_words     (char * name, int, int, word *) ;
-	void  gsm_debug_longwords (char * name, int, int, longword *) ;
-	void  gsm_debug_longword  (char * name, longword) ;
-	void  gsm_debug_word      (char * name, word) ;
-
-#endif /* !NDEBUG */
-
-#endif	/* PRIVATE_H */
-
+/*
+ * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
+ * Universitaet Berlin.  See the accompanying file "COPYRIGHT" for
+ * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
+ */
+
+#ifndef	PRIVATE_H
+#define	PRIVATE_H
+
+/* Added by Erik de Castro Lopo */
+#define	USE_FLOAT_MUL
+#define	FAST
+#define	WAV49
+
+#ifdef __cplusplus
+#error "This code is not designed to be compiled with a C++ compiler."
+#endif
+/* Added by Erik de Castro Lopo */
+
+
+#ifdef _MSC_VER
+#define inline _inline
+#endif
+
+
+typedef short				word;		/* 16 bit signed int	*/
+typedef int					longword;	/* 32 bit signed int	*/
+
+typedef unsigned short		uword;		/* unsigned word	*/
+typedef unsigned int		ulongword;	/* unsigned longword	*/
+
+struct gsm_state
+{	word			dp0[ 280 ] ;
+
+	word			z1;			/* preprocessing.c, Offset_com. */
+	longword		L_z2;		/*                  Offset_com. */
+	int				mp;			/*                  Preemphasis	*/
+
+	word			u[8] ;			/* short_term_aly_filter.c	*/
+	word			LARpp[2][8] ; 	/*                              */
+	word			j;				/*                              */
+
+	word	        ltp_cut;        /* long_term.c, LTP crosscorr.  */
+	word			nrp; 			/* 40 */	/* long_term.c, synthesis	*/
+	word			v[9] ;			/* short_term.c, synthesis	*/
+	word			msr;			/* decoder.c,	Postprocessing	*/
+
+	char			verbose;		/* only used if !NDEBUG		*/
+	char			fast;			/* only used if FAST		*/
+
+	char			wav_fmt;		/* only used if WAV49 defined	*/
+	unsigned char	frame_index;	/*            odd/even chaining	*/
+	unsigned char	frame_chain;	/*   half-byte to carry forward	*/
+
+	/* Moved here from code.c where it was defined as static */
+	word e[50] ;
+} ;
+
+typedef struct gsm_state GSM_STATE ;
+
+#define	MIN_WORD	(-32767 - 1)
+#define	MAX_WORD	  32767
+
+#define	MIN_LONGWORD	(-2147483647 - 1)
+#define	MAX_LONGWORD	  2147483647
+
+/* Signed arithmetic shift right. */
+static inline word
+SASR_W (word x, word by)
+{	return (x >> by) ;
+} /* SASR */
+
+static inline longword
+SASR_L (longword x, word by)
+{	return (x >> by) ;
+} /* SASR */
+
+/*
+ *	Prototypes from add.c
+ */
+word	gsm_mult 		(word a, word b) ;
+longword gsm_L_mult 	(word a, word b) ;
+word	gsm_mult_r		(word a, word b) ;
+
+word	gsm_div  		(word num, word denum) ;
+
+word	gsm_add 		(word a, word b ) ;
+longword gsm_L_add 	(longword a, longword b ) ;
+
+word	gsm_sub 		(word a, word b) ;
+longword gsm_L_sub 	(longword a, longword b) ;
+
+word	gsm_abs 		(word a) ;
+
+word	gsm_norm 		(longword a ) ;
+
+longword gsm_L_asl  	(longword a, int n) ;
+word	gsm_asl 		(word a, int n) ;
+
+longword gsm_L_asr  	(longword a, int n) ;
+word	gsm_asr  		(word a, int n) ;
+
+/*
+ *  Inlined functions from add.h
+ */
+
+static inline longword
+GSM_MULT_R (word a, word b)
+{	return (((longword) (a)) * ((longword) (b)) + 16384) >> 15 ;
+} /* GSM_MULT_R */
+
+static inline longword
+GSM_MULT (word a, word b)
+{	return (((longword) (a)) * ((longword) (b))) >> 15 ;
+} /* GSM_MULT */
+
+static inline longword
+GSM_L_MULT (word a, word b)
+{	return ((longword) (a)) * ((longword) (b)) << 1 ;

+} /* GSM_L_MULT */
+
+static inline longword
+GSM_L_ADD (longword a, longword b)
+{	ulongword utmp ;
+
+	if (a < 0 && b < 0)
+	{	utmp = (ulongword)-((a) + 1) + (ulongword)-((b) + 1) ;
+		return (utmp >= (ulongword) MAX_LONGWORD) ? MIN_LONGWORD : -(longword)utmp-2 ;
+		} ;
+
+	if (a > 0 && b > 0)
+	{	utmp = (ulongword) a + (ulongword) b ;
+		return (utmp >= (ulongword) MAX_LONGWORD) ? MAX_LONGWORD : utmp ;
+		} ;
+
+	return a + b ;
+} /* GSM_L_ADD */
+
+static inline longword
+GSM_ADD (word a, word b)
+{	longword ltmp ;
+
+	ltmp = ((longword) a) + ((longword) b) ;
+
+	if (ltmp >= MAX_WORD)
+		return MAX_WORD ;
+	if (ltmp <= MIN_WORD)
+		return MIN_WORD ;
+
+	return ltmp ;
+} /* GSM_ADD */
+
+static inline longword
+GSM_SUB (word a, word b)
+{	longword ltmp ;
+
+	ltmp = ((longword) a) - ((longword) b) ;
+
+	if (ltmp >= MAX_WORD)
+		ltmp = MAX_WORD ;
+	else if (ltmp <= MIN_WORD)
+		ltmp = MIN_WORD ;
+
+	return ltmp ;
+} /* GSM_SUB */
+
+static inline word
+GSM_ABS (word a)
+{
+	if (a > 0)
+		return a ;
+	if (a == MIN_WORD)
+		return MAX_WORD ;
+	return -a ;
+} /* GSM_ADD */
+
+
+/*
+ *  More prototypes from implementations..
+ */
+void Gsm_Coder (
+		struct gsm_state	* S,
+		word	* s,	/* [0..159] samples		IN	*/
+		word	* LARc,	/* [0..7] LAR coefficients	OUT	*/
+		word	* Nc,	/* [0..3] LTP lag		OUT 	*/
+		word	* bc,	/* [0..3] coded LTP gain	OUT 	*/
+		word	* Mc,	/* [0..3] RPE grid selection	OUT     */
+		word	* xmaxc,/* [0..3] Coded maximum amplitude OUT	*/
+		word	* xMc) ;/* [13*4] normalized RPE samples OUT	*/
+
+void Gsm_Long_Term_Predictor (		/* 4x for 160 samples */
+		struct gsm_state * S,
+		word	* d,	/* [0..39]   residual signal	IN	*/
+		word	* dp,	/* [-120..-1] d'		IN	*/
+		word	* e,	/* [0..40] 			OUT	*/
+		word	* dpp,	/* [0..40] 			OUT	*/
+		word	* Nc,	/* correlation lag		OUT	*/
+		word	* bc) ;	/* gain factor			OUT	*/
+
+void Gsm_LPC_Analysis (
+		struct gsm_state * S,
+		word * s,		/* 0..159 signals	IN/OUT	*/
+		word * LARc) ;   /* 0..7   LARc's	OUT	*/
+
+void Gsm_Preprocess (
+		struct gsm_state * S,
+		word * s, word * so) ;
+
+void Gsm_Encoding (
+		struct gsm_state * S,
+		word	* e,
+		word	* ep,
+		word	* xmaxc,
+		word	* Mc,
+		word	* xMc) ;
+
+void Gsm_Short_Term_Analysis_Filter (
+		struct gsm_state * S,
+		word	* LARc,	/* coded log area ratio [0..7]  IN	*/
+		word	* d) ;	/* st res. signal [0..159]	IN/OUT	*/
+
+void Gsm_Decoder (
+		struct gsm_state * S,
+		word	* LARcr,	/* [0..7]		IN	*/
+		word	* Ncr,		/* [0..3] 		IN 	*/
+		word	* bcr,		/* [0..3]		IN	*/
+		word	* Mcr,		/* [0..3] 		IN 	*/
+		word	* xmaxcr,	/* [0..3]		IN 	*/
+		word	* xMcr,		/* [0..13*4]		IN	*/
+		word	* s) ;		/* [0..159]		OUT 	*/
+
+void Gsm_Decoding (
+		struct gsm_state * S,
+		word 	xmaxcr,
+		word	Mcr,
+		word	* xMcr,  	/* [0..12]		IN	*/
+		word	* erp) ; 	/* [0..39]		OUT 	*/
+
+void Gsm_Long_Term_Synthesis_Filtering (
+		struct gsm_state* S,
+		word	Ncr,
+		word	bcr,
+		word	* erp,		/* [0..39]		  IN 	*/
+		word	* drp) ; 	/* [-120..-1] IN, [0..40] OUT 	*/
+
+void Gsm_RPE_Decoding (
+	/*-struct gsm_state *S,-*/
+		word xmaxcr,
+		word Mcr,
+		word * xMcr,  /* [0..12], 3 bits             IN      */
+		word * erp) ; /* [0..39]                     OUT     */
+
+void Gsm_RPE_Encoding (
+		/*-struct gsm_state * S,-*/
+		word    * e,            /* -5..-1][0..39][40..44     IN/OUT  */
+		word    * xmaxc,        /*                              OUT */
+		word    * Mc,           /*                              OUT */
+		word    * xMc) ;        /* [0..12]                      OUT */
+
+void Gsm_Short_Term_Synthesis_Filter (
+		struct gsm_state * S,
+		word	* LARcr, 	/* log area ratios [0..7]  IN	*/
+		word	* drp,		/* received d [0...39]	   IN	*/
+		word	* s) ;		/* signal   s [0..159]	  OUT	*/
+
+void Gsm_Update_of_reconstructed_short_time_residual_signal (
+		word	* dpp,		/* [0...39]	IN	*/
+		word	* ep,		/* [0...39]	IN	*/
+		word	* dp) ;		/* [-120...-1]  IN/OUT 	*/
+
+/*
+ *  Tables from table.c
+ */
+#ifndef	GSM_TABLE_C
+
+extern word gsm_A [8], gsm_B [8], gsm_MIC [8], gsm_MAC [8] ;
+extern word gsm_INVA [8] ;
+extern word gsm_DLB [4], gsm_QLB [4] ;
+extern word gsm_H [11] ;
+extern word gsm_NRFAC [8] ;
+extern word gsm_FAC [8] ;
+
+#endif	/* GSM_TABLE_C */
+
+/*
+ *  Debugging
+ */
+#ifdef NDEBUG
+
+#	define	gsm_debug_words(a, b, c, d)		/* nil */
+#	define	gsm_debug_longwords(a, b, c, d)		/* nil */
+#	define	gsm_debug_word(a, b)			/* nil */
+#	define	gsm_debug_longword(a, b)		/* nil */
+
+#else	/* !NDEBUG => DEBUG */
+
+	void  gsm_debug_words     (char * name, int, int, word *) ;
+	void  gsm_debug_longwords (char * name, int, int, longword *) ;
+	void  gsm_debug_longword  (char * name, longword) ;
+	void  gsm_debug_word      (char * name, word) ;
+
+#endif /* !NDEBUG */
+
+#endif	/* PRIVATE_H */
+
diff -Nru libsndfile-1.0.21.orig/src/aiff.c libsndfile-1.0.21/src/aiff.c
--- libsndfile-1.0.21.orig/src/aiff.c	Thu Dec 10 20:49:30 2009
+++ libsndfile-1.0.21/src/aiff.c	Wed Jul  7 18:25:45 2010
@@ -24,13 +24,14 @@
 #include <string.h>
 #include <time.h>
 #include <ctype.h>
-#include <inttypes.h>
 
 #include "sndfile.h"
 #include "sfendian.h"
 #include "common.h"
 #include "chanmap.h"
 
+#define snprintf _snprintf
+
 /*------------------------------------------------------------------------------
  * Macros to handle big/little endian issues.
  */
@@ -492,7 +493,7 @@
 						psf->peak_info->peaks [dword].value = value ;
 						psf->peak_info->peaks [dword].position = position ;
 
-						snprintf (cptr, sizeof (psf->u.scbuf), "    %2d   %-12" PRId64 "   %g\n",
+						snprintf (cptr, sizeof (psf->u.scbuf), "    %2d   %-12" "%lld" "   %g\n",
 								dword, psf->peak_info->peaks [dword].position, psf->peak_info->peaks [dword].value) ;
 						cptr [sizeof (psf->u.scbuf) - 1] = 0 ;
 						psf_log_printf (psf, "%s", cptr) ;
diff -Nru libsndfile-1.0.21.orig/src/broadcast.c libsndfile-1.0.21/src/broadcast.c
--- libsndfile-1.0.21.orig/src/broadcast.c	Fri Sep 25 11:41:20 2009
+++ libsndfile-1.0.21/src/broadcast.c	Wed Jul  7 18:17:41 2010
@@ -25,6 +25,8 @@
 
 #include "common.h"
 
+#define snprintf _snprintf
+
 static void strncpy_crlf (char *dest, const char *src, size_t destmax, size_t srcmax) ;
 static int gen_coding_history (char * added_history, int added_history_max, const SF_INFO * psfinfo) ;
 
diff -Nru libsndfile-1.0.21.orig/src/caf.c libsndfile-1.0.21/src/caf.c
--- libsndfile-1.0.21.orig/src/caf.c	Thu Dec 10 20:49:30 2009
+++ libsndfile-1.0.21/src/caf.c	Wed Jul  7 18:31:55 2010
@@ -23,13 +23,14 @@
 #include	<string.h>
 #include	<ctype.h>
 #include	<math.h>
-#include	<inttypes.h>
 
 #include	"sndfile.h"
 #include	"sfendian.h"
 #include	"common.h"
 #include	"chanmap.h"
 
+#define snprintf _snprintf
+
 /*------------------------------------------------------------------------------
 ** Macros to handle big/little endian issues.
 */
@@ -350,7 +351,7 @@
 					psf->peak_info->peaks [k].value = value ;
 					psf->peak_info->peaks [k].position = position ;
 
-					snprintf (psf->u.cbuf, sizeof (psf->u.cbuf), "    %2d   %-12" PRId64 "   %g\n", k, position, value) ;
+					snprintf (psf->u.cbuf, sizeof (psf->u.cbuf), "    %2d   %-12" "%lld" "   %g\n", k, position, value) ;
 					psf_log_printf (psf, psf->u.cbuf) ;
 					} ;
 
diff -Nru libsndfile-1.0.21.orig/src/common.c libsndfile-1.0.21/src/common.c
--- libsndfile-1.0.21.orig/src/common.c	Thu Dec 10 20:49:31 2009
+++ libsndfile-1.0.21/src/common.c	Wed Jul  7 17:50:42 2010
@@ -1,1429 +1,1429 @@
-/*
-** Copyright (C) 1999-2009 Erik de Castro Lopo <erikd@mega-nerd.com>
-**
-** This program is free software; you can redistribute it and/or modify
-** it under the terms of the GNU Lesser General Public License as published by
-** the Free Software Foundation; either version 2.1 of the License, or
-** (at your option) any later version.
-**
-** This program is distributed in the hope that it will be useful,
-** but WITHOUT ANY WARRANTY; without even the implied warranty of
-** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-** GNU Lesser General Public License for more details.
-**
-** You should have received a copy of the GNU Lesser General Public License
-** along with this program; if not, write to the Free Software
-** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
-*/
-
-#include	<config.h>
-
-#include	<stdarg.h>
-#include	<string.h>
-#include	<ctype.h>
-#include	<math.h>
-#include	<time.h>
-#include	<sys/time.h>
-
-#include	"sndfile.h"
-#include	"sfendian.h"
-#include	"common.h"
-
-/*-----------------------------------------------------------------------------------------------
-** psf_log_printf allows libsndfile internal functions to print to an internal logbuffer which
-** can later be displayed.
-** The format specifiers are as for printf but without the field width and other modifiers.
-** Printing is performed to the logbuffer char array of the SF_PRIVATE struct.
-** Printing is done in such a way as to guarantee that the log never overflows the end of the
-** logbuffer array.
-*/
-
-static inline void
-log_putchar (SF_PRIVATE *psf, char ch)
-{	if (psf->logindex < SIGNED_SIZEOF (psf->logbuffer) - 1)
-	{	psf->logbuffer [psf->logindex++] = ch ;
-		psf->logbuffer [psf->logindex] = 0 ;
-		} ;
-	return ;
-} /* log_putchar */
-
-void
-psf_log_printf (SF_PRIVATE *psf, const char *format, ...)
-{	va_list			ap ;
-	unsigned int	u ;
-	int				d, tens, shift, width, width_specifier, left_align ;
-	char			c, *strptr, istr [5], lead_char, sign_char ;
-
-	va_start (ap, format) ;
-
-	while ((c = *format++))
-	{	if (c != '%')
-		{	log_putchar (psf, c) ;
-			continue ;
-			} ;
-
-		if (format [0] == '%') /* Handle %% */
-		{ 	log_putchar (psf, '%') ;
-			format ++ ;
-			continue ;
-			} ;
-
-		sign_char = 0 ;
-		left_align = SF_FALSE ;
-		while (1)
-		{	switch (format [0])
-			{	case ' ' :
-				case '+' :
-					sign_char = format [0] ;
-					format ++ ;
-					continue ;
-
-				case '-' :
-					left_align = SF_TRUE ;
-					format ++ ;
-					continue ;
-
-				default : break ;
-				} ;
-
-			break ;
-			} ;
-
-		if (format [0] == 0)
-			break ;
-
-		lead_char = ' ' ;
-		if (format [0] == '0')
-			lead_char = '0' ;
-
-		width_specifier = 0 ;
-		while ((c = *format++) && isdigit (c))
-			width_specifier = width_specifier * 10 + (c - '0') ;
-
-		switch (c)
-		{	case 0 : /* NULL character. */
-					va_end (ap) ;
-					return ;
-
-			case 's': /* string */
-					strptr = va_arg (ap, char *) ;
-					if (strptr == NULL)
-						break ;
-					width_specifier -= strlen (strptr) ;
-					if (left_align == SF_FALSE)
-						while (width_specifier -- > 0)
-							log_putchar (psf, ' ') ;
-					while (*strptr)
-						log_putchar (psf, *strptr++) ;
-					while (width_specifier -- > 0)
-						log_putchar (psf, ' ') ;
-					break ;
-
-			case 'd': /* int */
-					d = va_arg (ap, int) ;
-
-					if (d < 0)
-					{	d = -d ;
-						sign_char = '-' ;
-						if (lead_char != '0' && left_align == SF_FALSE)
-							width_specifier -- ;
-						} ;
-
-					tens = 1 ;
-					width = 1 ;
-					while (d / tens >= 10)
-					{	tens *= 10 ;
-						width ++ ;
-						} ;
-
-					width_specifier -= width ;
-
-					if (sign_char == ' ')
-					{	log_putchar (psf, ' ') ;
-						width_specifier -- ;
-						} ;
-
-					if (left_align == SF_FALSE && lead_char != '0')
-					{	if (sign_char == '+')
-							width_specifier -- ;
-
-						while (width_specifier -- > 0)
-							log_putchar (psf, lead_char) ;
-						} ;
-
-					if (sign_char == '+' || sign_char == '-')
-					{	log_putchar (psf, sign_char) ;
-						width_specifier -- ;
-						} ;
-
-					if (left_align == SF_FALSE)
-						while (width_specifier -- > 0)
-							log_putchar (psf, lead_char) ;
-
-					while (tens > 0)
-					{	log_putchar (psf, '0' + d / tens) ;
-						d %= tens ;
-						tens /= 10 ;
-						} ;
-
-					while (width_specifier -- > 0)
-						log_putchar (psf, lead_char) ;
-					break ;
-
-			case 'D': /* sf_count_t */
-					{	sf_count_t		D, Tens ;
-
-						D = va_arg (ap, sf_count_t) ;
-
-						if (D == 0)
-						{	while (-- width_specifier > 0)
-								log_putchar (psf, lead_char) ;
-							log_putchar (psf, '0') ;
-							break ;
-							}
-						if (D < 0)
-						{	log_putchar (psf, '-') ;
-							D = -D ;
-							} ;
-						Tens = 1 ;
-						width = 1 ;
-						while (D / Tens >= 10)
-						{	Tens *= 10 ;
-							width ++ ;
-							} ;
-
-						while (width_specifier > width)
-						{	log_putchar (psf, lead_char) ;
-							width_specifier-- ;
-							} ;
-
-						while (Tens > 0)
-						{	log_putchar (psf, '0' + D / Tens) ;
-							D %= Tens ;
-							Tens /= 10 ;
-							} ;
-						} ;
-					break ;
-
-			case 'u': /* unsigned int */
-					u = va_arg (ap, unsigned int) ;
-
-					tens = 1 ;
-					width = 1 ;
-					while (u / tens >= 10)
-					{	tens *= 10 ;
-						width ++ ;
-						} ;
-
-					width_specifier -= width ;
-
-					if (sign_char == ' ')
-					{	log_putchar (psf, ' ') ;
-						width_specifier -- ;
-						} ;
-
-					if (left_align == SF_FALSE && lead_char != '0')
-					{	if (sign_char == '+')
-							width_specifier -- ;
-
-						while (width_specifier -- > 0)
-							log_putchar (psf, lead_char) ;
-						} ;
-
-					if (sign_char == '+' || sign_char == '-')
-					{	log_putchar (psf, sign_char) ;
-						width_specifier -- ;
-						} ;
-
-					if (left_align == SF_FALSE)
-						while (width_specifier -- > 0)
-							log_putchar (psf, lead_char) ;
-
-					while (tens > 0)
-					{	log_putchar (psf, '0' + u / tens) ;
-						u %= tens ;
-						tens /= 10 ;
-						} ;
-
-					while (width_specifier -- > 0)
-						log_putchar (psf, lead_char) ;
-					break ;
-
-			case 'c': /* char */
-					c = va_arg (ap, int) & 0xFF ;
-					log_putchar (psf, c) ;
-					break ;
-
-			case 'x': /* hex */
-			case 'X': /* hex */
-					d = va_arg (ap, int) ;
-
-					if (d == 0)
-					{	while (--width_specifier > 0)
-							log_putchar (psf, lead_char) ;
-						log_putchar (psf, '0') ;
-						break ;
-						} ;
-					shift = 28 ;
-					width = (width_specifier < 8) ? 8 : width_specifier ;
-					while (! ((0xF << shift) & d))
-					{	shift -= 4 ;
-						width -- ;
-						} ;
-
-					while (width > 0 && width_specifier > width)
-					{	log_putchar (psf, lead_char) ;
-						width_specifier-- ;
-						} ;
-
-					while (shift >= 0)
-					{	c = (d >> shift) & 0xF ;
-						log_putchar (psf, (c > 9) ? c + 'A' - 10 : c + '0') ;
-						shift -= 4 ;
-						} ;
-					break ;
-
-			case 'M': /* int2str */
-					d = va_arg (ap, int) ;
-					if (CPU_IS_LITTLE_ENDIAN)
-					{	istr [0] = d & 0xFF ;
-						istr [1] = (d >> 8) & 0xFF ;
-						istr [2] = (d >> 16) & 0xFF ;
-						istr [3] = (d >> 24) & 0xFF ;
-						}
-					else
-					{	istr [3] = d & 0xFF ;
-						istr [2] = (d >> 8) & 0xFF ;
-						istr [1] = (d >> 16) & 0xFF ;
-						istr [0] = (d >> 24) & 0xFF ;
-						} ;
-					istr [4] = 0 ;
-					strptr = istr ;
-					while (*strptr)
-					{	c = *strptr++ ;
-						log_putchar (psf, c) ;
-						} ;
-					break ;
-
-			default :
-					log_putchar (psf, '*') ;
-					log_putchar (psf, c) ;
-					log_putchar (psf, '*') ;
-					break ;
-			} /* switch */
-		} /* while */
-
-	va_end (ap) ;
-	return ;
-} /* psf_log_printf */
-
-/*-----------------------------------------------------------------------------------------------
-**  ASCII header printf functions.
-**  Some formats (ie NIST) use ascii text in their headers.
-**  Format specifiers are the same as the standard printf specifiers (uses vsnprintf).
-**  If this generates a compile error on any system, the author should be notified
-**  so an alternative vsnprintf can be provided.
-*/
-
-void
-psf_asciiheader_printf (SF_PRIVATE *psf, const char *format, ...)
-{	va_list	argptr ;
-	int		maxlen ;
-	char	*start ;
-
-	maxlen = strlen ((char*) psf->header) ;
-	start	= ((char*) psf->header) + maxlen ;
-	maxlen	= sizeof (psf->header) - maxlen ;
-
-	va_start (argptr, format) ;
-	vsnprintf (start, maxlen, format, argptr) ;
-	va_end (argptr) ;
-
-	/* Make sure the string is properly terminated. */
-	start [maxlen - 1] = 0 ;
-
-	psf->headindex = strlen ((char*) psf->header) ;
-
-	return ;
-} /* psf_asciiheader_printf */
-
-/*-----------------------------------------------------------------------------------------------
-**  Binary header writing functions. Returns number of bytes written.
-**
-**  Format specifiers for psf_binheader_writef are as follows
-**		m	- marker - four bytes - no endian manipulation
-**
-**		e   - all following numerical values will be little endian
-**		E   - all following numerical values will be big endian
-**
-**		t   - all following O types will be truncated to 4 bytes
-**		T   - switch off truncation of all following O types
-**
-**		1	- single byte value
-**		2	- two byte value
-**		3	- three byte value
-**		4	- four byte value
-**		8	- eight byte value (sometimes written as 4 bytes)
-**
-**		s   - string preceded by a four byte length
-**		S   - string including null terminator
-**		f	- floating point data
-**		d	- double precision floating point data
-**		h	- 16 binary bytes value
-**
-**		b	- binary data (see below)
-**		z   - zero bytes (ses below)
-**		j	- jump forwards or backwards
-**
-**	To write a word followed by an int (both little endian) use:
-**		psf_binheader_writef ("e24", wordval, longval) ;
-**
-**	To write binary data use:
-**		psf_binheader_writef ("b", &bindata, sizeof (bindata)) ;
-**
-**	To write N zero bytes use:
-**			NOTE: due to platform issues (ie x86-64) you should cast the
-**			argument to size_t or ensure the variable type is size_t.
-**		psf_binheader_writef ("z", N) ;
-*/
-
-/* These macros may seem a bit messy but do prevent problems with processors which
-** seg. fault when asked to write an int or short to a non-int/short aligned address.
-*/
-
-static inline void
-header_put_byte (SF_PRIVATE *psf, char x)
-{	if (psf->headindex < SIGNED_SIZEOF (psf->header) - 1)
-		psf->header [psf->headindex++] = x ;
-} /* header_put_byte */
-
-#if (CPU_IS_BIG_ENDIAN == 1)
-static inline void
-header_put_marker (SF_PRIVATE *psf, int x)
-{	if (psf->headindex < SIGNED_SIZEOF (psf->header) - 4)
-	{	psf->header [psf->headindex++] = (x >> 24) ;
-		psf->header [psf->headindex++] = (x >> 16) ;
-		psf->header [psf->headindex++] = (x >> 8) ;
-		psf->header [psf->headindex++] = x ;
-		} ;
-} /* header_put_marker */
-
-#elif (CPU_IS_LITTLE_ENDIAN == 1)
-static inline void
-header_put_marker (SF_PRIVATE *psf, int x)
-{	if (psf->headindex < SIGNED_SIZEOF (psf->header) - 4)
-	{	psf->header [psf->headindex++] = x ;
-		psf->header [psf->headindex++] = (x >> 8) ;
-		psf->header [psf->headindex++] = (x >> 16) ;
-		psf->header [psf->headindex++] = (x >> 24) ;
-		} ;
-} /* header_put_marker */
-
-#else
-#	error "Cannot determine endian-ness of processor."
-#endif
-
-
-static inline void
-header_put_be_short (SF_PRIVATE *psf, int x)
-{	if (psf->headindex < SIGNED_SIZEOF (psf->header) - 2)
-	{	psf->header [psf->headindex++] = (x >> 8) ;
-		psf->header [psf->headindex++] = x ;
-		} ;
-} /* header_put_be_short */
-
-static inline void
-header_put_le_short (SF_PRIVATE *psf, int x)
-{	if (psf->headindex < SIGNED_SIZEOF (psf->header) - 2)
-	{	psf->header [psf->headindex++] = x ;
-		psf->header [psf->headindex++] = (x >> 8) ;
-		} ;
-} /* header_put_le_short */
-
-static inline void
-header_put_be_3byte (SF_PRIVATE *psf, int x)
-{	if (psf->headindex < SIGNED_SIZEOF (psf->header) - 3)
-	{	psf->header [psf->headindex++] = (x >> 16) ;
-		psf->header [psf->headindex++] = (x >> 8) ;
-		psf->header [psf->headindex++] = x ;
-		} ;
-} /* header_put_be_3byte */
-
-static inline void
-header_put_le_3byte (SF_PRIVATE *psf, int x)
-{	if (psf->headindex < SIGNED_SIZEOF (psf->header) - 3)
-	{	psf->header [psf->headindex++] = x ;
-		psf->header [psf->headindex++] = (x >> 8) ;
-		psf->header [psf->headindex++] = (x >> 16) ;
-		} ;
-} /* header_put_le_3byte */
-
-static inline void
-header_put_be_int (SF_PRIVATE *psf, int x)
-{	if (psf->headindex < SIGNED_SIZEOF (psf->header) - 4)
-	{	psf->header [psf->headindex++] = (x >> 24) ;
-		psf->header [psf->headindex++] = (x >> 16) ;
-		psf->header [psf->headindex++] = (x >> 8) ;
-		psf->header [psf->headindex++] = x ;
-		} ;
-} /* header_put_be_int */
-
-static inline void
-header_put_le_int (SF_PRIVATE *psf, int x)
-{	if (psf->headindex < SIGNED_SIZEOF (psf->header) - 4)
-	{	psf->header [psf->headindex++] = x ;
-		psf->header [psf->headindex++] = (x >> 8) ;
-		psf->header [psf->headindex++] = (x >> 16) ;
-		psf->header [psf->headindex++] = (x >> 24) ;
-		} ;
-} /* header_put_le_int */
-
-#if (SIZEOF_SF_COUNT_T == 4)
-
-static inline void
-header_put_be_8byte (SF_PRIVATE *psf, sf_count_t x)
-{	if (psf->headindex < SIGNED_SIZEOF (psf->header) - 8)
-	{	psf->header [psf->headindex++] = 0 ;
-		psf->header [psf->headindex++] = 0 ;
-		psf->header [psf->headindex++] = 0 ;
-		psf->header [psf->headindex++] = 0 ;
-		psf->header [psf->headindex++] = (x >> 24) ;
-		psf->header [psf->headindex++] = (x >> 16) ;
-		psf->header [psf->headindex++] = (x >> 8) ;
-		psf->header [psf->headindex++] = x ;
-		} ;
-} /* header_put_be_8byte */
-
-static inline void
-header_put_le_8byte (SF_PRIVATE *psf, sf_count_t x)
-{	if (psf->headindex < SIGNED_SIZEOF (psf->header) - 8)
-	{	psf->header [psf->headindex++] = x ;
-		psf->header [psf->headindex++] = (x >> 8) ;
-		psf->header [psf->headindex++] = (x >> 16) ;
-		psf->header [psf->headindex++] = (x >> 24) ;
-		psf->header [psf->headindex++] = 0 ;
-		psf->header [psf->headindex++] = 0 ;
-		psf->header [psf->headindex++] = 0 ;
-		psf->header [psf->headindex++] = 0 ;
-		} ;
-} /* header_put_le_8byte */
-
-#elif (SIZEOF_SF_COUNT_T == 8)
-
-static inline void
-header_put_be_8byte (SF_PRIVATE *psf, sf_count_t x)
-{	if (psf->headindex < SIGNED_SIZEOF (psf->header) - 8)
-	{	psf->header [psf->headindex++] = (x >> 56) ;
-		psf->header [psf->headindex++] = (x >> 48) ;
-		psf->header [psf->headindex++] = (x >> 40) ;
-		psf->header [psf->headindex++] = (x >> 32) ;
-		psf->header [psf->headindex++] = (x >> 24) ;
-		psf->header [psf->headindex++] = (x >> 16) ;
-		psf->header [psf->headindex++] = (x >> 8) ;
-		psf->header [psf->headindex++] = x ;
-		} ;
-} /* header_put_be_8byte */
-
-static inline void
-header_put_le_8byte (SF_PRIVATE *psf, sf_count_t x)
-{	if (psf->headindex < SIGNED_SIZEOF (psf->header) - 8)
-	{	psf->header [psf->headindex++] = x ;
-		psf->header [psf->headindex++] = (x >> 8) ;
-		psf->header [psf->headindex++] = (x >> 16) ;
-		psf->header [psf->headindex++] = (x >> 24) ;
-		psf->header [psf->headindex++] = (x >> 32) ;
-		psf->header [psf->headindex++] = (x >> 40) ;
-		psf->header [psf->headindex++] = (x >> 48) ;
-		psf->header [psf->headindex++] = (x >> 56) ;
-		} ;
-} /* header_put_le_8byte */
-
-#else
-#error "SIZEOF_SF_COUNT_T is not defined."
-#endif
-
-int
-psf_binheader_writef (SF_PRIVATE *psf, const char *format, ...)
-{	va_list	argptr ;
-	sf_count_t 		countdata ;
-	unsigned long 	longdata ;
-	unsigned int 	data ;
-	float			floatdata ;
-	double			doubledata ;
-	void			*bindata ;
-	size_t			size ;
-	char			c, *strptr ;
-	int				count = 0, trunc_8to4 ;
-
-	trunc_8to4 = SF_FALSE ;
-
-	va_start (argptr, format) ;
-
-	while ((c = *format++))
-	{	switch (c)
-		{	case ' ' : /* Do nothing. Just used to space out format string. */
-					break ;
-
-			case 'e' : /* All conversions are now from LE to host. */
-					psf->rwf_endian = SF_ENDIAN_LITTLE ;
-					break ;
-
-			case 'E' : /* All conversions are now from BE to host. */
-					psf->rwf_endian = SF_ENDIAN_BIG ;
-					break ;
-
-			case 't' : /* All 8 byte values now get written as 4 bytes. */
-					trunc_8to4 = SF_TRUE ;
-					break ;
-
-			case 'T' : /* All 8 byte values now get written as 8 bytes. */
-					trunc_8to4 = SF_FALSE ;
-					break ;
-
-			case 'm' :
-					data = va_arg (argptr, unsigned int) ;
-					header_put_marker (psf, data) ;
-					count += 4 ;
-					break ;
-
-			case '1' :
-					data = va_arg (argptr, unsigned int) ;
-					header_put_byte (psf, data) ;
-					count += 1 ;
-					break ;
-
-			case '2' :
-					data = va_arg (argptr, unsigned int) ;
-					if (psf->rwf_endian == SF_ENDIAN_BIG)
-					{	header_put_be_short (psf, data) ;
-						}
-					else
-					{	header_put_le_short (psf, data) ;
-						} ;
-					count += 2 ;
-					break ;
-
-			case '3' : /* tribyte */
-					data = va_arg (argptr, unsigned int) ;
-					if (psf->rwf_endian == SF_ENDIAN_BIG)
-					{	header_put_be_3byte (psf, data) ;
-						}
-					else
-					{	header_put_le_3byte (psf, data) ;
-						} ;
-					count += 3 ;
-					break ;
-
-			case '4' :
-					data = va_arg (argptr, unsigned int) ;
-					if (psf->rwf_endian == SF_ENDIAN_BIG)
-					{	header_put_be_int (psf, data) ;
-						}
-					else
-					{	header_put_le_int (psf, data) ;
-						} ;
-					count += 4 ;
-					break ;
-
-			case '8' :
-					countdata = va_arg (argptr, sf_count_t) ;
-					if (psf->rwf_endian == SF_ENDIAN_BIG && trunc_8to4 == SF_FALSE)
-					{	header_put_be_8byte (psf, countdata) ;
-						count += 8 ;
-						}
-					else if (psf->rwf_endian == SF_ENDIAN_LITTLE && trunc_8to4 == SF_FALSE)
-					{	header_put_le_8byte (psf, countdata) ;
-						count += 8 ;
-						}
-					else if (psf->rwf_endian == SF_ENDIAN_BIG && trunc_8to4 == SF_TRUE)
-					{	longdata = countdata & 0xFFFFFFFF ;
-						header_put_be_int (psf, longdata) ;
-						count += 4 ;
-						}
-					else if (psf->rwf_endian == SF_ENDIAN_LITTLE && trunc_8to4 == SF_TRUE)
-					{	longdata = countdata & 0xFFFFFFFF ;
-						header_put_le_int (psf, longdata) ;
-						count += 4 ;
-						}
-					break ;
-
-			case 'f' :
-					/* Floats are passed as doubles. Is this always true? */
-					floatdata = (float) va_arg (argptr, double) ;
-					if (psf->rwf_endian == SF_ENDIAN_BIG)
-						float32_be_write (floatdata, psf->header + psf->headindex) ;
-					else
-						float32_le_write (floatdata, psf->header + psf->headindex) ;
-					psf->headindex += 4 ;
-					count += 4 ;
-					break ;
-
-			case 'd' :
-					doubledata = va_arg (argptr, double) ;
-					if (psf->rwf_endian == SF_ENDIAN_BIG)
-						double64_be_write (doubledata, psf->header + psf->headindex) ;
-					else
-						double64_le_write (doubledata, psf->header + psf->headindex) ;
-					psf->headindex += 8 ;
-					count += 8 ;
-					break ;
-
-			case 's' :
-					/* Write a C string (guaranteed to have a zero terminator). */
-					strptr = va_arg (argptr, char *) ;
-					size = strlen (strptr) + 1 ;
-					size += (size & 1) ;
-					if (psf->rwf_endian == SF_ENDIAN_BIG)
-						header_put_be_int (psf, size) ;
-					else
-						header_put_le_int (psf, size) ;
-					memcpy (&(psf->header [psf->headindex]), strptr, size) ;
-					psf->headindex += size ;
-					psf->header [psf->headindex - 1] = 0 ;
-					count += 4 + size ;
-					break ;
-
-			case 'S' :
-					/*
-					**	Write an AIFF style string (no zero terminator but possibly
-					**	an extra pad byte if the string length is odd).
-					*/
-					strptr = va_arg (argptr, char *) ;
-					size = strlen (strptr) ;
-					if (psf->rwf_endian == SF_ENDIAN_BIG)
-						header_put_be_int (psf, size) ;
-					else
-						header_put_le_int (psf, size) ;
-					memcpy (&(psf->header [psf->headindex]), strptr, size + 1) ;
-					size += (size & 1) ;
-					psf->headindex += size ;
-					psf->header [psf->headindex] = 0 ;
-					count += 4 + size ;
-					break ;
-
-			case 'b' :
-					bindata	= va_arg (argptr, void *) ;
-					size	= va_arg (argptr, size_t) ;
-					memcpy (&(psf->header [psf->headindex]), bindata, size) ;
-					psf->headindex += size ;
-					count += size ;
-					break ;
-
-			case 'z' :
-					size = va_arg (argptr, size_t) ;
-					count += size ;
-					while (size)
-					{	psf->header [psf->headindex] = 0 ;
-						psf->headindex ++ ;
-						size -- ;
-						} ;
-					break ;
-
-			case 'h' :
-					bindata = va_arg (argptr, void *) ;
-					memcpy (&(psf->header [psf->headindex]), bindata, 16) ;
-					psf->headindex += 16 ;
-					count += 16 ;
-					break ;
-
-			case 'j' :
-					size = va_arg (argptr, size_t) ;
-					psf->headindex += size ;
-					count = size ;
-					break ;
-
-			default :
-				psf_log_printf (psf, "*** Invalid format specifier `%c'\n", c) ;
-				psf->error = SFE_INTERNAL ;
-				break ;
-			} ;
-		} ;
-
-	va_end (argptr) ;
-	return count ;
-} /* psf_binheader_writef */
-
-/*-----------------------------------------------------------------------------------------------
-**  Binary header reading functions. Returns number of bytes read.
-**
-**	Format specifiers are the same as for header write function above with the following
-**	additions:
-**
-**		p   - jump a given number of position from start of file.
-**
-**	If format is NULL, psf_binheader_readf returns the current offset.
-*/
-
-#if (CPU_IS_BIG_ENDIAN == 1)
-#define	GET_MARKER(ptr)	(	((ptr) [0] << 24)	| ((ptr) [1] << 16) |	\
-							((ptr) [2] << 8)	| ((ptr) [3]) )
-
-#elif (CPU_IS_LITTLE_ENDIAN == 1)
-#define	GET_MARKER(ptr)	(	((ptr) [0])			| ((ptr) [1] << 8) |	\
-							((ptr) [2] << 16)	| ((ptr) [3] << 24) )
-
-#else
-#	error "Cannot determine endian-ness of processor."
-#endif
-
-#define	GET_LE_SHORT(ptr)	( ((ptr) [1] << 8) | ((ptr) [0]) )
-#define	GET_BE_SHORT(ptr)	( ((ptr) [0] << 8) | ((ptr) [1]) )
-
-#define	GET_LE_3BYTE(ptr)	( 	((ptr) [2] << 16) | ((ptr) [1] << 8) | ((ptr) [0]) )
-#define	GET_BE_3BYTE(ptr)	( 	((ptr) [0] << 16) | ((ptr) [1] << 8) | ((ptr) [2]) )
-
-#define	GET_LE_INT(ptr)		( 	((ptr) [3] << 24)	| ((ptr) [2] << 16) |	\
-								((ptr) [1] << 8)	| ((ptr) [0]) )
-
-#define	GET_BE_INT(ptr)		( 	((ptr) [0] << 24)	| ((ptr) [1] << 16) |	\
-							 	((ptr) [2] << 8)	| ((ptr) [3]) )
-
-#define	GET_LE_8BYTE(ptr)	( 	(((sf_count_t) (ptr) [7]) << 56) | (((sf_count_t) (ptr) [6]) << 48) |	\
-							 	(((sf_count_t) (ptr) [5]) << 40) | (((sf_count_t) (ptr) [4]) << 32) |	\
-							 	(((sf_count_t) (ptr) [3]) << 24) | (((sf_count_t) (ptr) [2]) << 16) |	\
-							 	(((sf_count_t) (ptr) [1]) << 8 ) | ((ptr) [0]))
-
-#define	GET_BE_8BYTE(ptr)	( 	(((sf_count_t) (ptr) [0]) << 56) | (((sf_count_t) (ptr) [1]) << 48) |	\
-							 	(((sf_count_t) (ptr) [2]) << 40) | (((sf_count_t) (ptr) [3]) << 32) |	\
-							 	(((sf_count_t) (ptr) [4]) << 24) | (((sf_count_t) (ptr) [5]) << 16) |	\
-							 	(((sf_count_t) (ptr) [6]) << 8 ) | ((ptr) [7]))
-
-
-
-static int
-header_read (SF_PRIVATE *psf, void *ptr, int bytes)
-{	int count = 0 ;
-
-	if (psf->headindex >= SIGNED_SIZEOF (psf->header))
-	{	memset (ptr, 0, SIGNED_SIZEOF (psf->header) - psf->headindex) ;
-
-		/* This is the best that we can do. */
-		psf_fseek (psf, bytes, SEEK_CUR) ;
-		return bytes ;
-		} ;
-
-	if (psf->headindex + bytes > SIGNED_SIZEOF (psf->header))
-	{	int most ;
-
-		most = SIGNED_SIZEOF (psf->header) - psf->headindex ;
-		psf_fread (psf->header + psf->headend, 1, most, psf) ;
-		memset ((char *) ptr + most, 0, bytes - most) ;
-
-		psf_fseek (psf, bytes - most, SEEK_CUR) ;
-		return bytes ;
-		} ;
-
-	if (psf->headindex + bytes > psf->headend)
-	{	count = psf_fread (psf->header + psf->headend, 1, bytes - (psf->headend - psf->headindex), psf) ;
-		if (count != bytes - (int) (psf->headend - psf->headindex))
-		{	psf_log_printf (psf, "Error : psf_fread returned short count.\n") ;
-			return 0 ;
-			} ;
-		psf->headend += count ;
-		} ;
-
-	memcpy (ptr, psf->header + psf->headindex, bytes) ;
-	psf->headindex += bytes ;
-
-	return bytes ;
-} /* header_read */
-
-static void
-header_seek (SF_PRIVATE *psf, sf_count_t position, int whence)
-{
-
-	switch (whence)
-	{	case SEEK_SET :
-			if (position > SIGNED_SIZEOF (psf->header))
-			{	/* Too much header to cache so just seek instead. */
-				psf_fseek (psf, position, whence) ;
-				return ;
-				} ;
-			if (position > psf->headend)
-				psf->headend += psf_fread (psf->header + psf->headend, 1, position - psf->headend, psf) ;
-			psf->headindex = position ;
-			break ;
-
-		case SEEK_CUR :
-			if (psf->headindex + position < 0)
-				break ;
-
-			if (psf->headindex >= SIGNED_SIZEOF (psf->header))
-			{	psf_fseek (psf, position, whence) ;
-				return ;
-				} ;
-
-			if (psf->headindex + position <= psf->headend)
-			{	psf->headindex += position ;
-				break ;
-				} ;
-
-			if (psf->headindex + position > SIGNED_SIZEOF (psf->header))
-			{	/* Need to jump this without caching it. */
-				psf->headindex = psf->headend ;
-				psf_fseek (psf, position, SEEK_CUR) ;
-				break ;
-				} ;
-
-			psf->headend += psf_fread (psf->header + psf->headend, 1, position - (psf->headend - psf->headindex), psf) ;
-			psf->headindex = psf->headend ;
-			break ;
-
-		case SEEK_END :
-		default :
-			psf_log_printf (psf, "Bad whence param in header_seek().\n") ;
-			break ;
-		} ;
-
-	return ;
-} /* header_seek */
-
-static int
-header_gets (SF_PRIVATE *psf, char *ptr, int bufsize)
-{
-	int		k ;
-
-	for (k = 0 ; k < bufsize - 1 ; k++)
-	{	if (psf->headindex < psf->headend)
-		{	ptr [k] = psf->header [psf->headindex] ;
-			psf->headindex ++ ;
-			}
-		else
-		{	psf->headend += psf_fread (psf->header + psf->headend, 1, 1, psf) ;
-			ptr [k] = psf->header [psf->headindex] ;
-			psf->headindex = psf->headend ;
-			} ;
-
-		if (ptr [k] == '\n')
-			break ;
-		} ;
-
-	ptr [k] = 0 ;
-
-	return k ;
-} /* header_gets */
-
-int
-psf_binheader_readf (SF_PRIVATE *psf, char const *format, ...)
-{	va_list			argptr ;
-	sf_count_t		*countptr, countdata ;
-	unsigned char	*ucptr, sixteen_bytes [16] ;
-	unsigned int 	*intptr, intdata ;
-	unsigned short	*shortptr ;
-	char			*charptr ;
-	float			*floatptr ;
-	double			*doubleptr ;
-	char			c ;
-	int				byte_count = 0, count ;
-
-	if (! format)
-		return psf_ftell (psf) ;
-
-	va_start (argptr, format) ;
-
-	while ((c = *format++))
-	{	switch (c)
-		{	case 'e' : /* All conversions are now from LE to host. */
-					psf->rwf_endian = SF_ENDIAN_LITTLE ;
-					break ;
-
-			case 'E' : /* All conversions are now from BE to host. */
-					psf->rwf_endian = SF_ENDIAN_BIG ;
-					break ;
-
-			case 'm' :
-					intptr = va_arg (argptr, unsigned int*) ;
-					ucptr = (unsigned char*) intptr ;
-					byte_count += header_read (psf, ucptr, sizeof (int)) ;
-					*intptr = GET_MARKER (ucptr) ;
-					break ;
-
-			case 'h' :
-					intptr = va_arg (argptr, unsigned int*) ;
-					ucptr = (unsigned char*) intptr ;
-					byte_count += header_read (psf, sixteen_bytes, sizeof (sixteen_bytes)) ;
-					{	int k ;
-						intdata = 0 ;
-						for (k = 0 ; k < 16 ; k++)
-							intdata ^= sixteen_bytes [k] << k ;
-						}
-					*intptr = intdata ;
-					break ;
-
-			case '1' :
-					charptr = va_arg (argptr, char*) ;
-					*charptr = 0 ;
-					byte_count += header_read (psf, charptr, sizeof (char)) ;
-					break ;
-
-			case '2' :
-					shortptr = va_arg (argptr, unsigned short*) ;
-					*shortptr = 0 ;
-					ucptr = (unsigned char*) shortptr ;
-					byte_count += header_read (psf, ucptr, sizeof (short)) ;
-					if (psf->rwf_endian == SF_ENDIAN_BIG)
-						*shortptr = GET_BE_SHORT (ucptr) ;
-					else
-						*shortptr = GET_LE_SHORT (ucptr) ;
-					break ;
-
-			case '3' :
-					intptr = va_arg (argptr, unsigned int*) ;
-					*intptr = 0 ;
-					byte_count += header_read (psf, sixteen_bytes, 3) ;
-					if (psf->rwf_endian == SF_ENDIAN_BIG)
-						*intptr = GET_BE_3BYTE (sixteen_bytes) ;
-					else
-						*intptr = GET_LE_3BYTE (sixteen_bytes) ;
-					break ;
-
-			case '4' :
-					intptr = va_arg (argptr, unsigned int*) ;
-					*intptr = 0 ;
-					ucptr = (unsigned char*) intptr ;
-					byte_count += header_read (psf, ucptr, sizeof (int)) ;
-					if (psf->rwf_endian == SF_ENDIAN_BIG)
-						*intptr = GET_BE_INT (ucptr) ;
-					else
-						*intptr = GET_LE_INT (ucptr) ;
-					break ;
-
-			case '8' :
-					countptr = va_arg (argptr, sf_count_t *) ;
-					*countptr = 0 ;
-					byte_count += header_read (psf, sixteen_bytes, 8) ;
-					if (psf->rwf_endian == SF_ENDIAN_BIG)
-						countdata = GET_BE_8BYTE (sixteen_bytes) ;
-					else
-						countdata = GET_LE_8BYTE (sixteen_bytes) ;
-					*countptr = countdata ;
-					break ;
-
-			case 'f' : /* Float conversion */
-					floatptr = va_arg (argptr, float *) ;
-					*floatptr = 0.0 ;
-					byte_count += header_read (psf, floatptr, sizeof (float)) ;
-					if (psf->rwf_endian == SF_ENDIAN_BIG)
-						*floatptr = float32_be_read ((unsigned char*) floatptr) ;
-					else
-						*floatptr = float32_le_read ((unsigned char*) floatptr) ;
-					break ;
-
-			case 'd' : /* double conversion */
-					doubleptr = va_arg (argptr, double *) ;
-					*doubleptr = 0.0 ;
-					byte_count += header_read (psf, doubleptr, sizeof (double)) ;
-					if (psf->rwf_endian == SF_ENDIAN_BIG)
-						*doubleptr = double64_be_read ((unsigned char*) doubleptr) ;
-					else
-						*doubleptr = double64_le_read ((unsigned char*) doubleptr) ;
-					break ;
-
-			case 's' :
-					psf_log_printf (psf, "Format conversion 's' not implemented yet.\n") ;
-					/*
-					strptr = va_arg (argptr, char *) ;
-					size   = strlen (strptr) + 1 ;
-					size  += (size & 1) ;
-					longdata = H2LE_INT (size) ;
-					get_int (psf, longdata) ;
-					memcpy (&(psf->header [psf->headindex]), strptr, size) ;
-					psf->headindex += size ;
-					*/
-					break ;
-
-			case 'b' :
-					charptr = va_arg (argptr, char*) ;
-					count = va_arg (argptr, int) ;
-					if (count > 0)
-						byte_count += header_read (psf, charptr, count) ;
-					break ;
-
-			case 'G' :
-					charptr = va_arg (argptr, char*) ;
-					count = va_arg (argptr, int) ;
-					if (count > 0)
-						byte_count += header_gets (psf, charptr, count) ;
-					break ;
-
-			case 'z' :
-					psf_log_printf (psf, "Format conversion 'z' not implemented yet.\n") ;
-					/*
-					size    = va_arg (argptr, size_t) ;
-					while (size)
-					{	psf->header [psf->headindex] = 0 ;
-						psf->headindex ++ ;
-						size -- ;
-						} ;
-					*/
-					break ;
-
-			case 'p' :
-					/* Get the seek position first. */
-					count = va_arg (argptr, int) ;
-					header_seek (psf, count, SEEK_SET) ;
-					byte_count = count ;
-					break ;
-
-			case 'j' :
-					/* Get the seek position first. */
-					count = va_arg (argptr, int) ;
-					header_seek (psf, count, SEEK_CUR) ;
-					byte_count += count ;
-					break ;
-
-			default :
-				psf_log_printf (psf, "*** Invalid format specifier `%c'\n", c) ;
-				psf->error = SFE_INTERNAL ;
-				break ;
-			} ;
-		} ;
-
-	va_end (argptr) ;
-
-	return byte_count ;
-} /* psf_binheader_readf */
-
-/*-----------------------------------------------------------------------------------------------
-*/
-
-sf_count_t
-psf_default_seek (SF_PRIVATE *psf, int UNUSED (mode), sf_count_t samples_from_start)
-{	sf_count_t position, retval ;
-
-	if (! (psf->blockwidth && psf->dataoffset >= 0))
-	{	psf->error = SFE_BAD_SEEK ;
-		return	PSF_SEEK_ERROR ;
-		} ;
-
-	if (! psf->sf.seekable)
-	{	psf->error = SFE_NOT_SEEKABLE ;
-		return	PSF_SEEK_ERROR ;
-		} ;
-
-	position = psf->dataoffset + psf->blockwidth * samples_from_start ;
-
-	if ((retval = psf_fseek (psf, position, SEEK_SET)) != position)
-	{	psf->error = SFE_SEEK_FAILED ;
-		return PSF_SEEK_ERROR ;
-		} ;
-
-	return samples_from_start ;
-} /* psf_default_seek */
-
-/*-----------------------------------------------------------------------------------------------
-*/
-
-void
-psf_hexdump (const void *ptr, int len)
-{	const char *data ;
-	char	ascii [17] ;
-	int		k, m ;
-
-	if ((data = ptr) == NULL)
-		return ;
-	if (len <= 0)
-		return ;
-
-	puts ("") ;
-	for (k = 0 ; k < len ; k += 16)
-	{	memset (ascii, ' ', sizeof (ascii)) ;
-
-		printf ("%08X: ", k) ;
-		for (m = 0 ; m < 16 && k + m < len ; m++)
-		{	printf (m == 8 ? " %02X " : "%02X ", data [k + m] & 0xFF) ;
-			ascii [m] = psf_isprint (data [k + m]) ? data [k + m] : '.' ;
-			} ;
-
-		if (m <= 8) printf (" ") ;
-		for ( ; m < 16 ; m++) printf ("   ") ;
-
-		ascii [16] = 0 ;
-		printf (" %s\n", ascii) ;
-		} ;
-
-	puts ("") ;
-} /* psf_hexdump */
-
-void
-psf_log_SF_INFO (SF_PRIVATE *psf)
-{	psf_log_printf (psf, "---------------------------------\n") ;
-
-	psf_log_printf (psf, " Sample rate :   %d\n", psf->sf.samplerate) ;
-	psf_log_printf (psf, " Frames      :   %D\n", psf->sf.frames) ;
-	psf_log_printf (psf, " Channels    :   %d\n", psf->sf.channels) ;
-
-	psf_log_printf (psf, " Format      :   0x%X\n", psf->sf.format) ;
-	psf_log_printf (psf, " Sections    :   %d\n", psf->sf.sections) ;
-	psf_log_printf (psf, " Seekable    :   %s\n", psf->sf.seekable ? "TRUE" : "FALSE") ;
-
-	psf_log_printf (psf, "---------------------------------\n") ;
-} /* psf_dump_SFINFO */
-
-/*========================================================================================
-*/
-
-void*
-psf_memset (void *s, int c, sf_count_t len)
-{	char	*ptr ;
-	int 	setcount ;
-
-	ptr = (char *) s ;
-
-	while (len > 0)
-	{	setcount = (len > 0x10000000) ? 0x10000000 : (int) len ;
-
-		memset (ptr, c, setcount) ;
-
-		ptr += setcount ;
-		len -= setcount ;
-		} ;
-
-	return s ;
-} /* psf_memset */
-
-SF_INSTRUMENT *
-psf_instrument_alloc (void)
-{	SF_INSTRUMENT *instr ;
-
-	instr = calloc (1, sizeof (SF_INSTRUMENT)) ;
-
-	if (instr == NULL)
-		return NULL ;
-
-	/* Set non-zero default values. */
-	instr->basenote = -1 ;
-	instr->velocity_lo = -1 ;
-	instr->velocity_hi = -1 ;
-	instr->key_lo = -1 ;
-	instr->key_hi = -1 ;
-
-	return instr ;
-} /* psf_instrument_alloc */
-
-void
-psf_sanitize_string (char * cptr, int len)
-{
-	do
-	{
-		len -- ;
-		cptr [len] = psf_isprint (cptr [len]) ? cptr [len] : '.' ;
-	}
-	while (len > 0) ;
-} /* psf_sanitize_string */
-
-void
-psf_get_date_str (char *str, int maxlen)
-{	time_t		current ;
-	struct tm	timedata, *tmptr ;
-
-	time (&current) ;
-
-#if defined (HAVE_GMTIME_R)
-	/* If the re-entrant version is available, use it. */
-	tmptr = gmtime_r (&current, &timedata) ;
-#elif defined (HAVE_GMTIME)
-	/* Otherwise use the standard one and copy the data to local storage. */
-	tmptr = gmtime (&current) ;
-	memcpy (&timedata, tmptr, sizeof (timedata)) ;
-#else
-	tmptr = NULL ;
-#endif
-
-	if (tmptr)
-		snprintf (str, maxlen, "%4d-%02d-%02d %02d:%02d:%02d UTC",
-			1900 + timedata.tm_year, timedata.tm_mon, timedata.tm_mday,
-			timedata.tm_hour, timedata.tm_min, timedata.tm_sec) ;
-	else
-		snprintf (str, maxlen, "Unknown date") ;
-
-	return ;
-} /* psf_get_date_str */
-
-int
-subformat_to_bytewidth (int format)
-{
-	switch (format)
-	{	case SF_FORMAT_PCM_U8 :
-		case SF_FORMAT_PCM_S8 :
-				return 1 ;
-		case SF_FORMAT_PCM_16 :
-				return 2 ;
-		case SF_FORMAT_PCM_24 :
-				return 3 ;
-		case SF_FORMAT_PCM_32 :
-		case SF_FORMAT_FLOAT :
-				return 4 ;
-		case SF_FORMAT_DOUBLE :
-				return 8 ;
-		} ;
-
-	return 0 ;
-} /* subformat_to_bytewidth */
-
-int
-s_bitwidth_to_subformat (int bits)
-{	static int array [] =
-	{	SF_FORMAT_PCM_S8, SF_FORMAT_PCM_16, SF_FORMAT_PCM_24, SF_FORMAT_PCM_32
-		} ;
-
-	if (bits < 8 || bits > 32)
-		return 0 ;
-
-	return array [((bits + 7) / 8) - 1] ;
-} /* bitwidth_to_subformat */
-
-int
-u_bitwidth_to_subformat (int bits)
-{	static int array [] =
-	{	SF_FORMAT_PCM_U8, SF_FORMAT_PCM_16, SF_FORMAT_PCM_24, SF_FORMAT_PCM_32
-		} ;
-
-	if (bits < 8 || bits > 32)
-		return 0 ;
-
-	return array [((bits + 7) / 8) - 1] ;
-} /* bitwidth_to_subformat */
-
-/*
-**	psf_rand_int32 : Not crypto quality, but more than adequate for things
-**	like stream serial numbers in Ogg files or the unique_id field of the
-**	SF_PRIVATE struct.
-*/
-
-int32_t
-psf_rand_int32 (void)
-{	static int32_t value = -1 ;
-	int k, count ;
-
-	if (value == -1)
-	{
-#if HAVE_GETTIMEOFDAY
-		struct timeval tv ;
-		gettimeofday (&tv, NULL) ;
-		value = tv.tv_sec + tv.tv_usec ;
-#else
-		value = time (NULL) ;
-#endif
-		} ;
-
-	count = 4 + (value & 7) ;
-	for (k = 0 ; k < count ; k++)
-		value = 11117 * value + 211231 ;
-
-	return value ;
-} /* psf_rand_int32 */
-
-void
-append_snprintf (char * dest, size_t maxlen, const char * fmt, ...)
-{	size_t len = strlen (dest) ;
-
-	if (len < maxlen)
-	{	va_list ap ;
-
-		va_start (ap, fmt) ;
-		vsnprintf (dest + len, maxlen - len, fmt, ap) ;
-		va_end (ap) ;
-		} ;
-
-	return ;
-} /* append_snprintf */
-
-/*==============================================================================
-*/
-
-#define CASE_NAME(x)		case x : return #x ; break ;
-
-const char *
-str_of_major_format (int format)
-{	switch (SF_CONTAINER (format))
-	{	CASE_NAME (SF_FORMAT_WAV) ;
-		CASE_NAME (SF_FORMAT_AIFF) ;
-		CASE_NAME (SF_FORMAT_AU) ;
-		CASE_NAME (SF_FORMAT_RAW) ;
-		CASE_NAME (SF_FORMAT_PAF) ;
-		CASE_NAME (SF_FORMAT_SVX) ;
-		CASE_NAME (SF_FORMAT_NIST) ;
-		CASE_NAME (SF_FORMAT_VOC) ;
-		CASE_NAME (SF_FORMAT_IRCAM) ;
-		CASE_NAME (SF_FORMAT_W64) ;
-		CASE_NAME (SF_FORMAT_MAT4) ;
-		CASE_NAME (SF_FORMAT_MAT5) ;
-		CASE_NAME (SF_FORMAT_PVF) ;
-		CASE_NAME (SF_FORMAT_XI) ;
-		CASE_NAME (SF_FORMAT_HTK) ;
-		CASE_NAME (SF_FORMAT_SDS) ;
-		CASE_NAME (SF_FORMAT_AVR) ;
-		CASE_NAME (SF_FORMAT_WAVEX) ;
-		CASE_NAME (SF_FORMAT_SD2) ;
-		CASE_NAME (SF_FORMAT_FLAC) ;
-		CASE_NAME (SF_FORMAT_CAF) ;
-		CASE_NAME (SF_FORMAT_WVE) ;
-		CASE_NAME (SF_FORMAT_OGG) ;
-		default :
-			break ;
-		} ;
-
-	return "BAD_MAJOR_FORMAT" ;
-} /* str_of_major_format */
-
-const char *
-str_of_minor_format (int format)
-{	switch (SF_CODEC (format))
-	{	CASE_NAME (SF_FORMAT_PCM_S8) ;
-		CASE_NAME (SF_FORMAT_PCM_16) ;
-		CASE_NAME (SF_FORMAT_PCM_24) ;
-		CASE_NAME (SF_FORMAT_PCM_32) ;
-		CASE_NAME (SF_FORMAT_PCM_U8) ;
-		CASE_NAME (SF_FORMAT_FLOAT) ;
-		CASE_NAME (SF_FORMAT_DOUBLE) ;
-		CASE_NAME (SF_FORMAT_ULAW) ;
-		CASE_NAME (SF_FORMAT_ALAW) ;
-		CASE_NAME (SF_FORMAT_IMA_ADPCM) ;
-		CASE_NAME (SF_FORMAT_MS_ADPCM) ;
-		CASE_NAME (SF_FORMAT_GSM610) ;
-		CASE_NAME (SF_FORMAT_VOX_ADPCM) ;
-		CASE_NAME (SF_FORMAT_G721_32) ;
-		CASE_NAME (SF_FORMAT_G723_24) ;
-		CASE_NAME (SF_FORMAT_G723_40) ;
-		CASE_NAME (SF_FORMAT_DWVW_12) ;
-		CASE_NAME (SF_FORMAT_DWVW_16) ;
-		CASE_NAME (SF_FORMAT_DWVW_24) ;
-		CASE_NAME (SF_FORMAT_DWVW_N) ;
-		CASE_NAME (SF_FORMAT_DPCM_8) ;
-		CASE_NAME (SF_FORMAT_DPCM_16) ;
-		CASE_NAME (SF_FORMAT_VORBIS) ;
-		default :
-			break ;
-		} ;
-
-	return "BAD_MINOR_FORMAT" ;
-} /* str_of_minor_format */
-
-const char *
-str_of_open_mode (int mode)
-{	switch (mode)
-	{	CASE_NAME (SFM_READ) ;
-		CASE_NAME (SFM_WRITE) ;
-		CASE_NAME (SFM_RDWR) ;
-
-		default :
-			break ;
-		} ;
-
-	return "BAD_MODE" ;
-} /* str_of_open_mode */
-
-const char *
-str_of_endianness (int end)
-{	switch (end)
-	{	CASE_NAME (SF_ENDIAN_BIG) ;
-		CASE_NAME (SF_ENDIAN_LITTLE) ;
-		CASE_NAME (SF_ENDIAN_CPU) ;
-		default :
-			break ;
-		} ;
-
-	/* Zero length string for SF_ENDIAN_FILE. */
-	return "" ;
-} /* str_of_endianness */
+/*
+** Copyright (C) 1999-2009 Erik de Castro Lopo <erikd@mega-nerd.com>
+**
+** This program is free software; you can redistribute it and/or modify
+** it under the terms of the GNU Lesser General Public License as published by
+** the Free Software Foundation; either version 2.1 of the License, or
+** (at your option) any later version.
+**
+** This program is distributed in the hope that it will be useful,
+** but WITHOUT ANY WARRANTY; without even the implied warranty of
+** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+** GNU Lesser General Public License for more details.
+**
+** You should have received a copy of the GNU Lesser General Public License
+** along with this program; if not, write to the Free Software
+** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*/
+
+#include	<config.h>
+
+#include	<stdarg.h>
+#include	<string.h>
+#include	<ctype.h>
+#include	<math.h>
+#include	<time.h>
+//#include	<sys/time.h>
+
+#include	"sndfile.h"
+#include	"sfendian.h"
+#include	"common.h"
+
+/*-----------------------------------------------------------------------------------------------
+** psf_log_printf allows libsndfile internal functions to print to an internal logbuffer which
+** can later be displayed.
+** The format specifiers are as for printf but without the field width and other modifiers.
+** Printing is performed to the logbuffer char array of the SF_PRIVATE struct.
+** Printing is done in such a way as to guarantee that the log never overflows the end of the
+** logbuffer array.
+*/
+
+static inline void
+log_putchar (SF_PRIVATE *psf, char ch)
+{	if (psf->logindex < SIGNED_SIZEOF (psf->logbuffer) - 1)
+	{	psf->logbuffer [psf->logindex++] = ch ;
+		psf->logbuffer [psf->logindex] = 0 ;
+		} ;
+	return ;
+} /* log_putchar */
+
+void
+psf_log_printf (SF_PRIVATE *psf, const char *format, ...)
+{	va_list			ap ;
+	unsigned int	u ;
+	int				d, tens, shift, width, width_specifier, left_align ;
+	char			c, *strptr, istr [5], lead_char, sign_char ;
+
+	va_start (ap, format) ;
+
+	while ((c = *format++))
+	{	if (c != '%')
+		{	log_putchar (psf, c) ;
+			continue ;
+			} ;
+
+		if (format [0] == '%') /* Handle %% */
+		{ 	log_putchar (psf, '%') ;
+			format ++ ;
+			continue ;
+			} ;
+
+		sign_char = 0 ;
+		left_align = SF_FALSE ;
+		while (1)
+		{	switch (format [0])
+			{	case ' ' :
+				case '+' :
+					sign_char = format [0] ;
+					format ++ ;
+					continue ;
+
+				case '-' :
+					left_align = SF_TRUE ;
+					format ++ ;
+					continue ;
+
+				default : break ;
+				} ;
+
+			break ;
+			} ;
+
+		if (format [0] == 0)
+			break ;
+
+		lead_char = ' ' ;
+		if (format [0] == '0')
+			lead_char = '0' ;
+
+		width_specifier = 0 ;
+		while ((c = *format++) && isdigit (c))
+			width_specifier = width_specifier * 10 + (c - '0') ;
+
+		switch (c)
+		{	case 0 : /* NULL character. */
+					va_end (ap) ;
+					return ;
+
+			case 's': /* string */
+					strptr = va_arg (ap, char *) ;
+					if (strptr == NULL)
+						break ;
+					width_specifier -= strlen (strptr) ;
+					if (left_align == SF_FALSE)
+						while (width_specifier -- > 0)
+							log_putchar (psf, ' ') ;
+					while (*strptr)
+						log_putchar (psf, *strptr++) ;
+					while (width_specifier -- > 0)
+						log_putchar (psf, ' ') ;
+					break ;
+
+			case 'd': /* int */
+					d = va_arg (ap, int) ;
+
+					if (d < 0)
+					{	d = -d ;
+						sign_char = '-' ;
+						if (lead_char != '0' && left_align == SF_FALSE)
+							width_specifier -- ;
+						} ;
+
+					tens = 1 ;
+					width = 1 ;
+					while (d / tens >= 10)
+					{	tens *= 10 ;
+						width ++ ;
+						} ;
+
+					width_specifier -= width ;
+
+					if (sign_char == ' ')
+					{	log_putchar (psf, ' ') ;
+						width_specifier -- ;
+						} ;
+
+					if (left_align == SF_FALSE && lead_char != '0')
+					{	if (sign_char == '+')
+							width_specifier -- ;
+
+						while (width_specifier -- > 0)
+							log_putchar (psf, lead_char) ;
+						} ;
+
+					if (sign_char == '+' || sign_char == '-')
+					{	log_putchar (psf, sign_char) ;
+						width_specifier -- ;
+						} ;
+
+					if (left_align == SF_FALSE)
+						while (width_specifier -- > 0)
+							log_putchar (psf, lead_char) ;
+
+					while (tens > 0)
+					{	log_putchar (psf, '0' + d / tens) ;
+						d %= tens ;
+						tens /= 10 ;
+						} ;
+
+					while (width_specifier -- > 0)
+						log_putchar (psf, lead_char) ;
+					break ;
+
+			case 'D': /* sf_count_t */
+					{	sf_count_t		D, Tens ;
+
+						D = va_arg (ap, sf_count_t) ;
+
+						if (D == 0)
+						{	while (-- width_specifier > 0)
+								log_putchar (psf, lead_char) ;
+							log_putchar (psf, '0') ;
+							break ;
+							}
+						if (D < 0)
+						{	log_putchar (psf, '-') ;
+							D = -D ;
+							} ;
+						Tens = 1 ;
+						width = 1 ;
+						while (D / Tens >= 10)
+						{	Tens *= 10 ;
+							width ++ ;
+							} ;
+
+						while (width_specifier > width)
+						{	log_putchar (psf, lead_char) ;
+							width_specifier-- ;
+							} ;
+
+						while (Tens > 0)
+						{	log_putchar (psf, '0' + D / Tens) ;
+							D %= Tens ;
+							Tens /= 10 ;
+							} ;
+						} ;
+					break ;
+
+			case 'u': /* unsigned int */
+					u = va_arg (ap, unsigned int) ;
+
+					tens = 1 ;
+					width = 1 ;
+					while (u / tens >= 10)
+					{	tens *= 10 ;
+						width ++ ;
+						} ;
+
+					width_specifier -= width ;
+
+					if (sign_char == ' ')
+					{	log_putchar (psf, ' ') ;
+						width_specifier -- ;
+						} ;
+
+					if (left_align == SF_FALSE && lead_char != '0')
+					{	if (sign_char == '+')
+							width_specifier -- ;
+
+						while (width_specifier -- > 0)
+							log_putchar (psf, lead_char) ;
+						} ;
+
+					if (sign_char == '+' || sign_char == '-')
+					{	log_putchar (psf, sign_char) ;
+						width_specifier -- ;
+						} ;
+
+					if (left_align == SF_FALSE)
+						while (width_specifier -- > 0)
+							log_putchar (psf, lead_char) ;
+
+					while (tens > 0)
+					{	log_putchar (psf, '0' + u / tens) ;
+						u %= tens ;
+						tens /= 10 ;
+						} ;
+
+					while (width_specifier -- > 0)
+						log_putchar (psf, lead_char) ;
+					break ;
+
+			case 'c': /* char */
+					c = va_arg (ap, int) & 0xFF ;
+					log_putchar (psf, c) ;
+					break ;
+
+			case 'x': /* hex */
+			case 'X': /* hex */
+					d = va_arg (ap, int) ;
+
+					if (d == 0)
+					{	while (--width_specifier > 0)
+							log_putchar (psf, lead_char) ;
+						log_putchar (psf, '0') ;
+						break ;
+						} ;
+					shift = 28 ;
+					width = (width_specifier < 8) ? 8 : width_specifier ;
+					while (! ((0xF << shift) & d))
+					{	shift -= 4 ;
+						width -- ;
+						} ;
+
+					while (width > 0 && width_specifier > width)
+					{	log_putchar (psf, lead_char) ;
+						width_specifier-- ;
+						} ;
+
+					while (shift >= 0)
+					{	c = (d >> shift) & 0xF ;
+						log_putchar (psf, (c > 9) ? c + 'A' - 10 : c + '0') ;
+						shift -= 4 ;
+						} ;
+					break ;
+
+			case 'M': /* int2str */
+					d = va_arg (ap, int) ;
+					if (CPU_IS_LITTLE_ENDIAN)
+					{	istr [0] = d & 0xFF ;
+						istr [1] = (d >> 8) & 0xFF ;
+						istr [2] = (d >> 16) & 0xFF ;
+						istr [3] = (d >> 24) & 0xFF ;
+						}
+					else
+					{	istr [3] = d & 0xFF ;
+						istr [2] = (d >> 8) & 0xFF ;
+						istr [1] = (d >> 16) & 0xFF ;
+						istr [0] = (d >> 24) & 0xFF ;
+						} ;
+					istr [4] = 0 ;
+					strptr = istr ;
+					while (*strptr)
+					{	c = *strptr++ ;
+						log_putchar (psf, c) ;
+						} ;
+					break ;
+
+			default :
+					log_putchar (psf, '*') ;
+					log_putchar (psf, c) ;
+					log_putchar (psf, '*') ;
+					break ;
+			} /* switch */
+		} /* while */
+
+	va_end (ap) ;
+	return ;
+} /* psf_log_printf */
+
+/*-----------------------------------------------------------------------------------------------
+**  ASCII header printf functions.
+**  Some formats (ie NIST) use ascii text in their headers.
+**  Format specifiers are the same as the standard printf specifiers (uses vsnprintf).
+**  If this generates a compile error on any system, the author should be notified
+**  so an alternative vsnprintf can be provided.
+*/
+
+void
+psf_asciiheader_printf (SF_PRIVATE *psf, const char *format, ...)
+{	va_list	argptr ;
+	int		maxlen ;
+	char	*start ;
+
+	maxlen = strlen ((char*) psf->header) ;
+	start	= ((char*) psf->header) + maxlen ;
+	maxlen	= sizeof (psf->header) - maxlen ;
+
+	va_start (argptr, format) ;
+	vsnprintf (start, maxlen, format, argptr) ;
+	va_end (argptr) ;
+
+	/* Make sure the string is properly terminated. */
+	start [maxlen - 1] = 0 ;
+
+	psf->headindex = strlen ((char*) psf->header) ;
+
+	return ;
+} /* psf_asciiheader_printf */
+
+/*-----------------------------------------------------------------------------------------------
+**  Binary header writing functions. Returns number of bytes written.
+**
+**  Format specifiers for psf_binheader_writef are as follows
+**		m	- marker - four bytes - no endian manipulation
+**
+**		e   - all following numerical values will be little endian
+**		E   - all following numerical values will be big endian
+**
+**		t   - all following O types will be truncated to 4 bytes
+**		T   - switch off truncation of all following O types
+**
+**		1	- single byte value
+**		2	- two byte value
+**		3	- three byte value
+**		4	- four byte value
+**		8	- eight byte value (sometimes written as 4 bytes)
+**
+**		s   - string preceded by a four byte length
+**		S   - string including null terminator
+**		f	- floating point data
+**		d	- double precision floating point data
+**		h	- 16 binary bytes value
+**
+**		b	- binary data (see below)
+**		z   - zero bytes (ses below)
+**		j	- jump forwards or backwards
+**
+**	To write a word followed by an int (both little endian) use:
+**		psf_binheader_writef ("e24", wordval, longval) ;
+**
+**	To write binary data use:
+**		psf_binheader_writef ("b", &bindata, sizeof (bindata)) ;
+**
+**	To write N zero bytes use:
+**			NOTE: due to platform issues (ie x86-64) you should cast the
+**			argument to size_t or ensure the variable type is size_t.
+**		psf_binheader_writef ("z", N) ;
+*/
+
+/* These macros may seem a bit messy but do prevent problems with processors which
+** seg. fault when asked to write an int or short to a non-int/short aligned address.
+*/
+
+static inline void
+header_put_byte (SF_PRIVATE *psf, char x)
+{	if (psf->headindex < SIGNED_SIZEOF (psf->header) - 1)
+		psf->header [psf->headindex++] = x ;
+} /* header_put_byte */
+
+#if (CPU_IS_BIG_ENDIAN == 1)
+static inline void
+header_put_marker (SF_PRIVATE *psf, int x)
+{	if (psf->headindex < SIGNED_SIZEOF (psf->header) - 4)
+	{	psf->header [psf->headindex++] = (x >> 24) ;
+		psf->header [psf->headindex++] = (x >> 16) ;
+		psf->header [psf->headindex++] = (x >> 8) ;
+		psf->header [psf->headindex++] = x ;
+		} ;
+} /* header_put_marker */
+
+#elif (CPU_IS_LITTLE_ENDIAN == 1)
+static inline void
+header_put_marker (SF_PRIVATE *psf, int x)
+{	if (psf->headindex < SIGNED_SIZEOF (psf->header) - 4)
+	{	psf->header [psf->headindex++] = x ;
+		psf->header [psf->headindex++] = (x >> 8) ;
+		psf->header [psf->headindex++] = (x >> 16) ;
+		psf->header [psf->headindex++] = (x >> 24) ;
+		} ;
+} /* header_put_marker */
+
+#else
+#	error "Cannot determine endian-ness of processor."
+#endif
+
+
+static inline void
+header_put_be_short (SF_PRIVATE *psf, int x)
+{	if (psf->headindex < SIGNED_SIZEOF (psf->header) - 2)
+	{	psf->header [psf->headindex++] = (x >> 8) ;
+		psf->header [psf->headindex++] = x ;
+		} ;
+} /* header_put_be_short */
+
+static inline void
+header_put_le_short (SF_PRIVATE *psf, int x)
+{	if (psf->headindex < SIGNED_SIZEOF (psf->header) - 2)
+	{	psf->header [psf->headindex++] = x ;
+		psf->header [psf->headindex++] = (x >> 8) ;
+		} ;
+} /* header_put_le_short */
+
+static inline void
+header_put_be_3byte (SF_PRIVATE *psf, int x)
+{	if (psf->headindex < SIGNED_SIZEOF (psf->header) - 3)
+	{	psf->header [psf->headindex++] = (x >> 16) ;
+		psf->header [psf->headindex++] = (x >> 8) ;
+		psf->header [psf->headindex++] = x ;
+		} ;
+} /* header_put_be_3byte */
+
+static inline void
+header_put_le_3byte (SF_PRIVATE *psf, int x)
+{	if (psf->headindex < SIGNED_SIZEOF (psf->header) - 3)
+	{	psf->header [psf->headindex++] = x ;
+		psf->header [psf->headindex++] = (x >> 8) ;
+		psf->header [psf->headindex++] = (x >> 16) ;
+		} ;
+} /* header_put_le_3byte */
+
+static inline void
+header_put_be_int (SF_PRIVATE *psf, int x)
+{	if (psf->headindex < SIGNED_SIZEOF (psf->header) - 4)
+	{	psf->header [psf->headindex++] = (x >> 24) ;
+		psf->header [psf->headindex++] = (x >> 16) ;
+		psf->header [psf->headindex++] = (x >> 8) ;
+		psf->header [psf->headindex++] = x ;
+		} ;
+} /* header_put_be_int */
+
+static inline void
+header_put_le_int (SF_PRIVATE *psf, int x)
+{	if (psf->headindex < SIGNED_SIZEOF (psf->header) - 4)
+	{	psf->header [psf->headindex++] = x ;
+		psf->header [psf->headindex++] = (x >> 8) ;
+		psf->header [psf->headindex++] = (x >> 16) ;
+		psf->header [psf->headindex++] = (x >> 24) ;
+		} ;
+} /* header_put_le_int */
+
+#if (SIZEOF_SF_COUNT_T == 4)
+
+static inline void
+header_put_be_8byte (SF_PRIVATE *psf, sf_count_t x)
+{	if (psf->headindex < SIGNED_SIZEOF (psf->header) - 8)
+	{	psf->header [psf->headindex++] = 0 ;
+		psf->header [psf->headindex++] = 0 ;
+		psf->header [psf->headindex++] = 0 ;
+		psf->header [psf->headindex++] = 0 ;
+		psf->header [psf->headindex++] = (x >> 24) ;
+		psf->header [psf->headindex++] = (x >> 16) ;
+		psf->header [psf->headindex++] = (x >> 8) ;
+		psf->header [psf->headindex++] = x ;
+		} ;
+} /* header_put_be_8byte */
+
+static inline void
+header_put_le_8byte (SF_PRIVATE *psf, sf_count_t x)
+{	if (psf->headindex < SIGNED_SIZEOF (psf->header) - 8)
+	{	psf->header [psf->headindex++] = x ;
+		psf->header [psf->headindex++] = (x >> 8) ;
+		psf->header [psf->headindex++] = (x >> 16) ;
+		psf->header [psf->headindex++] = (x >> 24) ;
+		psf->header [psf->headindex++] = 0 ;
+		psf->header [psf->headindex++] = 0 ;
+		psf->header [psf->headindex++] = 0 ;
+		psf->header [psf->headindex++] = 0 ;
+		} ;
+} /* header_put_le_8byte */
+
+#elif (SIZEOF_SF_COUNT_T == 8)
+
+static inline void
+header_put_be_8byte (SF_PRIVATE *psf, sf_count_t x)
+{	if (psf->headindex < SIGNED_SIZEOF (psf->header) - 8)
+	{	psf->header [psf->headindex++] = (x >> 56) ;
+		psf->header [psf->headindex++] = (x >> 48) ;
+		psf->header [psf->headindex++] = (x >> 40) ;
+		psf->header [psf->headindex++] = (x >> 32) ;
+		psf->header [psf->headindex++] = (x >> 24) ;
+		psf->header [psf->headindex++] = (x >> 16) ;
+		psf->header [psf->headindex++] = (x >> 8) ;
+		psf->header [psf->headindex++] = x ;
+		} ;
+} /* header_put_be_8byte */
+
+static inline void
+header_put_le_8byte (SF_PRIVATE *psf, sf_count_t x)
+{	if (psf->headindex < SIGNED_SIZEOF (psf->header) - 8)
+	{	psf->header [psf->headindex++] = x ;
+		psf->header [psf->headindex++] = (x >> 8) ;
+		psf->header [psf->headindex++] = (x >> 16) ;
+		psf->header [psf->headindex++] = (x >> 24) ;
+		psf->header [psf->headindex++] = (x >> 32) ;
+		psf->header [psf->headindex++] = (x >> 40) ;
+		psf->header [psf->headindex++] = (x >> 48) ;
+		psf->header [psf->headindex++] = (x >> 56) ;
+		} ;
+} /* header_put_le_8byte */
+
+#else
+#error "SIZEOF_SF_COUNT_T is not defined."
+#endif
+
+int
+psf_binheader_writef (SF_PRIVATE *psf, const char *format, ...)
+{	va_list	argptr ;
+	sf_count_t 		countdata ;
+	unsigned long 	longdata ;
+	unsigned int 	data ;
+	float			floatdata ;
+	double			doubledata ;
+	void			*bindata ;
+	size_t			size ;
+	char			c, *strptr ;
+	int				count = 0, trunc_8to4 ;
+
+	trunc_8to4 = SF_FALSE ;
+
+	va_start (argptr, format) ;
+
+	while ((c = *format++))
+	{	switch (c)
+		{	case ' ' : /* Do nothing. Just used to space out format string. */
+					break ;
+
+			case 'e' : /* All conversions are now from LE to host. */
+					psf->rwf_endian = SF_ENDIAN_LITTLE ;
+					break ;
+
+			case 'E' : /* All conversions are now from BE to host. */
+					psf->rwf_endian = SF_ENDIAN_BIG ;
+					break ;
+
+			case 't' : /* All 8 byte values now get written as 4 bytes. */
+					trunc_8to4 = SF_TRUE ;
+					break ;
+
+			case 'T' : /* All 8 byte values now get written as 8 bytes. */
+					trunc_8to4 = SF_FALSE ;
+					break ;
+
+			case 'm' :
+					data = va_arg (argptr, unsigned int) ;
+					header_put_marker (psf, data) ;
+					count += 4 ;
+					break ;
+
+			case '1' :
+					data = va_arg (argptr, unsigned int) ;
+					header_put_byte (psf, data) ;
+					count += 1 ;
+					break ;
+
+			case '2' :
+					data = va_arg (argptr, unsigned int) ;
+					if (psf->rwf_endian == SF_ENDIAN_BIG)
+					{	header_put_be_short (psf, data) ;
+						}
+					else
+					{	header_put_le_short (psf, data) ;
+						} ;
+					count += 2 ;
+					break ;
+
+			case '3' : /* tribyte */
+					data = va_arg (argptr, unsigned int) ;
+					if (psf->rwf_endian == SF_ENDIAN_BIG)
+					{	header_put_be_3byte (psf, data) ;
+						}
+					else
+					{	header_put_le_3byte (psf, data) ;
+						} ;
+					count += 3 ;
+					break ;
+
+			case '4' :
+					data = va_arg (argptr, unsigned int) ;
+					if (psf->rwf_endian == SF_ENDIAN_BIG)
+					{	header_put_be_int (psf, data) ;
+						}
+					else
+					{	header_put_le_int (psf, data) ;
+						} ;
+					count += 4 ;
+					break ;
+
+			case '8' :
+					countdata = va_arg (argptr, sf_count_t) ;
+					if (psf->rwf_endian == SF_ENDIAN_BIG && trunc_8to4 == SF_FALSE)
+					{	header_put_be_8byte (psf, countdata) ;
+						count += 8 ;
+						}
+					else if (psf->rwf_endian == SF_ENDIAN_LITTLE && trunc_8to4 == SF_FALSE)
+					{	header_put_le_8byte (psf, countdata) ;
+						count += 8 ;
+						}
+					else if (psf->rwf_endian == SF_ENDIAN_BIG && trunc_8to4 == SF_TRUE)
+					{	longdata = countdata & 0xFFFFFFFF ;
+						header_put_be_int (psf, longdata) ;
+						count += 4 ;
+						}
+					else if (psf->rwf_endian == SF_ENDIAN_LITTLE && trunc_8to4 == SF_TRUE)
+					{	longdata = countdata & 0xFFFFFFFF ;
+						header_put_le_int (psf, longdata) ;
+						count += 4 ;
+						}
+					break ;
+
+			case 'f' :
+					/* Floats are passed as doubles. Is this always true? */
+					floatdata = (float) va_arg (argptr, double) ;
+					if (psf->rwf_endian == SF_ENDIAN_BIG)
+						float32_be_write (floatdata, psf->header + psf->headindex) ;
+					else
+						float32_le_write (floatdata, psf->header + psf->headindex) ;
+					psf->headindex += 4 ;
+					count += 4 ;
+					break ;
+
+			case 'd' :
+					doubledata = va_arg (argptr, double) ;
+					if (psf->rwf_endian == SF_ENDIAN_BIG)
+						double64_be_write (doubledata, psf->header + psf->headindex) ;
+					else
+						double64_le_write (doubledata, psf->header + psf->headindex) ;
+					psf->headindex += 8 ;
+					count += 8 ;
+					break ;
+
+			case 's' :
+					/* Write a C string (guaranteed to have a zero terminator). */
+					strptr = va_arg (argptr, char *) ;
+					size = strlen (strptr) + 1 ;
+					size += (size & 1) ;
+					if (psf->rwf_endian == SF_ENDIAN_BIG)
+						header_put_be_int (psf, size) ;
+					else
+						header_put_le_int (psf, size) ;
+					memcpy (&(psf->header [psf->headindex]), strptr, size) ;
+					psf->headindex += size ;
+					psf->header [psf->headindex - 1] = 0 ;
+					count += 4 + size ;
+					break ;
+
+			case 'S' :
+					/*
+					**	Write an AIFF style string (no zero terminator but possibly
+					**	an extra pad byte if the string length is odd).
+					*/
+					strptr = va_arg (argptr, char *) ;
+					size = strlen (strptr) ;
+					if (psf->rwf_endian == SF_ENDIAN_BIG)
+						header_put_be_int (psf, size) ;
+					else
+						header_put_le_int (psf, size) ;
+					memcpy (&(psf->header [psf->headindex]), strptr, size + 1) ;
+					size += (size & 1) ;
+					psf->headindex += size ;
+					psf->header [psf->headindex] = 0 ;
+					count += 4 + size ;
+					break ;
+
+			case 'b' :
+					bindata	= va_arg (argptr, void *) ;
+					size	= va_arg (argptr, size_t) ;
+					memcpy (&(psf->header [psf->headindex]), bindata, size) ;
+					psf->headindex += size ;
+					count += size ;
+					break ;
+
+			case 'z' :
+					size = va_arg (argptr, size_t) ;
+					count += size ;
+					while (size)
+					{	psf->header [psf->headindex] = 0 ;
+						psf->headindex ++ ;
+						size -- ;
+						} ;
+					break ;
+
+			case 'h' :
+					bindata = va_arg (argptr, void *) ;
+					memcpy (&(psf->header [psf->headindex]), bindata, 16) ;
+					psf->headindex += 16 ;
+					count += 16 ;
+					break ;
+
+			case 'j' :
+					size = va_arg (argptr, size_t) ;
+					psf->headindex += size ;
+					count = size ;
+					break ;
+
+			default :
+				psf_log_printf (psf, "*** Invalid format specifier `%c'\n", c) ;
+				psf->error = SFE_INTERNAL ;
+				break ;
+			} ;
+		} ;
+
+	va_end (argptr) ;
+	return count ;
+} /* psf_binheader_writef */
+
+/*-----------------------------------------------------------------------------------------------
+**  Binary header reading functions. Returns number of bytes read.
+**
+**	Format specifiers are the same as for header write function above with the following
+**	additions:
+**
+**		p   - jump a given number of position from start of file.
+**
+**	If format is NULL, psf_binheader_readf returns the current offset.
+*/
+
+#if (CPU_IS_BIG_ENDIAN == 1)
+#define	GET_MARKER(ptr)	(	((ptr) [0] << 24)	| ((ptr) [1] << 16) |	\
+							((ptr) [2] << 8)	| ((ptr) [3]) )
+
+#elif (CPU_IS_LITTLE_ENDIAN == 1)
+#define	GET_MARKER(ptr)	(	((ptr) [0])			| ((ptr) [1] << 8) |	\
+							((ptr) [2] << 16)	| ((ptr) [3] << 24) )
+
+#else
+#	error "Cannot determine endian-ness of processor."
+#endif
+
+#define	GET_LE_SHORT(ptr)	( ((ptr) [1] << 8) | ((ptr) [0]) )
+#define	GET_BE_SHORT(ptr)	( ((ptr) [0] << 8) | ((ptr) [1]) )
+
+#define	GET_LE_3BYTE(ptr)	( 	((ptr) [2] << 16) | ((ptr) [1] << 8) | ((ptr) [0]) )
+#define	GET_BE_3BYTE(ptr)	( 	((ptr) [0] << 16) | ((ptr) [1] << 8) | ((ptr) [2]) )
+
+#define	GET_LE_INT(ptr)		( 	((ptr) [3] << 24)	| ((ptr) [2] << 16) |	\
+								((ptr) [1] << 8)	| ((ptr) [0]) )
+
+#define	GET_BE_INT(ptr)		( 	((ptr) [0] << 24)	| ((ptr) [1] << 16) |	\
+							 	((ptr) [2] << 8)	| ((ptr) [3]) )
+
+#define	GET_LE_8BYTE(ptr)	( 	(((sf_count_t) (ptr) [7]) << 56) | (((sf_count_t) (ptr) [6]) << 48) |	\
+							 	(((sf_count_t) (ptr) [5]) << 40) | (((sf_count_t) (ptr) [4]) << 32) |	\
+							 	(((sf_count_t) (ptr) [3]) << 24) | (((sf_count_t) (ptr) [2]) << 16) |	\
+							 	(((sf_count_t) (ptr) [1]) << 8 ) | ((ptr) [0]))
+
+#define	GET_BE_8BYTE(ptr)	( 	(((sf_count_t) (ptr) [0]) << 56) | (((sf_count_t) (ptr) [1]) << 48) |	\
+							 	(((sf_count_t) (ptr) [2]) << 40) | (((sf_count_t) (ptr) [3]) << 32) |	\
+							 	(((sf_count_t) (ptr) [4]) << 24) | (((sf_count_t) (ptr) [5]) << 16) |	\
+							 	(((sf_count_t) (ptr) [6]) << 8 ) | ((ptr) [7]))
+
+
+
+static int
+header_read (SF_PRIVATE *psf, void *ptr, int bytes)
+{	int count = 0 ;
+
+	if (psf->headindex >= SIGNED_SIZEOF (psf->header))
+	{	memset (ptr, 0, SIGNED_SIZEOF (psf->header) - psf->headindex) ;
+
+		/* This is the best that we can do. */
+		psf_fseek (psf, bytes, SEEK_CUR) ;
+		return bytes ;
+		} ;
+
+	if (psf->headindex + bytes > SIGNED_SIZEOF (psf->header))
+	{	int most ;
+
+		most = SIGNED_SIZEOF (psf->header) - psf->headindex ;
+		psf_fread (psf->header + psf->headend, 1, most, psf) ;
+		memset ((char *) ptr + most, 0, bytes - most) ;
+
+		psf_fseek (psf, bytes - most, SEEK_CUR) ;
+		return bytes ;
+		} ;
+
+	if (psf->headindex + bytes > psf->headend)
+	{	count = psf_fread (psf->header + psf->headend, 1, bytes - (psf->headend - psf->headindex), psf) ;
+		if (count != bytes - (int) (psf->headend - psf->headindex))
+		{	psf_log_printf (psf, "Error : psf_fread returned short count.\n") ;
+			return 0 ;
+			} ;
+		psf->headend += count ;
+		} ;
+
+	memcpy (ptr, psf->header + psf->headindex, bytes) ;
+	psf->headindex += bytes ;
+
+	return bytes ;
+} /* header_read */
+
+static void
+header_seek (SF_PRIVATE *psf, sf_count_t position, int whence)
+{
+
+	switch (whence)
+	{	case SEEK_SET :
+			if (position > SIGNED_SIZEOF (psf->header))
+			{	/* Too much header to cache so just seek instead. */
+				psf_fseek (psf, position, whence) ;
+				return ;
+				} ;
+			if (position > psf->headend)
+				psf->headend += psf_fread (psf->header + psf->headend, 1, position - psf->headend, psf) ;
+			psf->headindex = position ;
+			break ;
+
+		case SEEK_CUR :
+			if (psf->headindex + position < 0)
+				break ;
+
+			if (psf->headindex >= SIGNED_SIZEOF (psf->header))
+			{	psf_fseek (psf, position, whence) ;
+				return ;
+				} ;
+
+			if (psf->headindex + position <= psf->headend)
+			{	psf->headindex += position ;
+				break ;
+				} ;
+
+			if (psf->headindex + position > SIGNED_SIZEOF (psf->header))
+			{	/* Need to jump this without caching it. */
+				psf->headindex = psf->headend ;
+				psf_fseek (psf, position, SEEK_CUR) ;
+				break ;
+				} ;
+
+			psf->headend += psf_fread (psf->header + psf->headend, 1, position - (psf->headend - psf->headindex), psf) ;
+			psf->headindex = psf->headend ;
+			break ;
+
+		case SEEK_END :
+		default :
+			psf_log_printf (psf, "Bad whence param in header_seek().\n") ;
+			break ;
+		} ;
+
+	return ;
+} /* header_seek */
+
+static int
+header_gets (SF_PRIVATE *psf, char *ptr, int bufsize)
+{
+	int		k ;
+
+	for (k = 0 ; k < bufsize - 1 ; k++)
+	{	if (psf->headindex < psf->headend)
+		{	ptr [k] = psf->header [psf->headindex] ;
+			psf->headindex ++ ;
+			}
+		else
+		{	psf->headend += psf_fread (psf->header + psf->headend, 1, 1, psf) ;
+			ptr [k] = psf->header [psf->headindex] ;
+			psf->headindex = psf->headend ;
+			} ;
+
+		if (ptr [k] == '\n')
+			break ;
+		} ;
+
+	ptr [k] = 0 ;
+
+	return k ;
+} /* header_gets */
+
+int
+psf_binheader_readf (SF_PRIVATE *psf, char const *format, ...)
+{	va_list			argptr ;
+	sf_count_t		*countptr, countdata ;
+	unsigned char	*ucptr, sixteen_bytes [16] ;
+	unsigned int 	*intptr, intdata ;
+	unsigned short	*shortptr ;
+	char			*charptr ;
+	float			*floatptr ;
+	double			*doubleptr ;
+	char			c ;
+	int				byte_count = 0, count ;
+
+	if (! format)
+		return psf_ftell (psf) ;
+
+	va_start (argptr, format) ;
+
+	while ((c = *format++))
+	{	switch (c)
+		{	case 'e' : /* All conversions are now from LE to host. */
+					psf->rwf_endian = SF_ENDIAN_LITTLE ;
+					break ;
+
+			case 'E' : /* All conversions are now from BE to host. */
+					psf->rwf_endian = SF_ENDIAN_BIG ;
+					break ;
+
+			case 'm' :
+					intptr = va_arg (argptr, unsigned int*) ;
+					ucptr = (unsigned char*) intptr ;
+					byte_count += header_read (psf, ucptr, sizeof (int)) ;
+					*intptr = GET_MARKER (ucptr) ;
+					break ;
+
+			case 'h' :
+					intptr = va_arg (argptr, unsigned int*) ;
+					ucptr = (unsigned char*) intptr ;
+					byte_count += header_read (psf, sixteen_bytes, sizeof (sixteen_bytes)) ;
+					{	int k ;
+						intdata = 0 ;
+						for (k = 0 ; k < 16 ; k++)
+							intdata ^= sixteen_bytes [k] << k ;
+						}
+					*intptr = intdata ;
+					break ;
+
+			case '1' :
+					charptr = va_arg (argptr, char*) ;
+					*charptr = 0 ;
+					byte_count += header_read (psf, charptr, sizeof (char)) ;
+					break ;
+
+			case '2' :
+					shortptr = va_arg (argptr, unsigned short*) ;
+					*shortptr = 0 ;
+					ucptr = (unsigned char*) shortptr ;
+					byte_count += header_read (psf, ucptr, sizeof (short)) ;
+					if (psf->rwf_endian == SF_ENDIAN_BIG)
+						*shortptr = GET_BE_SHORT (ucptr) ;
+					else
+						*shortptr = GET_LE_SHORT (ucptr) ;
+					break ;
+
+			case '3' :
+					intptr = va_arg (argptr, unsigned int*) ;
+					*intptr = 0 ;
+					byte_count += header_read (psf, sixteen_bytes, 3) ;
+					if (psf->rwf_endian == SF_ENDIAN_BIG)
+						*intptr = GET_BE_3BYTE (sixteen_bytes) ;
+					else
+						*intptr = GET_LE_3BYTE (sixteen_bytes) ;
+					break ;
+
+			case '4' :
+					intptr = va_arg (argptr, unsigned int*) ;
+					*intptr = 0 ;
+					ucptr = (unsigned char*) intptr ;
+					byte_count += header_read (psf, ucptr, sizeof (int)) ;
+					if (psf->rwf_endian == SF_ENDIAN_BIG)
+						*intptr = GET_BE_INT (ucptr) ;
+					else
+						*intptr = GET_LE_INT (ucptr) ;
+					break ;
+
+			case '8' :
+					countptr = va_arg (argptr, sf_count_t *) ;
+					*countptr = 0 ;
+					byte_count += header_read (psf, sixteen_bytes, 8) ;
+					if (psf->rwf_endian == SF_ENDIAN_BIG)
+						countdata = GET_BE_8BYTE (sixteen_bytes) ;
+					else
+						countdata = GET_LE_8BYTE (sixteen_bytes) ;
+					*countptr = countdata ;
+					break ;
+
+			case 'f' : /* Float conversion */
+					floatptr = va_arg (argptr, float *) ;
+					*floatptr = 0.0 ;
+					byte_count += header_read (psf, floatptr, sizeof (float)) ;
+					if (psf->rwf_endian == SF_ENDIAN_BIG)
+						*floatptr = float32_be_read ((unsigned char*) floatptr) ;
+					else
+						*floatptr = float32_le_read ((unsigned char*) floatptr) ;
+					break ;
+
+			case 'd' : /* double conversion */
+					doubleptr = va_arg (argptr, double *) ;
+					*doubleptr = 0.0 ;
+					byte_count += header_read (psf, doubleptr, sizeof (double)) ;
+					if (psf->rwf_endian == SF_ENDIAN_BIG)
+						*doubleptr = double64_be_read ((unsigned char*) doubleptr) ;
+					else
+						*doubleptr = double64_le_read ((unsigned char*) doubleptr) ;
+					break ;
+
+			case 's' :
+					psf_log_printf (psf, "Format conversion 's' not implemented yet.\n") ;
+					/*
+					strptr = va_arg (argptr, char *) ;
+					size   = strlen (strptr) + 1 ;
+					size  += (size & 1) ;
+					longdata = H2LE_INT (size) ;
+					get_int (psf, longdata) ;
+					memcpy (&(psf->header [psf->headindex]), strptr, size) ;
+					psf->headindex += size ;
+					*/
+					break ;
+
+			case 'b' :
+					charptr = va_arg (argptr, char*) ;
+					count = va_arg (argptr, int) ;
+					if (count > 0)
+						byte_count += header_read (psf, charptr, count) ;
+					break ;
+
+			case 'G' :
+					charptr = va_arg (argptr, char*) ;
+					count = va_arg (argptr, int) ;
+					if (count > 0)
+						byte_count += header_gets (psf, charptr, count) ;
+					break ;
+
+			case 'z' :
+					psf_log_printf (psf, "Format conversion 'z' not implemented yet.\n") ;
+					/*
+					size    = va_arg (argptr, size_t) ;
+					while (size)
+					{	psf->header [psf->headindex] = 0 ;
+						psf->headindex ++ ;
+						size -- ;
+						} ;
+					*/
+					break ;
+
+			case 'p' :
+					/* Get the seek position first. */
+					count = va_arg (argptr, int) ;
+					header_seek (psf, count, SEEK_SET) ;
+					byte_count = count ;
+					break ;
+
+			case 'j' :
+					/* Get the seek position first. */
+					count = va_arg (argptr, int) ;
+					header_seek (psf, count, SEEK_CUR) ;
+					byte_count += count ;
+					break ;
+
+			default :
+				psf_log_printf (psf, "*** Invalid format specifier `%c'\n", c) ;
+				psf->error = SFE_INTERNAL ;
+				break ;
+			} ;
+		} ;
+
+	va_end (argptr) ;
+
+	return byte_count ;
+} /* psf_binheader_readf */
+
+/*-----------------------------------------------------------------------------------------------
+*/
+
+sf_count_t
+psf_default_seek (SF_PRIVATE *psf, int UNUSED (mode), sf_count_t samples_from_start)
+{	sf_count_t position, retval ;
+
+	if (! (psf->blockwidth && psf->dataoffset >= 0))
+	{	psf->error = SFE_BAD_SEEK ;
+		return	PSF_SEEK_ERROR ;
+		} ;
+
+	if (! psf->sf.seekable)
+	{	psf->error = SFE_NOT_SEEKABLE ;
+		return	PSF_SEEK_ERROR ;
+		} ;
+
+	position = psf->dataoffset + psf->blockwidth * samples_from_start ;
+
+	if ((retval = psf_fseek (psf, position, SEEK_SET)) != position)
+	{	psf->error = SFE_SEEK_FAILED ;
+		return PSF_SEEK_ERROR ;
+		} ;
+
+	return samples_from_start ;
+} /* psf_default_seek */
+
+/*-----------------------------------------------------------------------------------------------
+*/
+
+void
+psf_hexdump (const void *ptr, int len)
+{	const char *data ;
+	char	ascii [17] ;
+	int		k, m ;
+
+	if ((data = ptr) == NULL)
+		return ;
+	if (len <= 0)
+		return ;
+
+	puts ("") ;
+	for (k = 0 ; k < len ; k += 16)
+	{	memset (ascii, ' ', sizeof (ascii)) ;
+
+		printf ("%08X: ", k) ;
+		for (m = 0 ; m < 16 && k + m < len ; m++)
+		{	printf (m == 8 ? " %02X " : "%02X ", data [k + m] & 0xFF) ;
+			ascii [m] = psf_isprint (data [k + m]) ? data [k + m] : '.' ;
+			} ;
+
+		if (m <= 8) printf (" ") ;
+		for ( ; m < 16 ; m++) printf ("   ") ;
+
+		ascii [16] = 0 ;
+		printf (" %s\n", ascii) ;
+		} ;
+
+	puts ("") ;
+} /* psf_hexdump */
+
+void
+psf_log_SF_INFO (SF_PRIVATE *psf)
+{	psf_log_printf (psf, "---------------------------------\n") ;
+
+	psf_log_printf (psf, " Sample rate :   %d\n", psf->sf.samplerate) ;
+	psf_log_printf (psf, " Frames      :   %D\n", psf->sf.frames) ;
+	psf_log_printf (psf, " Channels    :   %d\n", psf->sf.channels) ;
+
+	psf_log_printf (psf, " Format      :   0x%X\n", psf->sf.format) ;
+	psf_log_printf (psf, " Sections    :   %d\n", psf->sf.sections) ;
+	psf_log_printf (psf, " Seekable    :   %s\n", psf->sf.seekable ? "TRUE" : "FALSE") ;
+
+	psf_log_printf (psf, "---------------------------------\n") ;
+} /* psf_dump_SFINFO */
+
+/*========================================================================================
+*/
+
+void*
+psf_memset (void *s, int c, sf_count_t len)
+{	char	*ptr ;
+	int 	setcount ;
+
+	ptr = (char *) s ;
+
+	while (len > 0)
+	{	setcount = (len > 0x10000000) ? 0x10000000 : (int) len ;
+
+		memset (ptr, c, setcount) ;
+
+		ptr += setcount ;
+		len -= setcount ;
+		} ;
+
+	return s ;
+} /* psf_memset */
+
+SF_INSTRUMENT *
+psf_instrument_alloc (void)
+{	SF_INSTRUMENT *instr ;
+
+	instr = calloc (1, sizeof (SF_INSTRUMENT)) ;
+
+	if (instr == NULL)
+		return NULL ;
+
+	/* Set non-zero default values. */
+	instr->basenote = -1 ;
+	instr->velocity_lo = -1 ;
+	instr->velocity_hi = -1 ;
+	instr->key_lo = -1 ;
+	instr->key_hi = -1 ;
+
+	return instr ;
+} /* psf_instrument_alloc */
+
+void
+psf_sanitize_string (char * cptr, int len)
+{
+	do
+	{
+		len -- ;
+		cptr [len] = psf_isprint (cptr [len]) ? cptr [len] : '.' ;
+	}
+	while (len > 0) ;
+} /* psf_sanitize_string */
+
+void
+psf_get_date_str (char *str, int maxlen)
+{	time_t		current ;
+	struct tm	timedata, *tmptr ;
+
+	time (&current) ;
+
+#if defined (HAVE_GMTIME_R)
+	/* If the re-entrant version is available, use it. */
+	tmptr = gmtime_r (&current, &timedata) ;
+#elif defined (HAVE_GMTIME)
+	/* Otherwise use the standard one and copy the data to local storage. */
+	tmptr = gmtime (&current) ;
+	memcpy (&timedata, tmptr, sizeof (timedata)) ;
+#else
+	tmptr = NULL ;
+#endif
+
+	if (tmptr)
+		snprintf (str, maxlen, "%4d-%02d-%02d %02d:%02d:%02d UTC",
+			1900 + timedata.tm_year, timedata.tm_mon, timedata.tm_mday,
+			timedata.tm_hour, timedata.tm_min, timedata.tm_sec) ;
+	else
+		snprintf (str, maxlen, "Unknown date") ;
+
+	return ;
+} /* psf_get_date_str */
+
+int
+subformat_to_bytewidth (int format)
+{
+	switch (format)
+	{	case SF_FORMAT_PCM_U8 :
+		case SF_FORMAT_PCM_S8 :
+				return 1 ;
+		case SF_FORMAT_PCM_16 :
+				return 2 ;
+		case SF_FORMAT_PCM_24 :
+				return 3 ;
+		case SF_FORMAT_PCM_32 :
+		case SF_FORMAT_FLOAT :
+				return 4 ;
+		case SF_FORMAT_DOUBLE :
+				return 8 ;
+		} ;
+
+	return 0 ;
+} /* subformat_to_bytewidth */
+
+int
+s_bitwidth_to_subformat (int bits)
+{	static int array [] =
+	{	SF_FORMAT_PCM_S8, SF_FORMAT_PCM_16, SF_FORMAT_PCM_24, SF_FORMAT_PCM_32
+		} ;
+
+	if (bits < 8 || bits > 32)
+		return 0 ;
+
+	return array [((bits + 7) / 8) - 1] ;
+} /* bitwidth_to_subformat */
+
+int
+u_bitwidth_to_subformat (int bits)
+{	static int array [] =
+	{	SF_FORMAT_PCM_U8, SF_FORMAT_PCM_16, SF_FORMAT_PCM_24, SF_FORMAT_PCM_32
+		} ;
+
+	if (bits < 8 || bits > 32)
+		return 0 ;
+
+	return array [((bits + 7) / 8) - 1] ;
+} /* bitwidth_to_subformat */
+
+/*
+**	psf_rand_int32 : Not crypto quality, but more than adequate for things
+**	like stream serial numbers in Ogg files or the unique_id field of the
+**	SF_PRIVATE struct.
+*/
+
+int
+psf_rand_int32 (void)
+{	static int value = -1 ;
+	int k, count ;
+
+	if (value == -1)
+	{
+#if HAVE_GETTIMEOFDAY
+		struct timeval tv ;
+		gettimeofday (&tv, NULL) ;
+		value = tv.tv_sec + tv.tv_usec ;
+#else
+		value = time (NULL) ;
+#endif
+		} ;
+
+	count = 4 + (value & 7) ;
+	for (k = 0 ; k < count ; k++)
+		value = 11117 * value + 211231 ;
+
+	return value ;
+} /* psf_rand_int32 */
+
+void
+append_snprintf (char * dest, size_t maxlen, const char * fmt, ...)
+{	size_t len = strlen (dest) ;
+
+	if (len < maxlen)
+	{	va_list ap ;
+
+		va_start (ap, fmt) ;
+		vsnprintf (dest + len, maxlen - len, fmt, ap) ;
+		va_end (ap) ;
+		} ;
+
+	return ;
+} /* append_snprintf */
+
+/*==============================================================================
+*/
+
+#define CASE_NAME(x)		case x : return #x ; break ;
+
+const char *
+str_of_major_format (int format)
+{	switch (SF_CONTAINER (format))
+	{	CASE_NAME (SF_FORMAT_WAV) ;
+		CASE_NAME (SF_FORMAT_AIFF) ;
+		CASE_NAME (SF_FORMAT_AU) ;
+		CASE_NAME (SF_FORMAT_RAW) ;
+		CASE_NAME (SF_FORMAT_PAF) ;
+		CASE_NAME (SF_FORMAT_SVX) ;
+		CASE_NAME (SF_FORMAT_NIST) ;
+		CASE_NAME (SF_FORMAT_VOC) ;
+		CASE_NAME (SF_FORMAT_IRCAM) ;
+		CASE_NAME (SF_FORMAT_W64) ;
+		CASE_NAME (SF_FORMAT_MAT4) ;
+		CASE_NAME (SF_FORMAT_MAT5) ;
+		CASE_NAME (SF_FORMAT_PVF) ;
+		CASE_NAME (SF_FORMAT_XI) ;
+		CASE_NAME (SF_FORMAT_HTK) ;
+		CASE_NAME (SF_FORMAT_SDS) ;
+		CASE_NAME (SF_FORMAT_AVR) ;
+		CASE_NAME (SF_FORMAT_WAVEX) ;
+		CASE_NAME (SF_FORMAT_SD2) ;
+		CASE_NAME (SF_FORMAT_FLAC) ;
+		CASE_NAME (SF_FORMAT_CAF) ;
+		CASE_NAME (SF_FORMAT_WVE) ;
+		CASE_NAME (SF_FORMAT_OGG) ;
+		default :
+			break ;
+		} ;
+
+	return "BAD_MAJOR_FORMAT" ;
+} /* str_of_major_format */
+
+const char *
+str_of_minor_format (int format)
+{	switch (SF_CODEC (format))
+	{	CASE_NAME (SF_FORMAT_PCM_S8) ;
+		CASE_NAME (SF_FORMAT_PCM_16) ;
+		CASE_NAME (SF_FORMAT_PCM_24) ;
+		CASE_NAME (SF_FORMAT_PCM_32) ;
+		CASE_NAME (SF_FORMAT_PCM_U8) ;
+		CASE_NAME (SF_FORMAT_FLOAT) ;
+		CASE_NAME (SF_FORMAT_DOUBLE) ;
+		CASE_NAME (SF_FORMAT_ULAW) ;
+		CASE_NAME (SF_FORMAT_ALAW) ;
+		CASE_NAME (SF_FORMAT_IMA_ADPCM) ;
+		CASE_NAME (SF_FORMAT_MS_ADPCM) ;
+		CASE_NAME (SF_FORMAT_GSM610) ;
+		CASE_NAME (SF_FORMAT_VOX_ADPCM) ;
+		CASE_NAME (SF_FORMAT_G721_32) ;
+		CASE_NAME (SF_FORMAT_G723_24) ;
+		CASE_NAME (SF_FORMAT_G723_40) ;
+		CASE_NAME (SF_FORMAT_DWVW_12) ;
+		CASE_NAME (SF_FORMAT_DWVW_16) ;
+		CASE_NAME (SF_FORMAT_DWVW_24) ;
+		CASE_NAME (SF_FORMAT_DWVW_N) ;
+		CASE_NAME (SF_FORMAT_DPCM_8) ;
+		CASE_NAME (SF_FORMAT_DPCM_16) ;
+		CASE_NAME (SF_FORMAT_VORBIS) ;
+		default :
+			break ;
+		} ;
+
+	return "BAD_MINOR_FORMAT" ;
+} /* str_of_minor_format */
+
+const char *
+str_of_open_mode (int mode)
+{	switch (mode)
+	{	CASE_NAME (SFM_READ) ;
+		CASE_NAME (SFM_WRITE) ;
+		CASE_NAME (SFM_RDWR) ;
+
+		default :
+			break ;
+		} ;
+
+	return "BAD_MODE" ;
+} /* str_of_open_mode */
+
+const char *
+str_of_endianness (int end)
+{	switch (end)
+	{	CASE_NAME (SF_ENDIAN_BIG) ;
+		CASE_NAME (SF_ENDIAN_LITTLE) ;
+		CASE_NAME (SF_ENDIAN_CPU) ;
+		default :
+			break ;
+		} ;
+
+	/* Zero length string for SF_ENDIAN_FILE. */
+	return "" ;
+} /* str_of_endianness */
diff -Nru libsndfile-1.0.21.orig/src/common.h libsndfile-1.0.21/src/common.h
--- libsndfile-1.0.21.orig/src/common.h	Thu Dec 10 20:49:31 2009
+++ libsndfile-1.0.21/src/common.h	Wed Jul  7 18:04:05 2010
@@ -1,887 +1,887 @@
-/*
-** Copyright (C) 1999-2009 Erik de Castro Lopo <erikd@mega-nerd.com>
-**
-** This program is free software; you can redistribute it and/or modify
-** it under the terms of the GNU Lesser General Public License as published by
-** the Free Software Foundation; either version 2.1 of the License, or
-** (at your option) any later version.
-**
-** This program is distributed in the hope that it will be useful,
-** but WITHOUT ANY WARRANTY; without even the implied warranty of
-** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-** GNU Lesser General Public License for more details.
-**
-** You should have received a copy of the GNU Lesser General Public License
-** along with this program; if not, write to the Free Software
-** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
-*/
-
-#ifndef SNDFILE_COMMON_H
-#define SNDFILE_COMMON_H
-
-#include "sfconfig.h"
-
-#include <stdlib.h>
-
-#if HAVE_STDINT_H
-#include <stdint.h>
-#elif HAVE_INTTYPES_H
-#include <inttypes.h>
-#endif
-
-#ifndef SNDFILE_H
-#include "sndfile.h"
-#endif
-
-#ifdef __cplusplus
-#error "This code is not designed to be compiled with a C++ compiler."
-#endif
-
-#if (SIZEOF_LONG == 8)
-#	define	SF_PLATFORM_S64(x)		x##l
-#elif (SIZEOF_LONG_LONG == 8)
-#	define	SF_PLATFORM_S64(x)		x##ll
-#elif COMPILER_IS_GCC
-#	define	SF_PLATFORM_S64(x)		x##ll
-#elif OS_IS_WIN32
-#	define	SF_PLATFORM_S64(x)		x##I64
-#else
-#	error "Don't know how to define a 64 bit integer constant."
-#endif
-
-
-
-/*
-** Inspiration : http://sourcefrog.net/weblog/software/languages/C/unused.html
-*/
-#ifdef UNUSED
-#elif defined (__GNUC__)
-#	define UNUSED(x) UNUSED_ ## x __attribute__ ((unused))
-#elif defined (__LCLINT__)
-#	define UNUSED(x) /*@unused@*/ x
-#else
-#	define UNUSED(x) x
-#endif
-
-#ifdef __GNUC__
-#	define WARN_UNUSED	__attribute__ ((warn_unused_result))
-#else
-#	define WARN_UNUSED
-#endif
-
-#define	SF_BUFFER_LEN			(8192*2)
-#define	SF_FILENAME_LEN			(512)
-#define SF_SYSERR_LEN			(256)
-#define SF_MAX_STRINGS			(32)
-#define SF_STR_BUFFER_LEN		(8192)
-#define	SF_HEADER_LEN			(4100 + SF_STR_BUFFER_LEN)
-
-#define	PSF_SEEK_ERROR			((sf_count_t) -1)
-
-
-#define	BITWIDTH2BYTES(x)	(((x) + 7) / 8)
-
-/*	For some reason sizeof returns an unsigned  value which causes
-**	a warning when that value is added or subtracted from a signed
-**	value. Use SIGNED_SIZEOF instead.
-*/
-#define		SIGNED_SIZEOF(x)	((int) sizeof (x))
-
-#define		ARRAY_LEN(x)	((int) (sizeof (x) / sizeof ((x) [0])))
-
-#if (COMPILER_IS_GCC == 1)
-#define		SF_MAX(x,y)		({ \
-								typeof (x) sf_max_x1 = (x) ; \
-								typeof (y) sf_max_y1 = (y) ; \
-								(void) (&sf_max_x1 == &sf_max_y1) ; \
-								sf_max_x1 > sf_max_y1 ? sf_max_x1 : sf_max_y1 ; })
-
-#define		SF_MIN(x,y)		({ \
-								typeof (x) sf_min_x2 = (x) ; \
-								typeof (y) sf_min_y2 = (y) ; \
-								(void) (&sf_min_x2 == &sf_min_y2) ; \
-								sf_min_x2 < sf_min_y2 ? sf_min_x2 : sf_min_y2 ; })
-#else
-#define		SF_MAX(a,b)		((a) > (b) ? (a) : (b))
-#define		SF_MIN(a,b)		((a) < (b) ? (a) : (b))
-#endif
-
-
-#define		SF_MAX_CHANNELS	256
-
-/*
-*	Macros for spliting the format file of SF_INFI into contrainer type,
-**	codec type and endian-ness.
-*/
-#define SF_CONTAINER(x)		((x) & SF_FORMAT_TYPEMASK)
-#define SF_CODEC(x)			((x) & SF_FORMAT_SUBMASK)
-#define SF_ENDIAN(x)		((x) & SF_FORMAT_ENDMASK)
-
-
-enum
-{	/* PEAK chunk location. */
-	SF_PEAK_START		= 42,
-	SF_PEAK_END			= 43,
-
-	/* PEAK chunk location. */
-	SF_SCALE_MAX		= 52,
-	SF_SCALE_MIN		= 53,
-
-	/* str_flags values. */
-	SF_STR_ALLOW_START	= 0x0100,
-	SF_STR_ALLOW_END	= 0x0200,
-
-	/* Location of strings. */
-	SF_STR_LOCATE_START	= 0x0400,
-	SF_STR_LOCATE_END	= 0x0800,
-
-	SFD_TYPEMASK		= 0x0FFFFFFF
-} ;
-
-#define		SFM_MASK 	(SFM_READ | SFM_WRITE | SFM_RDWR)
-#define		SFM_UNMASK 	(~SFM_MASK)
-
-/*---------------------------------------------------------------------------------------
-** Formats that may be supported at some time in the future.
-** When support is finalised, these values move to src/sndfile.h.
-*/
-
-enum
-{	/* Work in progress. */
-
-	/* Formats supported read only. */
-	SF_FORMAT_TXW			= 0x4030000,		/* Yamaha TX16 sampler file */
-	SF_FORMAT_DWD			= 0x4040000,		/* DiamondWare Digirized */
-
-	/* Following are detected but not supported. */
-	SF_FORMAT_REX			= 0x40A0000,		/* Propellorheads Rex/Rcy */
-	SF_FORMAT_REX2			= 0x40D0000,		/* Propellorheads Rex2 */
-	SF_FORMAT_KRZ			= 0x40E0000,		/* Kurzweil sampler file */
-	SF_FORMAT_WMA			= 0x4100000,		/* Windows Media Audio. */
-	SF_FORMAT_SHN			= 0x4110000,		/* Shorten. */
-
-	/* Unsupported encodings. */
-	SF_FORMAT_SVX_FIB		= 0x1020, 		/* SVX Fibonacci Delta encoding. */
-	SF_FORMAT_SVX_EXP		= 0x1021, 		/* SVX Exponential Delta encoding. */
-
-	SF_FORMAT_PCM_N			= 0x1030
-} ;
-
-/*---------------------------------------------------------------------------------------
-**	PEAK_CHUNK - This chunk type is common to both AIFF and WAVE files although their
-**	endian encodings are different.
-*/
-
-typedef struct
-{	double		value ;		/* signed value of peak */
-	sf_count_t	position ;	/* the sample frame for the peak */
-} PEAK_POS ;
-
-typedef struct
-{	/* libsndfile internal : write a PEAK chunk at the start or end of the file? */
-	int				peak_loc ;
-
-	/* WAV/AIFF */
-	unsigned int	version ;	/* version of the PEAK chunk */
-	unsigned int	timestamp ;	/* secs since 1/1/1970  */
-
-	/* CAF */
-	unsigned int	edit_number ;
-
-#if HAVE_FLEXIBLE_ARRAY
-	/* the per channel peak info */
-	PEAK_POS		peaks [] ;
-#else
-	/*
-	** This is not ISO compliant C. It works on some compilers which
-	** don't support the ISO standard flexible struct array which is
-	** used above. If your compiler doesn't like this I suggest you find
-	** youself a 1999 ISO C standards compilant compiler. GCC-3.X is
-	** highly recommended.
-	*/
-	PEAK_POS		peaks [0] ;
-#endif
-} PEAK_INFO ;
-
-static inline PEAK_INFO *
-peak_info_calloc (int channels)
-{	return calloc (1, sizeof (PEAK_INFO) + channels * sizeof (PEAK_POS)) ;
-} /* peak_info_calloc */
-
-typedef struct
-{	int		type ;
-	int		flags ;
-	char 	*str ;
-} STR_DATA ;
-
-static inline size_t
-make_size_t (int x)
-{	return (size_t) x ;
-} /* size_t_of_int */
-
-/*
-**	This version of isprint specifically ignores any locale info. Its used for
-**	determining which characters can be printed in things like hexdumps.
-*/
-static inline int
-psf_isprint (int ch)
-{	return (ch >= ' ' && ch <= '~') ;
-} /* psf_isprint */
-
-/*=======================================================================================
-**	SF_PRIVATE stuct - a pointer to this struct is passed back to the caller of the
-**	sf_open_XXXX functions. The caller however has no knowledge of the struct's
-**	contents.
-*/
-
-
-typedef struct
-{	int size ;
-	SF_BROADCAST_INFO binfo ;
-} PSF_BROADCAST_VAR ;
-
-#if SIZEOF_WCHAR_T == 2
-typedef wchar_t	sfwchar_t ;
-#else
-typedef int16_t sfwchar_t ;
-#endif
-
-
-typedef struct
-{
-	union
-	{	char		c [SF_FILENAME_LEN] ;
-		sfwchar_t	wc [SF_FILENAME_LEN] ;
-	} path ;
-
-	union
-	{	char		c [SF_FILENAME_LEN] ;
-		sfwchar_t	wc [SF_FILENAME_LEN] ;
-	} dir ;
-
-	union
-	{	char		c [SF_FILENAME_LEN / 4] ;
-		sfwchar_t	wc [SF_FILENAME_LEN / 4] ;
-	} name ;
-
-#if USE_WINDOWS_API
-	/*
-	**	These fields can only be used in src/file_io.c.
-	**	They are basically the same as a windows file HANDLE.
-	*/
-	void 			*handle, *hsaved ;
-
-	int				use_wchar ;
-#else
-	/* These fields can only be used in src/file_io.c. */
-	int 			filedes, savedes ;
-#endif
-
-	int				do_not_close_descriptor ;
-	int				mode ;			/* Open mode : SFM_READ, SFM_WRITE or SFM_RDWR. */
-} PSF_FILE ;
-
-
-typedef struct sf_private_tag
-{
-	/* Canary in a coal mine. */
-	union
-	{	/* Place a double here to encourage double alignment. */
-		double d [2] ;
-		char c [16] ;
-		} canary ;
-
-	/* Force the compiler to double align the start of buffer. */
-	union
-	{	double			dbuf	[SF_BUFFER_LEN / sizeof (double)] ;
-#if (defined (SIZEOF_INT64_T) && (SIZEOF_INT64_T == 8))
-		int64_t			lbuf	[SF_BUFFER_LEN / sizeof (int64_t)] ;
-#else
-		long			lbuf	[SF_BUFFER_LEN / sizeof (double)] ;
-#endif
-		float			fbuf	[SF_BUFFER_LEN / sizeof (float)] ;
-		int				ibuf	[SF_BUFFER_LEN / sizeof (int)] ;
-		short			sbuf	[SF_BUFFER_LEN / sizeof (short)] ;
-		char			cbuf	[SF_BUFFER_LEN / sizeof (char)] ;
-		signed char		scbuf	[SF_BUFFER_LEN / sizeof (signed char)] ;
-		unsigned char	ucbuf	[SF_BUFFER_LEN / sizeof (signed char)] ;
-		} u ;
-
-
-	PSF_FILE		file, rsrc ;
-
-	char			syserr		[SF_SYSERR_LEN] ;
-
-	/* logbuffer and logindex should only be changed within the logging functions
-	** of common.c
-	*/
-	char			logbuffer	[SF_BUFFER_LEN] ;
-	unsigned char	header		[SF_HEADER_LEN] ; /* Must be unsigned */
-	int				rwf_endian ;	/* Header endian-ness flag. */
-
-	/* Storage and housekeeping data for adding/reading strings from
-	** sound files.
-	*/
-	STR_DATA		strings [SF_MAX_STRINGS] ;
-	char			str_storage [SF_STR_BUFFER_LEN] ;
-	char			*str_end ;
-	int				str_flags ;
-
-	/* Guard value. If this changes the buffers above have overflowed. */
-	int				Magick ;
-
-	unsigned		unique_id ;
-
-	/* Index variables for maintaining logbuffer and header above. */
-	int				logindex ;
-	int				headindex, headend ;
-	int				has_text ;
-
-	int				error ;
-
-	int				endian ;		/* File endianness : SF_ENDIAN_LITTLE or SF_ENDIAN_BIG. */
-	int				data_endswap ;	/* Need to endswap data? */
-
-	/*
-	** Maximum float value for calculating the multiplier for
-	** float/double to short/int conversions.
-	*/
-	int				float_int_mult ;
-	float			float_max ;
-
-	int				scale_int_float ;
-
-	/* Vairables for handling pipes. */
-	int				is_pipe ;		/* True if file is a pipe. */
-	sf_count_t		pipeoffset ;	/* Number of bytes read from a pipe. */
-
-	/* True if clipping must be performed on float->int conversions. */
-	int				add_clipping ;
-
-	SF_INFO			sf ;
-
-	int				have_written ;	/* Has a single write been done to the file? */
-	PEAK_INFO		*peak_info ;
-
-	/* Loop Info */
-	SF_LOOP_INFO	*loop_info ;
-	SF_INSTRUMENT	*instrument ;
-
-	/* Broadcast (EBU) Info */
-	PSF_BROADCAST_VAR *broadcast_var ;
-
-	/* Channel map data (if present) : an array of ints. */
-	int				*channel_map ;
-
-	sf_count_t		filelength ;	/* Overall length of (embedded) file. */
-	sf_count_t		fileoffset ;	/* Offset in number of bytes from beginning of file. */
-
-	sf_count_t		rsrclength ;	/* Length of the resource fork (if it exists). */
-
-	sf_count_t		dataoffset ;	/* Offset in number of bytes from beginning of file. */
-	sf_count_t		datalength ;	/* Length in bytes of the audio data. */
-	sf_count_t		dataend ;		/* Offset to file tailer. */
-
-	int				blockwidth ;	/* Size in bytes of one set of interleaved samples. */
-	int				bytewidth ;		/* Size in bytes of one sample (one channel). */
-
-	void			*dither ;
-	void			*interleave ;
-
-	int				last_op ;		/* Last operation; either SFM_READ or SFM_WRITE */
-	sf_count_t		read_current ;
-	sf_count_t		write_current ;
-
-	void			*container_data ;	/*	This is a pointer to dynamically allocated file
-										**	container format specific data.
-										*/
-
-	void			*codec_data ;		/*	This is a pointer to dynamically allocated file
-										**	codec format specific data.
-										*/
-
-	SF_DITHER_INFO	write_dither ;
-	SF_DITHER_INFO	read_dither ;
-
-	int				norm_double ;
-	int				norm_float ;
-
-	int				auto_header ;
-
-	int				ieee_replace ;
-
-	/* A set of file specific function pointers */
-	sf_count_t		(*read_short)	(struct sf_private_tag*, short *ptr, sf_count_t len) ;
-	sf_count_t		(*read_int)		(struct sf_private_tag*, int *ptr, sf_count_t len) ;
-	sf_count_t		(*read_float)	(struct sf_private_tag*, float *ptr, sf_count_t len) ;
-	sf_count_t		(*read_double)	(struct sf_private_tag*, double *ptr, sf_count_t len) ;
-
-	sf_count_t		(*write_short)	(struct sf_private_tag*, const short *ptr, sf_count_t len) ;
-	sf_count_t		(*write_int)	(struct sf_private_tag*, const int *ptr, sf_count_t len) ;
-	sf_count_t		(*write_float)	(struct sf_private_tag*, const float *ptr, sf_count_t len) ;
-	sf_count_t		(*write_double)	(struct sf_private_tag*, const double *ptr, sf_count_t len) ;
-
-	sf_count_t		(*seek) 		(struct sf_private_tag*, int mode, sf_count_t samples_from_start) ;
-	int				(*write_header)	(struct sf_private_tag*, int calc_length) ;
-	int				(*command)		(struct sf_private_tag*, int command, void *data, int datasize) ;
-
-	/*
-	**	Separate close functions for the codec and the container.
-	**	The codec close function is always called first.
-	*/
-	int				(*codec_close)		(struct sf_private_tag*) ;
-	int				(*container_close)	(struct sf_private_tag*) ;
-
-	char			*format_desc ;
-
-	/* Virtual I/O functions. */
-	int					virtual_io ;
-	SF_VIRTUAL_IO		vio ;
-	void				*vio_user_data ;
-} SF_PRIVATE ;
-
-
-
-enum
-{	SFE_NO_ERROR				= SF_ERR_NO_ERROR,
-	SFE_BAD_OPEN_FORMAT			= SF_ERR_UNRECOGNISED_FORMAT,
-	SFE_SYSTEM					= SF_ERR_SYSTEM,
-	SFE_MALFORMED_FILE			= SF_ERR_MALFORMED_FILE,
-	SFE_UNSUPPORTED_ENCODING	= SF_ERR_UNSUPPORTED_ENCODING,
-
-	SFE_ZERO_MAJOR_FORMAT,
-	SFE_ZERO_MINOR_FORMAT,
-	SFE_BAD_FILE,
-	SFE_BAD_FILE_READ,
-	SFE_OPEN_FAILED,
-	SFE_BAD_SNDFILE_PTR,
-	SFE_BAD_SF_INFO_PTR,
-	SFE_BAD_SF_INCOMPLETE,
-	SFE_BAD_FILE_PTR,
-	SFE_BAD_INT_PTR,
-	SFE_BAD_STAT_SIZE,
-	SFE_MALLOC_FAILED,
-	SFE_UNIMPLEMENTED,
-	SFE_BAD_READ_ALIGN,
-	SFE_BAD_WRITE_ALIGN,
-	SFE_UNKNOWN_FORMAT,
-	SFE_NOT_READMODE,
-	SFE_NOT_WRITEMODE,
-	SFE_BAD_MODE_RW,
-	SFE_BAD_SF_INFO,
-	SFE_BAD_OFFSET,
-	SFE_NO_EMBED_SUPPORT,
-	SFE_NO_EMBEDDED_RDWR,
-	SFE_NO_PIPE_WRITE,
-
-	SFE_INTERNAL,
-	SFE_BAD_COMMAND_PARAM,
-	SFE_BAD_ENDIAN,
-	SFE_CHANNEL_COUNT_ZERO,
-	SFE_CHANNEL_COUNT,
-
-	SFE_BAD_VIRTUAL_IO,
-
-	SFE_INTERLEAVE_MODE,
-	SFE_INTERLEAVE_SEEK,
-	SFE_INTERLEAVE_READ,
-
-	SFE_BAD_SEEK,
-	SFE_NOT_SEEKABLE,
-	SFE_AMBIGUOUS_SEEK,
-	SFE_WRONG_SEEK,
-	SFE_SEEK_FAILED,
-
-	SFE_BAD_OPEN_MODE,
-	SFE_OPEN_PIPE_RDWR,
-	SFE_RDWR_POSITION,
-	SFE_RDWR_BAD_HEADER,
-	SFE_CMD_HAS_DATA,
-	SFE_BAD_BROADCAST_INFO_SIZE,
-
-	SFE_STR_NO_SUPPORT,
-	SFE_STR_NOT_WRITE,
-	SFE_STR_MAX_DATA,
-	SFE_STR_MAX_COUNT,
-	SFE_STR_BAD_TYPE,
-	SFE_STR_NO_ADD_END,
-	SFE_STR_BAD_STRING,
-	SFE_STR_WEIRD,
-
-	SFE_WAV_NO_RIFF,
-	SFE_WAV_NO_WAVE,
-	SFE_WAV_NO_FMT,
-	SFE_WAV_BAD_FMT,
-	SFE_WAV_FMT_SHORT,
-	SFE_WAV_BAD_FACT,
-	SFE_WAV_BAD_PEAK,
-	SFE_WAV_PEAK_B4_FMT,
-	SFE_WAV_BAD_FORMAT,
-	SFE_WAV_BAD_BLOCKALIGN,
-	SFE_WAV_NO_DATA,
-	SFE_WAV_BAD_LIST,
-	SFE_WAV_ADPCM_NOT4BIT,
-	SFE_WAV_ADPCM_CHANNELS,
-	SFE_WAV_GSM610_FORMAT,
-	SFE_WAV_UNKNOWN_CHUNK,
-	SFE_WAV_WVPK_DATA,
-
-	SFE_AIFF_NO_FORM,
-	SFE_AIFF_AIFF_NO_FORM,
-	SFE_AIFF_COMM_NO_FORM,
-	SFE_AIFF_SSND_NO_COMM,
-	SFE_AIFF_UNKNOWN_CHUNK,
-	SFE_AIFF_COMM_CHUNK_SIZE,
-	SFE_AIFF_BAD_COMM_CHUNK,
-	SFE_AIFF_PEAK_B4_COMM,
-	SFE_AIFF_BAD_PEAK,
-	SFE_AIFF_NO_SSND,
-	SFE_AIFF_NO_DATA,
-	SFE_AIFF_RW_SSND_NOT_LAST,
-
-	SFE_AU_UNKNOWN_FORMAT,
-	SFE_AU_NO_DOTSND,
-	SFE_AU_EMBED_BAD_LEN,
-
-	SFE_RAW_READ_BAD_SPEC,
-	SFE_RAW_BAD_BITWIDTH,
-	SFE_RAW_BAD_FORMAT,
-
-	SFE_PAF_NO_MARKER,
-	SFE_PAF_VERSION,
-	SFE_PAF_UNKNOWN_FORMAT,
-	SFE_PAF_SHORT_HEADER,
-
-	SFE_SVX_NO_FORM,
-	SFE_SVX_NO_BODY,
-	SFE_SVX_NO_DATA,
-	SFE_SVX_BAD_COMP,
-	SFE_SVX_BAD_NAME_LENGTH,
-
-	SFE_NIST_BAD_HEADER,
-	SFE_NIST_CRLF_CONVERISON,
-	SFE_NIST_BAD_ENCODING,
-
-	SFE_VOC_NO_CREATIVE,
-	SFE_VOC_BAD_FORMAT,
-	SFE_VOC_BAD_VERSION,
-	SFE_VOC_BAD_MARKER,
-	SFE_VOC_BAD_SECTIONS,
-	SFE_VOC_MULTI_SAMPLERATE,
-	SFE_VOC_MULTI_SECTION,
-	SFE_VOC_MULTI_PARAM,
-	SFE_VOC_SECTION_COUNT,
-	SFE_VOC_NO_PIPE,
-
-	SFE_IRCAM_NO_MARKER,
-	SFE_IRCAM_BAD_CHANNELS,
-	SFE_IRCAM_UNKNOWN_FORMAT,
-
-	SFE_W64_64_BIT,
-	SFE_W64_NO_RIFF,
-	SFE_W64_NO_WAVE,
-	SFE_W64_NO_DATA,
-	SFE_W64_ADPCM_NOT4BIT,
-	SFE_W64_ADPCM_CHANNELS,
-	SFE_W64_GSM610_FORMAT,
-
-	SFE_MAT4_BAD_NAME,
-	SFE_MAT4_NO_SAMPLERATE,
-
-	SFE_MAT5_BAD_ENDIAN,
-	SFE_MAT5_NO_BLOCK,
-	SFE_MAT5_SAMPLE_RATE,
-
-	SFE_PVF_NO_PVF1,
-	SFE_PVF_BAD_HEADER,
-	SFE_PVF_BAD_BITWIDTH,
-
-	SFE_DWVW_BAD_BITWIDTH,
-	SFE_G72X_NOT_MONO,
-
-	SFE_XI_BAD_HEADER,
-	SFE_XI_EXCESS_SAMPLES,
-	SFE_XI_NO_PIPE,
-
-	SFE_HTK_NO_PIPE,
-
-	SFE_SDS_NOT_SDS,
-	SFE_SDS_BAD_BIT_WIDTH,
-
-	SFE_SD2_FD_DISALLOWED,
-	SFE_SD2_BAD_DATA_OFFSET,
-	SFE_SD2_BAD_MAP_OFFSET,
-	SFE_SD2_BAD_DATA_LENGTH,
-	SFE_SD2_BAD_MAP_LENGTH,
-	SFE_SD2_BAD_RSRC,
-	SFE_SD2_BAD_SAMPLE_SIZE,
-
-	SFE_FLAC_BAD_HEADER,
-	SFE_FLAC_NEW_DECODER,
-	SFE_FLAC_INIT_DECODER,
-	SFE_FLAC_LOST_SYNC,
-	SFE_FLAC_BAD_SAMPLE_RATE,
-	SFE_FLAC_UNKOWN_ERROR,
-
-	SFE_WVE_NOT_WVE,
-	SFE_WVE_NO_PIPE,
-
-	SFE_VORBIS_ENCODER_BUG,
-
-	SFE_RF64_NOT_RF64,
-
-	SFE_MAX_ERROR			/* This must be last in list. */
-} ;
-
-int subformat_to_bytewidth (int format) ;
-int s_bitwidth_to_subformat (int bits) ;
-int u_bitwidth_to_subformat (int bits) ;
-
-/*  Functions for reading and writing floats and doubles on processors
-**	with non-IEEE floats/doubles.
-*/
-float	float32_be_read		(unsigned char *cptr) ;
-float	float32_le_read		(unsigned char *cptr) ;
-void	float32_be_write	(float in, unsigned char *out) ;
-void	float32_le_write	(float in, unsigned char *out) ;
-
-double	double64_be_read	(unsigned char *cptr) ;
-double	double64_le_read	(unsigned char *cptr) ;
-void	double64_be_write	(double in, unsigned char *out) ;
-void	double64_le_write	(double in, unsigned char *out) ;
-
-/* Functions for writing to the internal logging buffer. */
-
-void	psf_log_printf		(SF_PRIVATE *psf, const char *format, ...) ;
-void	psf_log_SF_INFO 	(SF_PRIVATE *psf) ;
-
-int32_t	psf_rand_int32 (void) ;
-
-void append_snprintf (char * dest, size_t maxlen, const char * fmt, ...) ;
-
-/* Functions used when writing file headers. */
-
-int		psf_binheader_writef	(SF_PRIVATE *psf, const char *format, ...) ;
-void	psf_asciiheader_printf	(SF_PRIVATE *psf, const char *format, ...) ;
-
-/* Functions used when reading file headers. */
-
-int		psf_binheader_readf	(SF_PRIVATE *psf, char const *format, ...) ;
-
-/* Functions used in the write function for updating the peak chunk. */
-
-void	peak_update_short	(SF_PRIVATE *psf, short *ptr, size_t items) ;
-void	peak_update_int		(SF_PRIVATE *psf, int *ptr, size_t items) ;
-void	peak_update_double	(SF_PRIVATE *psf, double *ptr, size_t items) ;
-
-/* Functions defined in command.c. */
-
-int		psf_get_format_simple_count	(void) ;
-int		psf_get_format_simple		(SF_FORMAT_INFO *data) ;
-
-int		psf_get_format_info			(SF_FORMAT_INFO *data) ;
-
-int		psf_get_format_major_count	(void) ;
-int		psf_get_format_major		(SF_FORMAT_INFO *data) ;
-
-int		psf_get_format_subtype_count	(void) ;
-int		psf_get_format_subtype		(SF_FORMAT_INFO *data) ;
-
-void	psf_generate_format_desc (SF_PRIVATE *psf) ;
-
-double	psf_calc_signal_max			(SF_PRIVATE *psf, int normalize) ;
-int		psf_calc_max_all_channels	(SF_PRIVATE *psf, double *peaks, int normalize) ;
-
-int		psf_get_signal_max			(SF_PRIVATE *psf, double *peak) ;
-int		psf_get_max_all_channels	(SF_PRIVATE *psf, double *peaks) ;
-
-/* Functions in strings.c. */
-
-const char* psf_get_string (SF_PRIVATE *psf, int str_type) ;
-int psf_set_string (SF_PRIVATE *psf, int str_type, const char *str) ;
-int psf_store_string (SF_PRIVATE *psf, int str_type, const char *str) ;
-int psf_location_string_count (const SF_PRIVATE * psf, int location) ;
-
-/* Default seek function. Use for PCM and float encoded data. */
-sf_count_t	psf_default_seek (SF_PRIVATE *psf, int mode, sf_count_t samples_from_start) ;
-
-int macos_guess_file_type (SF_PRIVATE *psf, const char *filename) ;
-
-/*------------------------------------------------------------------------------------
-**	File I/O functions which will allow access to large files (> 2 Gig) on
-**	some 32 bit OSes. Implementation in file_io.c.
-*/
-
-int psf_fopen (SF_PRIVATE *psf) ;
-int psf_set_stdio (SF_PRIVATE *psf) ;
-int psf_file_valid (SF_PRIVATE *psf) ;
-void psf_set_file (SF_PRIVATE *psf, int fd) ;
-void psf_init_files (SF_PRIVATE *psf) ;
-void psf_use_rsrc (SF_PRIVATE *psf, int on_off) ;
-
-SNDFILE * psf_open_file (SF_PRIVATE *psf, SF_INFO *sfinfo) ;
-
-sf_count_t psf_fseek (SF_PRIVATE *psf, sf_count_t offset, int whence) ;
-sf_count_t psf_fread (void *ptr, sf_count_t bytes, sf_count_t count, SF_PRIVATE *psf) ;
-sf_count_t psf_fwrite (const void *ptr, sf_count_t bytes, sf_count_t count, SF_PRIVATE *psf) ;
-sf_count_t psf_fgets (char *buffer, sf_count_t bufsize, SF_PRIVATE *psf) ;
-sf_count_t psf_ftell (SF_PRIVATE *psf) ;
-sf_count_t psf_get_filelen (SF_PRIVATE *psf) ;
-
-void psf_fsync (SF_PRIVATE *psf) ;
-
-int psf_is_pipe (SF_PRIVATE *psf) ;
-
-int psf_ftruncate (SF_PRIVATE *psf, sf_count_t len) ;
-int psf_fclose (SF_PRIVATE *psf) ;
-
-/* Open and close the resource fork of a file. */
-int psf_open_rsrc (SF_PRIVATE *psf) ;
-int psf_close_rsrc (SF_PRIVATE *psf) ;
-
-/*
-void psf_fclearerr (SF_PRIVATE *psf) ;
-int psf_ferror (SF_PRIVATE *psf) ;
-*/
-
-/*------------------------------------------------------------------------------------
-** Functions for reading and writing different file formats.
-*/
-
-int		aiff_open	(SF_PRIVATE *psf) ;
-int		au_open		(SF_PRIVATE *psf) ;
-int		avr_open	(SF_PRIVATE *psf) ;
-int		htk_open	(SF_PRIVATE *psf) ;
-int		ircam_open	(SF_PRIVATE *psf) ;
-int		mat4_open	(SF_PRIVATE *psf) ;
-int		mat5_open	(SF_PRIVATE *psf) ;
-int		nist_open	(SF_PRIVATE *psf) ;
-int		paf_open	(SF_PRIVATE *psf) ;
-int		pvf_open	(SF_PRIVATE *psf) ;
-int		raw_open	(SF_PRIVATE *psf) ;
-int		sd2_open	(SF_PRIVATE *psf) ;
-int		sds_open	(SF_PRIVATE *psf) ;
-int		svx_open	(SF_PRIVATE *psf) ;
-int		voc_open	(SF_PRIVATE *psf) ;
-int		w64_open	(SF_PRIVATE *psf) ;
-int		wav_open	(SF_PRIVATE *psf) ;
-int		xi_open		(SF_PRIVATE *psf) ;
-int		flac_open	(SF_PRIVATE *psf) ;
-int		caf_open	(SF_PRIVATE *psf) ;
-int		mpc2k_open	(SF_PRIVATE *psf) ;
-int		rf64_open	(SF_PRIVATE *psf) ;
-
-/* In progress. Do not currently work. */
-
-int		mpeg_open	(SF_PRIVATE *psf) ;
-int		ogg_open	(SF_PRIVATE *psf) ;
-int		rx2_open	(SF_PRIVATE *psf) ;
-int		txw_open	(SF_PRIVATE *psf) ;
-int		wve_open	(SF_PRIVATE *psf) ;
-int		dwd_open	(SF_PRIVATE *psf) ;
-
-int		macbinary3_open (SF_PRIVATE *psf) ;
-
-/*------------------------------------------------------------------------------------
-**	Init functions for a number of common data encodings.
-*/
-
-int		pcm_init		(SF_PRIVATE *psf) ;
-int		ulaw_init		(SF_PRIVATE *psf) ;
-int		alaw_init		(SF_PRIVATE *psf) ;
-int		float32_init	(SF_PRIVATE *psf) ;
-int		double64_init	(SF_PRIVATE *psf) ;
-int		dwvw_init		(SF_PRIVATE *psf, int bitwidth) ;
-int		gsm610_init		(SF_PRIVATE *psf) ;
-int		vox_adpcm_init	(SF_PRIVATE *psf) ;
-int		flac_init		(SF_PRIVATE *psf) ;
-int		g72x_init 		(SF_PRIVATE * psf) ;
-
-int 	dither_init		(SF_PRIVATE *psf, int mode) ;
-
-int		wav_w64_ima_init (SF_PRIVATE *psf, int blockalign, int samplesperblock) ;
-int		wav_w64_msadpcm_init (SF_PRIVATE *psf, int blockalign, int samplesperblock) ;
-
-int		aiff_ima_init (SF_PRIVATE *psf, int blockalign, int samplesperblock) ;
-
-int		interleave_init (SF_PRIVATE *psf) ;
-
-/*------------------------------------------------------------------------------------
-** Chunk logging functions.
-*/
-
-typedef struct
-{	struct
-	{	int chunk ;
-		sf_count_t offset ;
-		sf_count_t len ;
-	} l [100] ;
-
-	int count ;
-} PRIV_CHUNK4 ;
-
-void pchk4_store (PRIV_CHUNK4 * pchk, int marker, sf_count_t offset, sf_count_t len) ;
-int pchk4_find (PRIV_CHUNK4 * pchk, int marker) ;
-
-/*------------------------------------------------------------------------------------
-** Other helper functions.
-*/
-
-void	*psf_memset (void *s, int c, sf_count_t n) ;
-
-SF_INSTRUMENT * psf_instrument_alloc (void) ;
-
-void	psf_sanitize_string (char * cptr, int len) ;
-
-/* Generate the current date as a string. */
-void	psf_get_date_str (char *str, int maxlen) ;
-
-PSF_BROADCAST_VAR* broadcast_var_alloc (size_t datasize) ;
-int		broadcast_var_set (SF_PRIVATE *psf, const SF_BROADCAST_INFO * data, size_t datasize) ;
-int		broadcast_var_get (SF_PRIVATE *psf, SF_BROADCAST_INFO * data, size_t datasize) ;
-
-
-typedef struct
-{	int channels ;
-	int endianness ;
-} AUDIO_DETECT ;
-
-int audio_detect (SF_PRIVATE * psf, AUDIO_DETECT *ad, const unsigned char * data, int datalen) ;
-
-
-/*------------------------------------------------------------------------------------
-** Helper/debug functions.
-*/
-
-void	psf_hexdump (const void *ptr, int len) ;
-
-const char * str_of_major_format (int format) ;
-const char * str_of_minor_format (int format) ;
-const char * str_of_open_mode (int mode) ;
-const char * str_of_endianness (int end) ;
-
-/*------------------------------------------------------------------------------------
-** Extra commands for sf_command(). Not for public use yet.
-*/
-
-enum
-{	SFC_TEST_AIFF_ADD_INST_CHUNK	= 0x2000,
-	SFC_TEST_WAV_ADD_INFO_CHUNK		= 0x2010
-} ;
-
-/*
-** Maybe, one day, make these functions or something like them, public.
-**
-** Buffer to buffer dithering. Pointer in and out are allowed to point
-** to the same buffer for in-place dithering.
-*/
-
-#if 0
-int sf_dither_short		(const SF_DITHER_INFO *dither, const short *in, short *out, int count) ;
-int sf_dither_int		(const SF_DITHER_INFO *dither, const int *in, int *out, int count) ;
-int sf_dither_float		(const SF_DITHER_INFO *dither, const float *in, float *out, int count) ;
-int sf_dither_double	(const SF_DITHER_INFO *dither, const double *in, double *out, int count) ;
-#endif
-
-#endif /* SNDFILE_COMMON_H */
-
+/*
+** Copyright (C) 1999-2009 Erik de Castro Lopo <erikd@mega-nerd.com>
+**
+** This program is free software; you can redistribute it and/or modify
+** it under the terms of the GNU Lesser General Public License as published by
+** the Free Software Foundation; either version 2.1 of the License, or
+** (at your option) any later version.
+**
+** This program is distributed in the hope that it will be useful,
+** but WITHOUT ANY WARRANTY; without even the implied warranty of
+** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+** GNU Lesser General Public License for more details.
+**
+** You should have received a copy of the GNU Lesser General Public License
+** along with this program; if not, write to the Free Software
+** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*/
+
+#ifndef SNDFILE_COMMON_H
+#define SNDFILE_COMMON_H
+
+#include "sfconfig.h"
+
+#include <stdlib.h>
+
+#if HAVE_STDINT_H
+#include <stdint.h>
+#elif HAVE_INTTYPES_H
+#include <inttypes.h>
+#endif
+
+#ifndef SNDFILE_H
+#include "sndfile.h"
+#endif
+
+#ifdef __cplusplus
+#error "This code is not designed to be compiled with a C++ compiler."
+#endif
+
+#if (SIZEOF_LONG == 8)
+#	define	SF_PLATFORM_S64(x)		x##l
+#elif (SIZEOF_LONG_LONG == 8)
+#	define	SF_PLATFORM_S64(x)		x##ll
+#elif COMPILER_IS_GCC
+#	define	SF_PLATFORM_S64(x)		x##ll
+#elif OS_IS_WIN32
+#	define	SF_PLATFORM_S64(x)		x##I64
+#else
+#	error "Don't know how to define a 64 bit integer constant."
+#endif
+
+
+
+/*
+** Inspiration : http://sourcefrog.net/weblog/software/languages/C/unused.html
+*/
+#ifdef UNUSED
+#elif defined (__GNUC__)
+#	define UNUSED(x) UNUSED_ ## x __attribute__ ((unused))
+#elif defined (__LCLINT__)
+#	define UNUSED(x) /*@unused@*/ x
+#else
+#	define UNUSED(x) x
+#endif
+
+#ifdef __GNUC__
+#	define WARN_UNUSED	__attribute__ ((warn_unused_result))
+#else
+#	define WARN_UNUSED
+#endif
+
+#define	SF_BUFFER_LEN			(8192*2)
+#define	SF_FILENAME_LEN			(512)
+#define SF_SYSERR_LEN			(256)
+#define SF_MAX_STRINGS			(32)
+#define SF_STR_BUFFER_LEN		(8192)
+#define	SF_HEADER_LEN			(4100 + SF_STR_BUFFER_LEN)
+
+#define	PSF_SEEK_ERROR			((sf_count_t) -1)
+
+
+#define	BITWIDTH2BYTES(x)	(((x) + 7) / 8)
+
+/*	For some reason sizeof returns an unsigned  value which causes
+**	a warning when that value is added or subtracted from a signed
+**	value. Use SIGNED_SIZEOF instead.
+*/
+#define		SIGNED_SIZEOF(x)	((int) sizeof (x))
+
+#define		ARRAY_LEN(x)	((int) (sizeof (x) / sizeof ((x) [0])))
+
+#if (COMPILER_IS_GCC == 1)
+#define		SF_MAX(x,y)		({ \
+								typeof (x) sf_max_x1 = (x) ; \
+								typeof (y) sf_max_y1 = (y) ; \
+								(void) (&sf_max_x1 == &sf_max_y1) ; \
+								sf_max_x1 > sf_max_y1 ? sf_max_x1 : sf_max_y1 ; })
+
+#define		SF_MIN(x,y)		({ \
+								typeof (x) sf_min_x2 = (x) ; \
+								typeof (y) sf_min_y2 = (y) ; \
+								(void) (&sf_min_x2 == &sf_min_y2) ; \
+								sf_min_x2 < sf_min_y2 ? sf_min_x2 : sf_min_y2 ; })
+#else
+#define		SF_MAX(a,b)		((a) > (b) ? (a) : (b))
+#define		SF_MIN(a,b)		((a) < (b) ? (a) : (b))
+#endif
+
+
+#define		SF_MAX_CHANNELS	256
+
+/*
+*	Macros for spliting the format file of SF_INFI into contrainer type,
+**	codec type and endian-ness.
+*/
+#define SF_CONTAINER(x)		((x) & SF_FORMAT_TYPEMASK)
+#define SF_CODEC(x)			((x) & SF_FORMAT_SUBMASK)
+#define SF_ENDIAN(x)		((x) & SF_FORMAT_ENDMASK)
+
+
+enum
+{	/* PEAK chunk location. */
+	SF_PEAK_START		= 42,
+	SF_PEAK_END			= 43,
+
+	/* PEAK chunk location. */
+	SF_SCALE_MAX		= 52,
+	SF_SCALE_MIN		= 53,
+
+	/* str_flags values. */
+	SF_STR_ALLOW_START	= 0x0100,
+	SF_STR_ALLOW_END	= 0x0200,
+
+	/* Location of strings. */
+	SF_STR_LOCATE_START	= 0x0400,
+	SF_STR_LOCATE_END	= 0x0800,
+
+	SFD_TYPEMASK		= 0x0FFFFFFF
+} ;
+
+#define		SFM_MASK 	(SFM_READ | SFM_WRITE | SFM_RDWR)
+#define		SFM_UNMASK 	(~SFM_MASK)
+
+/*---------------------------------------------------------------------------------------
+** Formats that may be supported at some time in the future.
+** When support is finalised, these values move to src/sndfile.h.
+*/
+
+enum
+{	/* Work in progress. */
+
+	/* Formats supported read only. */
+	SF_FORMAT_TXW			= 0x4030000,		/* Yamaha TX16 sampler file */
+	SF_FORMAT_DWD			= 0x4040000,		/* DiamondWare Digirized */
+
+	/* Following are detected but not supported. */
+	SF_FORMAT_REX			= 0x40A0000,		/* Propellorheads Rex/Rcy */
+	SF_FORMAT_REX2			= 0x40D0000,		/* Propellorheads Rex2 */
+	SF_FORMAT_KRZ			= 0x40E0000,		/* Kurzweil sampler file */
+	SF_FORMAT_WMA			= 0x4100000,		/* Windows Media Audio. */
+	SF_FORMAT_SHN			= 0x4110000,		/* Shorten. */
+
+	/* Unsupported encodings. */
+	SF_FORMAT_SVX_FIB		= 0x1020, 		/* SVX Fibonacci Delta encoding. */
+	SF_FORMAT_SVX_EXP		= 0x1021, 		/* SVX Exponential Delta encoding. */
+
+	SF_FORMAT_PCM_N			= 0x1030
+} ;
+
+/*---------------------------------------------------------------------------------------
+**	PEAK_CHUNK - This chunk type is common to both AIFF and WAVE files although their
+**	endian encodings are different.
+*/
+
+typedef struct
+{	double		value ;		/* signed value of peak */
+	sf_count_t	position ;	/* the sample frame for the peak */
+} PEAK_POS ;
+
+typedef struct
+{	/* libsndfile internal : write a PEAK chunk at the start or end of the file? */
+	int				peak_loc ;
+
+	/* WAV/AIFF */
+	unsigned int	version ;	/* version of the PEAK chunk */
+	unsigned int	timestamp ;	/* secs since 1/1/1970  */
+
+	/* CAF */
+	unsigned int	edit_number ;
+
+#if HAVE_FLEXIBLE_ARRAY
+	/* the per channel peak info */
+	PEAK_POS		peaks [] ;
+#else
+	/*
+	** This is not ISO compliant C. It works on some compilers which
+	** don't support the ISO standard flexible struct array which is
+	** used above. If your compiler doesn't like this I suggest you find
+	** youself a 1999 ISO C standards compilant compiler. GCC-3.X is
+	** highly recommended.
+	*/
+	PEAK_POS		peaks [0] ;
+#endif
+} PEAK_INFO ;
+
+static inline PEAK_INFO *
+peak_info_calloc (int channels)
+{	return calloc (1, sizeof (PEAK_INFO) + channels * sizeof (PEAK_POS)) ;
+} /* peak_info_calloc */
+
+typedef struct
+{	int		type ;
+	int		flags ;
+	char 	*str ;
+} STR_DATA ;
+
+static inline size_t
+make_size_t (int x)
+{	return (size_t) x ;
+} /* size_t_of_int */
+
+/*
+**	This version of isprint specifically ignores any locale info. Its used for
+**	determining which characters can be printed in things like hexdumps.
+*/
+static inline int
+psf_isprint (int ch)
+{	return (ch >= ' ' && ch <= '~') ;
+} /* psf_isprint */
+
+/*=======================================================================================
+**	SF_PRIVATE stuct - a pointer to this struct is passed back to the caller of the
+**	sf_open_XXXX functions. The caller however has no knowledge of the struct's
+**	contents.
+*/
+
+
+typedef struct
+{	int size ;
+	SF_BROADCAST_INFO binfo ;
+} PSF_BROADCAST_VAR ;
+
+#if SIZEOF_WCHAR_T == 2
+typedef wchar_t	sfwchar_t ;
+#else
+typedef __int16 sfwchar_t ;
+#endif

+
+
+typedef struct
+{
+	union
+	{	char		c [SF_FILENAME_LEN] ;
+		sfwchar_t	wc [SF_FILENAME_LEN] ;
+	} path ;
+
+	union
+	{	char		c [SF_FILENAME_LEN] ;
+		sfwchar_t	wc [SF_FILENAME_LEN] ;
+	} dir ;
+
+	union
+	{	char		c [SF_FILENAME_LEN / 4] ;
+		sfwchar_t	wc [SF_FILENAME_LEN / 4] ;
+	} name ;
+
+#if USE_WINDOWS_API
+	/*
+	**	These fields can only be used in src/file_io.c.
+	**	They are basically the same as a windows file HANDLE.
+	*/
+	void 			*handle, *hsaved ;
+
+	int				use_wchar ;
+#else
+	/* These fields can only be used in src/file_io.c. */
+	int 			filedes, savedes ;
+#endif
+
+	int				do_not_close_descriptor ;
+	int				mode ;			/* Open mode : SFM_READ, SFM_WRITE or SFM_RDWR. */
+} PSF_FILE ;
+
+
+typedef struct sf_private_tag
+{
+	/* Canary in a coal mine. */
+	union
+	{	/* Place a double here to encourage double alignment. */
+		double d [2] ;
+		char c [16] ;
+		} canary ;
+
+	/* Force the compiler to double align the start of buffer. */
+	union
+	{	double			dbuf	[SF_BUFFER_LEN / sizeof (double)] ;
+#if (defined (SIZEOF_INT64_T) && (SIZEOF_INT64_T == 8))
+		int64_t			lbuf	[SF_BUFFER_LEN / sizeof (int64_t)] ;
+#else
+		long			lbuf	[SF_BUFFER_LEN / sizeof (double)] ;
+#endif
+		float			fbuf	[SF_BUFFER_LEN / sizeof (float)] ;
+		int				ibuf	[SF_BUFFER_LEN / sizeof (int)] ;
+		short			sbuf	[SF_BUFFER_LEN / sizeof (short)] ;
+		char			cbuf	[SF_BUFFER_LEN / sizeof (char)] ;
+		signed char		scbuf	[SF_BUFFER_LEN / sizeof (signed char)] ;
+		unsigned char	ucbuf	[SF_BUFFER_LEN / sizeof (signed char)] ;
+		} u ;
+
+
+	PSF_FILE		file, rsrc ;
+
+	char			syserr		[SF_SYSERR_LEN] ;
+
+	/* logbuffer and logindex should only be changed within the logging functions
+	** of common.c
+	*/
+	char			logbuffer	[SF_BUFFER_LEN] ;
+	unsigned char	header		[SF_HEADER_LEN] ; /* Must be unsigned */
+	int				rwf_endian ;	/* Header endian-ness flag. */
+
+	/* Storage and housekeeping data for adding/reading strings from
+	** sound files.
+	*/
+	STR_DATA		strings [SF_MAX_STRINGS] ;
+	char			str_storage [SF_STR_BUFFER_LEN] ;
+	char			*str_end ;
+	int				str_flags ;
+
+	/* Guard value. If this changes the buffers above have overflowed. */
+	int				Magick ;
+
+	unsigned		unique_id ;
+
+	/* Index variables for maintaining logbuffer and header above. */
+	int				logindex ;
+	int				headindex, headend ;
+	int				has_text ;
+
+	int				error ;
+
+	int				endian ;		/* File endianness : SF_ENDIAN_LITTLE or SF_ENDIAN_BIG. */
+	int				data_endswap ;	/* Need to endswap data? */
+
+	/*
+	** Maximum float value for calculating the multiplier for
+	** float/double to short/int conversions.
+	*/
+	int				float_int_mult ;
+	float			float_max ;
+
+	int				scale_int_float ;
+
+	/* Vairables for handling pipes. */
+	int				is_pipe ;		/* True if file is a pipe. */
+	sf_count_t		pipeoffset ;	/* Number of bytes read from a pipe. */
+
+	/* True if clipping must be performed on float->int conversions. */
+	int				add_clipping ;
+
+	SF_INFO			sf ;
+
+	int				have_written ;	/* Has a single write been done to the file? */
+	PEAK_INFO		*peak_info ;
+
+	/* Loop Info */
+	SF_LOOP_INFO	*loop_info ;
+	SF_INSTRUMENT	*instrument ;
+
+	/* Broadcast (EBU) Info */
+	PSF_BROADCAST_VAR *broadcast_var ;
+
+	/* Channel map data (if present) : an array of ints. */
+	int				*channel_map ;
+
+	sf_count_t		filelength ;	/* Overall length of (embedded) file. */
+	sf_count_t		fileoffset ;	/* Offset in number of bytes from beginning of file. */
+
+	sf_count_t		rsrclength ;	/* Length of the resource fork (if it exists). */
+
+	sf_count_t		dataoffset ;	/* Offset in number of bytes from beginning of file. */
+	sf_count_t		datalength ;	/* Length in bytes of the audio data. */
+	sf_count_t		dataend ;		/* Offset to file tailer. */
+
+	int				blockwidth ;	/* Size in bytes of one set of interleaved samples. */
+	int				bytewidth ;		/* Size in bytes of one sample (one channel). */
+
+	void			*dither ;
+	void			*interleave ;
+
+	int				last_op ;		/* Last operation; either SFM_READ or SFM_WRITE */
+	sf_count_t		read_current ;
+	sf_count_t		write_current ;
+
+	void			*container_data ;	/*	This is a pointer to dynamically allocated file
+										**	container format specific data.
+										*/
+
+	void			*codec_data ;		/*	This is a pointer to dynamically allocated file
+										**	codec format specific data.
+										*/
+
+	SF_DITHER_INFO	write_dither ;
+	SF_DITHER_INFO	read_dither ;
+
+	int				norm_double ;
+	int				norm_float ;
+
+	int				auto_header ;
+
+	int				ieee_replace ;
+
+	/* A set of file specific function pointers */
+	sf_count_t		(*read_short)	(struct sf_private_tag*, short *ptr, sf_count_t len) ;
+	sf_count_t		(*read_int)		(struct sf_private_tag*, int *ptr, sf_count_t len) ;
+	sf_count_t		(*read_float)	(struct sf_private_tag*, float *ptr, sf_count_t len) ;
+	sf_count_t		(*read_double)	(struct sf_private_tag*, double *ptr, sf_count_t len) ;
+
+	sf_count_t		(*write_short)	(struct sf_private_tag*, const short *ptr, sf_count_t len) ;
+	sf_count_t		(*write_int)	(struct sf_private_tag*, const int *ptr, sf_count_t len) ;
+	sf_count_t		(*write_float)	(struct sf_private_tag*, const float *ptr, sf_count_t len) ;
+	sf_count_t		(*write_double)	(struct sf_private_tag*, const double *ptr, sf_count_t len) ;
+
+	sf_count_t		(*seek) 		(struct sf_private_tag*, int mode, sf_count_t samples_from_start) ;
+	int				(*write_header)	(struct sf_private_tag*, int calc_length) ;
+	int				(*command)		(struct sf_private_tag*, int command, void *data, int datasize) ;
+
+	/*
+	**	Separate close functions for the codec and the container.
+	**	The codec close function is always called first.
+	*/
+	int				(*codec_close)		(struct sf_private_tag*) ;
+	int				(*container_close)	(struct sf_private_tag*) ;
+
+	char			*format_desc ;
+
+	/* Virtual I/O functions. */
+	int					virtual_io ;
+	SF_VIRTUAL_IO		vio ;
+	void				*vio_user_data ;
+} SF_PRIVATE ;
+
+
+
+enum
+{	SFE_NO_ERROR				= SF_ERR_NO_ERROR,
+	SFE_BAD_OPEN_FORMAT			= SF_ERR_UNRECOGNISED_FORMAT,
+	SFE_SYSTEM					= SF_ERR_SYSTEM,
+	SFE_MALFORMED_FILE			= SF_ERR_MALFORMED_FILE,
+	SFE_UNSUPPORTED_ENCODING	= SF_ERR_UNSUPPORTED_ENCODING,
+
+	SFE_ZERO_MAJOR_FORMAT,
+	SFE_ZERO_MINOR_FORMAT,
+	SFE_BAD_FILE,
+	SFE_BAD_FILE_READ,
+	SFE_OPEN_FAILED,
+	SFE_BAD_SNDFILE_PTR,
+	SFE_BAD_SF_INFO_PTR,
+	SFE_BAD_SF_INCOMPLETE,
+	SFE_BAD_FILE_PTR,
+	SFE_BAD_INT_PTR,
+	SFE_BAD_STAT_SIZE,
+	SFE_MALLOC_FAILED,
+	SFE_UNIMPLEMENTED,
+	SFE_BAD_READ_ALIGN,
+	SFE_BAD_WRITE_ALIGN,
+	SFE_UNKNOWN_FORMAT,
+	SFE_NOT_READMODE,
+	SFE_NOT_WRITEMODE,
+	SFE_BAD_MODE_RW,
+	SFE_BAD_SF_INFO,
+	SFE_BAD_OFFSET,
+	SFE_NO_EMBED_SUPPORT,
+	SFE_NO_EMBEDDED_RDWR,
+	SFE_NO_PIPE_WRITE,
+
+	SFE_INTERNAL,
+	SFE_BAD_COMMAND_PARAM,
+	SFE_BAD_ENDIAN,
+	SFE_CHANNEL_COUNT_ZERO,
+	SFE_CHANNEL_COUNT,
+
+	SFE_BAD_VIRTUAL_IO,
+
+	SFE_INTERLEAVE_MODE,
+	SFE_INTERLEAVE_SEEK,
+	SFE_INTERLEAVE_READ,
+
+	SFE_BAD_SEEK,
+	SFE_NOT_SEEKABLE,
+	SFE_AMBIGUOUS_SEEK,
+	SFE_WRONG_SEEK,
+	SFE_SEEK_FAILED,
+
+	SFE_BAD_OPEN_MODE,
+	SFE_OPEN_PIPE_RDWR,
+	SFE_RDWR_POSITION,
+	SFE_RDWR_BAD_HEADER,
+	SFE_CMD_HAS_DATA,
+	SFE_BAD_BROADCAST_INFO_SIZE,
+
+	SFE_STR_NO_SUPPORT,
+	SFE_STR_NOT_WRITE,
+	SFE_STR_MAX_DATA,
+	SFE_STR_MAX_COUNT,
+	SFE_STR_BAD_TYPE,
+	SFE_STR_NO_ADD_END,
+	SFE_STR_BAD_STRING,
+	SFE_STR_WEIRD,
+
+	SFE_WAV_NO_RIFF,
+	SFE_WAV_NO_WAVE,
+	SFE_WAV_NO_FMT,
+	SFE_WAV_BAD_FMT,
+	SFE_WAV_FMT_SHORT,
+	SFE_WAV_BAD_FACT,
+	SFE_WAV_BAD_PEAK,
+	SFE_WAV_PEAK_B4_FMT,
+	SFE_WAV_BAD_FORMAT,
+	SFE_WAV_BAD_BLOCKALIGN,
+	SFE_WAV_NO_DATA,
+	SFE_WAV_BAD_LIST,
+	SFE_WAV_ADPCM_NOT4BIT,
+	SFE_WAV_ADPCM_CHANNELS,
+	SFE_WAV_GSM610_FORMAT,
+	SFE_WAV_UNKNOWN_CHUNK,
+	SFE_WAV_WVPK_DATA,
+
+	SFE_AIFF_NO_FORM,
+	SFE_AIFF_AIFF_NO_FORM,
+	SFE_AIFF_COMM_NO_FORM,
+	SFE_AIFF_SSND_NO_COMM,
+	SFE_AIFF_UNKNOWN_CHUNK,
+	SFE_AIFF_COMM_CHUNK_SIZE,
+	SFE_AIFF_BAD_COMM_CHUNK,
+	SFE_AIFF_PEAK_B4_COMM,
+	SFE_AIFF_BAD_PEAK,
+	SFE_AIFF_NO_SSND,
+	SFE_AIFF_NO_DATA,
+	SFE_AIFF_RW_SSND_NOT_LAST,
+
+	SFE_AU_UNKNOWN_FORMAT,
+	SFE_AU_NO_DOTSND,
+	SFE_AU_EMBED_BAD_LEN,
+
+	SFE_RAW_READ_BAD_SPEC,
+	SFE_RAW_BAD_BITWIDTH,
+	SFE_RAW_BAD_FORMAT,
+
+	SFE_PAF_NO_MARKER,
+	SFE_PAF_VERSION,
+	SFE_PAF_UNKNOWN_FORMAT,
+	SFE_PAF_SHORT_HEADER,
+
+	SFE_SVX_NO_FORM,
+	SFE_SVX_NO_BODY,
+	SFE_SVX_NO_DATA,
+	SFE_SVX_BAD_COMP,
+	SFE_SVX_BAD_NAME_LENGTH,
+
+	SFE_NIST_BAD_HEADER,
+	SFE_NIST_CRLF_CONVERISON,
+	SFE_NIST_BAD_ENCODING,
+
+	SFE_VOC_NO_CREATIVE,
+	SFE_VOC_BAD_FORMAT,
+	SFE_VOC_BAD_VERSION,
+	SFE_VOC_BAD_MARKER,
+	SFE_VOC_BAD_SECTIONS,
+	SFE_VOC_MULTI_SAMPLERATE,
+	SFE_VOC_MULTI_SECTION,
+	SFE_VOC_MULTI_PARAM,
+	SFE_VOC_SECTION_COUNT,
+	SFE_VOC_NO_PIPE,
+
+	SFE_IRCAM_NO_MARKER,
+	SFE_IRCAM_BAD_CHANNELS,
+	SFE_IRCAM_UNKNOWN_FORMAT,
+
+	SFE_W64_64_BIT,
+	SFE_W64_NO_RIFF,
+	SFE_W64_NO_WAVE,
+	SFE_W64_NO_DATA,
+	SFE_W64_ADPCM_NOT4BIT,
+	SFE_W64_ADPCM_CHANNELS,
+	SFE_W64_GSM610_FORMAT,
+
+	SFE_MAT4_BAD_NAME,
+	SFE_MAT4_NO_SAMPLERATE,
+
+	SFE_MAT5_BAD_ENDIAN,
+	SFE_MAT5_NO_BLOCK,

+	SFE_MAT5_SAMPLE_RATE,
+
+	SFE_PVF_NO_PVF1,
+	SFE_PVF_BAD_HEADER,
+	SFE_PVF_BAD_BITWIDTH,
+
+	SFE_DWVW_BAD_BITWIDTH,
+	SFE_G72X_NOT_MONO,
+
+	SFE_XI_BAD_HEADER,
+	SFE_XI_EXCESS_SAMPLES,
+	SFE_XI_NO_PIPE,
+
+	SFE_HTK_NO_PIPE,
+
+	SFE_SDS_NOT_SDS,
+	SFE_SDS_BAD_BIT_WIDTH,
+
+	SFE_SD2_FD_DISALLOWED,
+	SFE_SD2_BAD_DATA_OFFSET,
+	SFE_SD2_BAD_MAP_OFFSET,
+	SFE_SD2_BAD_DATA_LENGTH,
+	SFE_SD2_BAD_MAP_LENGTH,
+	SFE_SD2_BAD_RSRC,
+	SFE_SD2_BAD_SAMPLE_SIZE,
+
+	SFE_FLAC_BAD_HEADER,
+	SFE_FLAC_NEW_DECODER,
+	SFE_FLAC_INIT_DECODER,
+	SFE_FLAC_LOST_SYNC,
+	SFE_FLAC_BAD_SAMPLE_RATE,
+	SFE_FLAC_UNKOWN_ERROR,
+
+	SFE_WVE_NOT_WVE,
+	SFE_WVE_NO_PIPE,
+
+	SFE_VORBIS_ENCODER_BUG,
+
+	SFE_RF64_NOT_RF64,
+
+	SFE_MAX_ERROR			/* This must be last in list. */
+} ;
+
+int subformat_to_bytewidth (int format) ;
+int s_bitwidth_to_subformat (int bits) ;
+int u_bitwidth_to_subformat (int bits) ;
+
+/*  Functions for reading and writing floats and doubles on processors
+**	with non-IEEE floats/doubles.
+*/
+float	float32_be_read		(unsigned char *cptr) ;
+float	float32_le_read		(unsigned char *cptr) ;
+void	float32_be_write	(float in, unsigned char *out) ;
+void	float32_le_write	(float in, unsigned char *out) ;
+
+double	double64_be_read	(unsigned char *cptr) ;
+double	double64_le_read	(unsigned char *cptr) ;
+void	double64_be_write	(double in, unsigned char *out) ;
+void	double64_le_write	(double in, unsigned char *out) ;
+
+/* Functions for writing to the internal logging buffer. */
+
+void	psf_log_printf		(SF_PRIVATE *psf, const char *format, ...) ;
+void	psf_log_SF_INFO 	(SF_PRIVATE *psf) ;
+
+int	psf_rand_int32 (void) ;
+
+void append_snprintf (char * dest, size_t maxlen, const char * fmt, ...) ;
+
+/* Functions used when writing file headers. */
+
+int		psf_binheader_writef	(SF_PRIVATE *psf, const char *format, ...) ;
+void	psf_asciiheader_printf	(SF_PRIVATE *psf, const char *format, ...) ;
+
+/* Functions used when reading file headers. */
+
+int		psf_binheader_readf	(SF_PRIVATE *psf, char const *format, ...) ;
+
+/* Functions used in the write function for updating the peak chunk. */
+
+void	peak_update_short	(SF_PRIVATE *psf, short *ptr, size_t items) ;
+void	peak_update_int		(SF_PRIVATE *psf, int *ptr, size_t items) ;
+void	peak_update_double	(SF_PRIVATE *psf, double *ptr, size_t items) ;
+
+/* Functions defined in command.c. */
+
+int		psf_get_format_simple_count	(void) ;
+int		psf_get_format_simple		(SF_FORMAT_INFO *data) ;
+
+int		psf_get_format_info			(SF_FORMAT_INFO *data) ;
+
+int		psf_get_format_major_count	(void) ;
+int		psf_get_format_major		(SF_FORMAT_INFO *data) ;
+
+int		psf_get_format_subtype_count	(void) ;
+int		psf_get_format_subtype		(SF_FORMAT_INFO *data) ;
+
+void	psf_generate_format_desc (SF_PRIVATE *psf) ;
+
+double	psf_calc_signal_max			(SF_PRIVATE *psf, int normalize) ;
+int		psf_calc_max_all_channels	(SF_PRIVATE *psf, double *peaks, int normalize) ;
+
+int		psf_get_signal_max			(SF_PRIVATE *psf, double *peak) ;
+int		psf_get_max_all_channels	(SF_PRIVATE *psf, double *peaks) ;
+
+/* Functions in strings.c. */
+
+const char* psf_get_string (SF_PRIVATE *psf, int str_type) ;
+int psf_set_string (SF_PRIVATE *psf, int str_type, const char *str) ;
+int psf_store_string (SF_PRIVATE *psf, int str_type, const char *str) ;
+int psf_location_string_count (const SF_PRIVATE * psf, int location) ;
+
+/* Default seek function. Use for PCM and float encoded data. */
+sf_count_t	psf_default_seek (SF_PRIVATE *psf, int mode, sf_count_t samples_from_start) ;
+
+int macos_guess_file_type (SF_PRIVATE *psf, const char *filename) ;
+
+/*------------------------------------------------------------------------------------
+**	File I/O functions which will allow access to large files (> 2 Gig) on
+**	some 32 bit OSes. Implementation in file_io.c.
+*/
+
+int psf_fopen (SF_PRIVATE *psf) ;
+int psf_set_stdio (SF_PRIVATE *psf) ;
+int psf_file_valid (SF_PRIVATE *psf) ;
+void psf_set_file (SF_PRIVATE *psf, int fd) ;
+void psf_init_files (SF_PRIVATE *psf) ;
+void psf_use_rsrc (SF_PRIVATE *psf, int on_off) ;
+
+SNDFILE * psf_open_file (SF_PRIVATE *psf, SF_INFO *sfinfo) ;
+
+sf_count_t psf_fseek (SF_PRIVATE *psf, sf_count_t offset, int whence) ;
+sf_count_t psf_fread (void *ptr, sf_count_t bytes, sf_count_t count, SF_PRIVATE *psf) ;
+sf_count_t psf_fwrite (const void *ptr, sf_count_t bytes, sf_count_t count, SF_PRIVATE *psf) ;
+sf_count_t psf_fgets (char *buffer, sf_count_t bufsize, SF_PRIVATE *psf) ;
+sf_count_t psf_ftell (SF_PRIVATE *psf) ;
+sf_count_t psf_get_filelen (SF_PRIVATE *psf) ;
+
+void psf_fsync (SF_PRIVATE *psf) ;
+
+int psf_is_pipe (SF_PRIVATE *psf) ;
+
+int psf_ftruncate (SF_PRIVATE *psf, sf_count_t len) ;
+int psf_fclose (SF_PRIVATE *psf) ;
+
+/* Open and close the resource fork of a file. */
+int psf_open_rsrc (SF_PRIVATE *psf) ;
+int psf_close_rsrc (SF_PRIVATE *psf) ;
+
+/*
+void psf_fclearerr (SF_PRIVATE *psf) ;
+int psf_ferror (SF_PRIVATE *psf) ;
+*/
+
+/*------------------------------------------------------------------------------------
+** Functions for reading and writing different file formats.
+*/
+
+int		aiff_open	(SF_PRIVATE *psf) ;
+int		au_open		(SF_PRIVATE *psf) ;
+int		avr_open	(SF_PRIVATE *psf) ;
+int		htk_open	(SF_PRIVATE *psf) ;
+int		ircam_open	(SF_PRIVATE *psf) ;
+int		mat4_open	(SF_PRIVATE *psf) ;
+int		mat5_open	(SF_PRIVATE *psf) ;
+int		nist_open	(SF_PRIVATE *psf) ;
+int		paf_open	(SF_PRIVATE *psf) ;
+int		pvf_open	(SF_PRIVATE *psf) ;
+int		raw_open	(SF_PRIVATE *psf) ;
+int		sd2_open	(SF_PRIVATE *psf) ;
+int		sds_open	(SF_PRIVATE *psf) ;
+int		svx_open	(SF_PRIVATE *psf) ;
+int		voc_open	(SF_PRIVATE *psf) ;
+int		w64_open	(SF_PRIVATE *psf) ;
+int		wav_open	(SF_PRIVATE *psf) ;
+int		xi_open		(SF_PRIVATE *psf) ;
+int		flac_open	(SF_PRIVATE *psf) ;
+int		caf_open	(SF_PRIVATE *psf) ;
+int		mpc2k_open	(SF_PRIVATE *psf) ;
+int		rf64_open	(SF_PRIVATE *psf) ;
+
+/* In progress. Do not currently work. */
+
+int		mpeg_open	(SF_PRIVATE *psf) ;
+int		ogg_open	(SF_PRIVATE *psf) ;
+int		rx2_open	(SF_PRIVATE *psf) ;
+int		txw_open	(SF_PRIVATE *psf) ;
+int		wve_open	(SF_PRIVATE *psf) ;
+int		dwd_open	(SF_PRIVATE *psf) ;
+
+int		macbinary3_open (SF_PRIVATE *psf) ;
+
+/*------------------------------------------------------------------------------------
+**	Init functions for a number of common data encodings.
+*/
+
+int		pcm_init		(SF_PRIVATE *psf) ;
+int		ulaw_init		(SF_PRIVATE *psf) ;
+int		alaw_init		(SF_PRIVATE *psf) ;
+int		float32_init	(SF_PRIVATE *psf) ;
+int		double64_init	(SF_PRIVATE *psf) ;
+int		dwvw_init		(SF_PRIVATE *psf, int bitwidth) ;
+int		gsm610_init		(SF_PRIVATE *psf) ;
+int		vox_adpcm_init	(SF_PRIVATE *psf) ;
+int		flac_init		(SF_PRIVATE *psf) ;
+int		g72x_init 		(SF_PRIVATE * psf) ;
+
+int 	dither_init		(SF_PRIVATE *psf, int mode) ;
+
+int		wav_w64_ima_init (SF_PRIVATE *psf, int blockalign, int samplesperblock) ;
+int		wav_w64_msadpcm_init (SF_PRIVATE *psf, int blockalign, int samplesperblock) ;
+
+int		aiff_ima_init (SF_PRIVATE *psf, int blockalign, int samplesperblock) ;
+
+int		interleave_init (SF_PRIVATE *psf) ;
+
+/*------------------------------------------------------------------------------------
+** Chunk logging functions.
+*/
+
+typedef struct
+{	struct
+	{	int chunk ;
+		sf_count_t offset ;
+		sf_count_t len ;
+	} l [100] ;
+
+	int count ;
+} PRIV_CHUNK4 ;
+
+void pchk4_store (PRIV_CHUNK4 * pchk, int marker, sf_count_t offset, sf_count_t len) ;
+int pchk4_find (PRIV_CHUNK4 * pchk, int marker) ;
+
+/*------------------------------------------------------------------------------------
+** Other helper functions.
+*/
+
+void	*psf_memset (void *s, int c, sf_count_t n) ;
+
+SF_INSTRUMENT * psf_instrument_alloc (void) ;
+
+void	psf_sanitize_string (char * cptr, int len) ;
+
+/* Generate the current date as a string. */
+void	psf_get_date_str (char *str, int maxlen) ;
+
+PSF_BROADCAST_VAR* broadcast_var_alloc (size_t datasize) ;
+int		broadcast_var_set (SF_PRIVATE *psf, const SF_BROADCAST_INFO * data, size_t datasize) ;
+int		broadcast_var_get (SF_PRIVATE *psf, SF_BROADCAST_INFO * data, size_t datasize) ;
+
+
+typedef struct
+{	int channels ;
+	int endianness ;
+} AUDIO_DETECT ;
+
+int audio_detect (SF_PRIVATE * psf, AUDIO_DETECT *ad, const unsigned char * data, int datalen) ;
+
+
+/*------------------------------------------------------------------------------------
+** Helper/debug functions.
+*/
+
+void	psf_hexdump (const void *ptr, int len) ;
+
+const char * str_of_major_format (int format) ;
+const char * str_of_minor_format (int format) ;
+const char * str_of_open_mode (int mode) ;
+const char * str_of_endianness (int end) ;
+
+/*------------------------------------------------------------------------------------
+** Extra commands for sf_command(). Not for public use yet.
+*/
+
+enum
+{	SFC_TEST_AIFF_ADD_INST_CHUNK	= 0x2000,
+	SFC_TEST_WAV_ADD_INFO_CHUNK		= 0x2010
+} ;
+
+/*
+** Maybe, one day, make these functions or something like them, public.
+**
+** Buffer to buffer dithering. Pointer in and out are allowed to point
+** to the same buffer for in-place dithering.
+*/
+
+#if 0
+int sf_dither_short		(const SF_DITHER_INFO *dither, const short *in, short *out, int count) ;
+int sf_dither_int		(const SF_DITHER_INFO *dither, const int *in, int *out, int count) ;
+int sf_dither_float		(const SF_DITHER_INFO *dither, const float *in, float *out, int count) ;
+int sf_dither_double	(const SF_DITHER_INFO *dither, const double *in, double *out, int count) ;
+#endif
+
+#endif /* SNDFILE_COMMON_H */
+
diff -Nru libsndfile-1.0.21.orig/src/config.h libsndfile-1.0.21/src/config.h
--- libsndfile-1.0.21.orig/src/config.h	Thu Jan  1 02:00:00 1970
+++ libsndfile-1.0.21/src/config.h	Wed Jul  7 17:50:42 2010
@@ -0,0 +1,256 @@
+/* src/config.h.in.  Generated from configure.ac by autoheader.  */
+
+/* Set to 1 if the compile is GNU GCC. */
+#undef COMPILER_IS_GCC
+
+/* Target processor clips on negative float to int conversion. */
+#define CPU_CLIPS_NEGATIVE 1
+
+/* Target processor clips on positive float to int conversion. */
+#define CPU_CLIPS_POSITIVE 1
+
+/* Target processor is big endian. */
+#define CPU_IS_BIG_ENDIAN 0
+
+/* Target processor is little endian. */
+#define CPU_IS_LITTLE_ENDIAN 1
+
+/* Set to 1 to enable experimental code. */
+#define ENABLE_EXPERIMENTAL_CODE 1
+
+/* Major version of GCC or 3 otherwise. */
+#undef GCC_MAJOR_VERSION
+
+/* Define to 1 if you have the <alsa/asoundlib.h> header file. */
+#undef HAVE_ALSA_ASOUNDLIB_H
+
+/* Define to 1 if you have the <byteswap.h> header file. */
+#undef HAVE_BYTESWAP_H
+
+/* Define to 1 if you have the `calloc' function. */
+#undef HAVE_CALLOC
+
+/* Define to 1 if you have the `ceil' function. */
+#undef HAVE_CEIL
+
+/* Set to 1 if S_IRGRP is defined. */
+#undef HAVE_DECL_S_IRGRP
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#undef HAVE_DLFCN_H
+
+/* Define to 1 if you have the <endian.h> header file. */
+#define HAVE_ENDIAN_H
+
+/* Define to 1 if you have libflac 1.1.1 */
+#undef HAVE_FLAC_1_1_1
+
+/* Define to 1 if you have the <FLAC/all.h> header file. */
+#undef HAVE_FLAC_ALL_H
+
+/* Set to 1 if the compile supports the struct hack. */
+#undef HAVE_FLEXIBLE_ARRAY
+
+/* Define to 1 if you have the `floor' function. */
+#undef HAVE_FLOOR
+
+/* Define to 1 if you have the `fmod' function. */
+#undef HAVE_FMOD
+
+/* Define to 1 if you have the `free' function. */
+#undef HAVE_FREE
+
+/* Define to 1 if you have the `fstat' function. */
+#undef HAVE_FSTAT
+
+/* Define to 1 if you have the `fsync' function. */
+#undef HAVE_FSYNC
+
+/* Define to 1 if you have the `ftruncate' function. */
+#undef HAVE_FTRUNCATE
+
+/* Define to 1 if you have the `getpagesize' function. */
+#undef HAVE_GETPAGESIZE
+
+/* Define to 1 if you have the `gmtime' function. */
+#undef HAVE_GMTIME
+
+/* Define to 1 if you have the `gmtime_r' function. */
+#undef HAVE_GMTIME_R
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#undef HAVE_INTTYPES_H
+
+/* Define to 1 if you have the `m' library (-lm). */
+#undef HAVE_LIBM
+
+/* Define to 1 if you have the <locale.h> header file. */
+#undef HAVE_LOCALE_H
+
+/* Define if you have C99's lrint function. */
+#undef HAVE_LRINT
+
+/* Define if you have C99's lrintf function. */
+#undef HAVE_LRINTF
+
+/* Define to 1 if you have the `lseek' function. */
+#undef HAVE_LSEEK
+
+/* Define to 1 if you have the `malloc' function. */
+#define HAVE_MALLOC 1
+
+/* Define to 1 if you have the <memory.h> header file. */
+#undef HAVE_MEMORY_H
+
+/* Define to 1 if you have the `mmap' function. */
+#undef HAVE_MMAP
+
+/* Define to 1 if you have the `open' function. */
+#undef HAVE_OPEN
+
+/* Define to 1 if you have the `pread' function. */
+#undef HAVE_PREAD
+
+/* Define to 1 if you have the `pwrite' function. */
+#undef HAVE_PWRITE
+
+/* Define to 1 if you have the `read' function. */
+#undef HAVE_READ
+
+/* Define to 1 if you have the `realloc' function. */
+#undef HAVE_REALLOC
+
+/* Define to 1 if you have the `setlocale' function. */
+#undef HAVE_SETLOCALE
+
+/* Define to 1 if you have the `snprintf' function. */
+#undef HAVE_SNPRINTF
+
+/* Set to 1 if you have libsqlite3. */
+#undef HAVE_SQLITE3
+
+/* Define to 1 if the system has the type `ssize_t'. */
+#undef HAVE_SSIZE_T
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#undef HAVE_STDINT_H
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#undef HAVE_STDLIB_H
+
+/* Define to 1 if you have the <strings.h> header file. */
+#undef HAVE_STRINGS_H
+
+/* Define to 1 if you have the <string.h> header file. */
+#undef HAVE_STRING_H
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#undef HAVE_SYS_STAT_H
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#undef HAVE_SYS_TYPES_H
+
+/* Define to 1 if you have <sys/wait.h> that is POSIX.1 compatible. */
+#undef HAVE_SYS_WAIT_H
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#undef HAVE_UNISTD_H
+
+/* Define to 1 if you have the `vsnprintf' function. */
+#undef HAVE_VSNPRINTF
+
+/* Define to 1 if you have the `write' function. */
+#undef HAVE_WRITE
+
+/* Set to 1 if compiling for MacOSX */
+#undef OS_IS_MACOSX
+
+/* Set to 1 if compiling for Win32 */
+#define	OS_IS_WIN32 1
+
+/* Name of package */
+#define PACKAGE "libsndfile"
+
+/* Define to the address where bug reports for this package should be sent. */
+#undef PACKAGE_BUGREPORT
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "libsndfile"
+
+/* Define to the full name and version of this package. */
+#undef PACKAGE_STRING
+
+/* Define to the one symbol short name of this package. */
+#undef PACKAGE_TARNAME
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "1.0.17-msvc"
+
+/* Set to maximum allowed value of sf_count_t type. */
+#undef SF_COUNT_MAX
+
+/* The size of `double', as computed by sizeof. */
+#undef SIZEOF_DOUBLE
+
+/* The size of `float', as computed by sizeof. */
+#undef SIZEOF_FLOAT
+
+/* The size of `int', as computed by sizeof. */
+#undef SIZEOF_INT
+
+/* The size of `int64_t', as computed by sizeof. */
+#undef SIZEOF_INT64_T
+
+/* The size of `loff_t', as computed by sizeof. */
+#undef SIZEOF_LOFF_T
+
+/* The size of `long', as computed by sizeof. */
+#undef SIZEOF_LONG
+
+/* The size of `long long', as computed by sizeof. */
+#undef SIZEOF_LONG_LONG
+
+/* The size of `off64_t', as computed by sizeof. */
+#undef SIZEOF_OFF64_T
+
+/* The size of `off_t', as computed by sizeof. */
+#undef SIZEOF_OFF_T
+
+/* Set to sizeof (long) if unknown. */
+#define SIZEOF_SF_COUNT_T 4
+
+/* The size of `short', as computed by sizeof. */
+#undef SIZEOF_SHORT
+
+/* The size of `size_t', as computed by sizeof. */
+#undef SIZEOF_SIZE_T
+
+/* The size of `ssize_t', as computed by sizeof. */
+#undef SIZEOF_SSIZE_T
+
+/* The size of `void*', as computed by sizeof. */
+#undef SIZEOF_VOIDP
+
+/* Define to 1 if you have the ANSI C header files. */
+#undef STDC_HEADERS
+
+/* Set to long if unknown. */
+#undef TYPEOF_SF_COUNT_T
+
+/* Set to 1 to use the native windows API */
+#define USE_WINDOWS_API 1
+
+/* Version number of package */
+#define VERSION  "1.0.17-msvc"
+
+/* Number of bits in a file offset, on hosts where this is settable. */
+#undef _FILE_OFFSET_BITS
+
+/* Define to make fseeko etc. visible, on some hosts. */
+#undef _LARGEFILE_SOURCE
+
+/* Define for large files, on AIX-style hosts. */
+#undef _LARGE_FILES
+
+#define inline _inline
+
diff -Nru libsndfile-1.0.21.orig/src/config.h.in libsndfile-1.0.21/src/config.h.in
--- libsndfile-1.0.21.orig/src/config.h.in	Sun Dec 13 08:47:06 2009
+++ libsndfile-1.0.21/src/config.h.in	Thu Jan  1 02:00:00 1970
@@ -1,281 +0,0 @@
-/* src/config.h.in.  Generated from configure.ac by autoheader.  */
-
-/* Set to 1 if the compile is GNU GCC. */
-#undef COMPILER_IS_GCC
-
-/* Target processor clips on negative float to int conversion. */
-#undef CPU_CLIPS_NEGATIVE
-
-/* Target processor clips on positive float to int conversion. */
-#undef CPU_CLIPS_POSITIVE
-
-/* Target processor is big endian. */
-#undef CPU_IS_BIG_ENDIAN
-
-/* Target processor is little endian. */
-#undef CPU_IS_LITTLE_ENDIAN
-
-/* Set to 1 to enable experimental code. */
-#undef ENABLE_EXPERIMENTAL_CODE
-
-/* Define to 1 if you have the <alsa/asoundlib.h> header file. */
-#undef HAVE_ALSA_ASOUNDLIB_H
-
-/* Define to 1 if you have the <byteswap.h> header file. */
-#undef HAVE_BYTESWAP_H
-
-/* Define to 1 if you have the `calloc' function. */
-#undef HAVE_CALLOC
-
-/* Define to 1 if you have the `ceil' function. */
-#undef HAVE_CEIL
-
-/* Set to 1 if S_IRGRP is defined. */
-#undef HAVE_DECL_S_IRGRP
-
-/* Define to 1 if you have the <dlfcn.h> header file. */
-#undef HAVE_DLFCN_H
-
-/* Define to 1 if you have the <endian.h> header file. */
-#undef HAVE_ENDIAN_H
-
-/* Will be set to 1 if flac, ogg and vorbis are available. */
-#undef HAVE_EXTERNAL_LIBS
-
-/* Set to 1 if the compile supports the struct hack. */
-#undef HAVE_FLEXIBLE_ARRAY
-
-/* Define to 1 if you have the `floor' function. */
-#undef HAVE_FLOOR
-
-/* Define to 1 if you have the `fmod' function. */
-#undef HAVE_FMOD
-
-/* Define to 1 if you have the `free' function. */
-#undef HAVE_FREE
-
-/* Define to 1 if you have the `fstat' function. */
-#undef HAVE_FSTAT
-
-/* Define to 1 if you have the `fsync' function. */
-#undef HAVE_FSYNC
-
-/* Define to 1 if you have the `ftruncate' function. */
-#undef HAVE_FTRUNCATE
-
-/* Define to 1 if you have the `getpagesize' function. */
-#undef HAVE_GETPAGESIZE
-
-/* Define to 1 if you have the `gettimeofday' function. */
-#undef HAVE_GETTIMEOFDAY
-
-/* Define to 1 if you have the `gmtime' function. */
-#undef HAVE_GMTIME
-
-/* Define to 1 if you have the `gmtime_r' function. */
-#undef HAVE_GMTIME_R
-
-/* Define to 1 if you have the <inttypes.h> header file. */
-#undef HAVE_INTTYPES_H
-
-/* Define to 1 if you have the `m' library (-lm). */
-#undef HAVE_LIBM
-
-/* Define to 1 if you have the <locale.h> header file. */
-#undef HAVE_LOCALE_H
-
-/* Define to 1 if you have the `localtime' function. */
-#undef HAVE_LOCALTIME
-
-/* Define to 1 if you have the `localtime_r' function. */
-#undef HAVE_LOCALTIME_R
-
-/* Define if you have C99's lrint function. */
-#undef HAVE_LRINT
-
-/* Define if you have C99's lrintf function. */
-#undef HAVE_LRINTF
-
-/* Define to 1 if you have the `lseek' function. */
-#undef HAVE_LSEEK
-
-/* Define to 1 if you have the `malloc' function. */
-#undef HAVE_MALLOC
-
-/* Define to 1 if you have the <memory.h> header file. */
-#undef HAVE_MEMORY_H
-
-/* Define to 1 if you have the `mmap' function. */
-#undef HAVE_MMAP
-
-/* Define to 1 if you have the `open' function. */
-#undef HAVE_OPEN
-
-/* Define to 1 if you have the `pread' function. */
-#undef HAVE_PREAD
-
-/* Define to 1 if you have the `pwrite' function. */
-#undef HAVE_PWRITE
-
-/* Define to 1 if you have the `read' function. */
-#undef HAVE_READ
-
-/* Define to 1 if you have the `realloc' function. */
-#undef HAVE_REALLOC
-
-/* Define to 1 if you have the `setlocale' function. */
-#undef HAVE_SETLOCALE
-
-/* Define to 1 if you have the `snprintf' function. */
-#undef HAVE_SNPRINTF
-
-/* Set to 1 if you have libsqlite3. */
-#undef HAVE_SQLITE3
-
-/* Define to 1 if the system has the type `ssize_t'. */
-#undef HAVE_SSIZE_T
-
-/* Define to 1 if you have the <stdint.h> header file. */
-#undef HAVE_STDINT_H
-
-/* Define to 1 if you have the <stdlib.h> header file. */
-#undef HAVE_STDLIB_H
-
-/* Define to 1 if you have the <strings.h> header file. */
-#undef HAVE_STRINGS_H
-
-/* Define to 1 if you have the <string.h> header file. */
-#undef HAVE_STRING_H
-
-/* Define to 1 if you have the <sys/stat.h> header file. */
-#undef HAVE_SYS_STAT_H
-
-/* Define to 1 if you have the <sys/time.h> header file. */
-#undef HAVE_SYS_TIME_H
-
-/* Define to 1 if you have the <sys/types.h> header file. */
-#undef HAVE_SYS_TYPES_H
-
-/* Define to 1 if you have <sys/wait.h> that is POSIX.1 compatible. */
-#undef HAVE_SYS_WAIT_H
-
-/* Define to 1 if you have the <unistd.h> header file. */
-#undef HAVE_UNISTD_H
-
-/* Define to 1 if you have the `vsnprintf' function. */
-#undef HAVE_VSNPRINTF
-
-/* Define to 1 if you have the `write' function. */
-#undef HAVE_WRITE
-
-/* Define to the sub-directory in which libtool stores uninstalled libraries.
-   */
-#undef LT_OBJDIR
-
-/* Define to 1 if your C compiler doesn't accept -c and -o together. */
-#undef NO_MINUS_C_MINUS_O
-
-/* Set to 1 if compiling for MacOSX */
-#undef OS_IS_MACOSX
-
-/* Set to 1 if compiling for Win32 */
-#undef OS_IS_WIN32
-
-/* Name of package */
-#undef PACKAGE
-
-/* Define to the address where bug reports for this package should be sent. */
-#undef PACKAGE_BUGREPORT
-
-/* Define to the full name of this package. */
-#undef PACKAGE_NAME
-
-/* Define to the full name and version of this package. */
-#undef PACKAGE_STRING
-
-/* Define to the one symbol short name of this package. */
-#undef PACKAGE_TARNAME
-
-/* Define to the home page for this package. */
-#undef PACKAGE_URL
-
-/* Define to the version of this package. */
-#undef PACKAGE_VERSION
-
-/* Set to maximum allowed value of sf_count_t type. */
-#undef SF_COUNT_MAX
-
-/* The size of `double', as computed by sizeof. */
-#undef SIZEOF_DOUBLE
-
-/* The size of `float', as computed by sizeof. */
-#undef SIZEOF_FLOAT
-
-/* The size of `int', as computed by sizeof. */
-#undef SIZEOF_INT
-
-/* The size of `int64_t', as computed by sizeof. */
-#undef SIZEOF_INT64_T
-
-/* The size of `loff_t', as computed by sizeof. */
-#undef SIZEOF_LOFF_T
-
-/* The size of `long', as computed by sizeof. */
-#undef SIZEOF_LONG
-
-/* The size of `long long', as computed by sizeof. */
-#undef SIZEOF_LONG_LONG
-
-/* The size of `off64_t', as computed by sizeof. */
-#undef SIZEOF_OFF64_T
-
-/* The size of `off_t', as computed by sizeof. */
-#undef SIZEOF_OFF_T
-
-/* Set to sizeof (long) if unknown. */
-#undef SIZEOF_SF_COUNT_T
-
-/* The size of `short', as computed by sizeof. */
-#undef SIZEOF_SHORT
-
-/* The size of `size_t', as computed by sizeof. */
-#undef SIZEOF_SIZE_T
-
-/* The size of `ssize_t', as computed by sizeof. */
-#undef SIZEOF_SSIZE_T
-
-/* The size of `void*', as computed by sizeof. */
-#undef SIZEOF_VOIDP
-
-/* The size of `wchar_t', as computed by sizeof. */
-#undef SIZEOF_WCHAR_T
-
-/* Define to 1 if you have the ANSI C header files. */
-#undef STDC_HEADERS
-
-/* Set to long if unknown. */
-#undef TYPEOF_SF_COUNT_T
-
-/* Set to 1 to use the native windows API */
-#undef USE_WINDOWS_API
-
-/* Version number of package */
-#undef VERSION
-
-/* Set to 1 if windows DLL is being built. */
-#undef WIN32_TARGET_DLL
-
-/* Target processor is big endian. */
-#undef WORDS_BIGENDIAN
-
-/* Number of bits in a file offset, on hosts where this is settable. */
-#undef _FILE_OFFSET_BITS
-
-/* Define to make fseeko etc. visible, on some hosts. */
-#undef _LARGEFILE_SOURCE
-
-/* Define for large files, on AIX-style hosts. */
-#undef _LARGE_FILES
-
-/* Set to 1 to use C99 printf/snprintf in MinGW. */
-#undef __USE_MINGW_ANSI_STDIO
diff -Nru libsndfile-1.0.21.orig/src/file_io.c libsndfile-1.0.21/src/file_io.c
--- libsndfile-1.0.21.orig/src/file_io.c	Sat Sep 26 15:05:03 2009
+++ libsndfile-1.0.21/src/file_io.c	Wed Jul  7 18:18:08 2010
@@ -55,6 +55,11 @@
 
 #define	SENSIBLE_SIZE	(0x40000000)
 
+#if _WIN32
+#define snprintf _snprintf
+#define ssize_t SSIZE_T
+#endif
+
 /*
 **	Neat solution to the Win32/OS2 binary file flage requirement.
 **	If O_BINARY isn't already defined by the inclusion of the system
diff -Nru libsndfile-1.0.21.orig/src/libsndfile-1.def libsndfile-1.0.21/src/libsndfile-1.def
--- libsndfile-1.0.21.orig/src/libsndfile-1.def	Mon Nov 30 23:31:18 2009
+++ libsndfile-1.0.21/src/libsndfile-1.def	Wed Jul  7 18:45:26 2010
@@ -1,6 +1,6 @@
 ; Auto-generated by create_symbols_file.py
 
-LIBRARY libsndfile-1.dll
+LIBRARY sndfile.dll
 EXPORTS
 
 sf_command           @1
diff -Nru libsndfile-1.0.21.orig/src/libsndfile.rc libsndfile-1.0.21/src/libsndfile.rc
--- libsndfile-1.0.21.orig/src/libsndfile.rc	Thu Jan  1 02:00:00 1970
+++ libsndfile-1.0.21/src/libsndfile.rc	Wed Jul  7 17:50:42 2010
@@ -0,0 +1,32 @@
+#include <winver.h>
+
+VS_VERSION_INFO	VERSIONINFO
+FILEVERSION 	1,0,17
+PRODUCTVERSION	1,0,17
+#ifdef DEBUG
+FILEFLAGS	(VS_FF_DEBUG | VS_FF_PRERELEASE)
+#else
+FILEFLAGS	VS_FF_PRERELEASE
+#endif
+FILEOS		VOS__WINDOWS32
+FILETYPE	VFT_DLL
+FILESUBTYPE	VFT2_UNKNOWN
+BEGIN
+	BLOCK "StringFileInfo"
+	BEGIN 
+		BLOCK "040904E4"
+		BEGIN
+		VALUE "FileDescription",  "sndfile"
+		VALUE "LegalCopyright", "Erik de Castro Lopo <erikd@mega-nerd.com>"
+		VALUE "FileVersion", "1.0.21"
+		VALUE "OriginalFilename", "sndfile.dll"
+		VALUE "Comments", "Compilied using MSVC 2008"
+		END
+	END
+
+	BLOCK "VarFileInfo"
+	BEGIN
+		VALUE "Translation", 0x0409, 0x04E4
+	END
+END
+
diff -Nru libsndfile-1.0.21.orig/src/sndfile.def libsndfile-1.0.21/src/sndfile.def
--- libsndfile-1.0.21.orig/src/sndfile.def	Thu Jan  1 02:00:00 1970
+++ libsndfile-1.0.21/src/sndfile.def	Wed Jul  7 17:50:42 2010
@@ -0,0 +1,39 @@
+; Auto-generated by create_symbols_file.py
+
+LIBRARY sndfile.dll
+EXPORTS
+
+sf_command           @1
+sf_open              @2
+sf_close             @3
+sf_seek              @4
+sf_error             @7
+sf_perror            @8
+sf_error_str         @9
+sf_error_number      @10
+sf_format_check      @11
+sf_read_raw          @16
+sf_readf_short       @17
+sf_readf_int         @18
+sf_readf_float       @19
+sf_readf_double      @20
+sf_read_short        @21
+sf_read_int          @22
+sf_read_float        @23
+sf_read_double       @24
+sf_write_raw         @32
+sf_writef_short      @33
+sf_writef_int        @34
+sf_writef_float      @35
+sf_writef_double     @36
+sf_write_short       @37
+sf_write_int         @38
+sf_write_float       @39
+sf_write_double      @40
+sf_strerror          @50
+sf_get_string        @60
+sf_set_string        @61
+sf_open_fd           @70
+sf_open_virtual      @80
+sf_write_sync        @90
+
diff -Nru libsndfile-1.0.21.orig/src/sndfile.h libsndfile-1.0.21/src/sndfile.h
--- libsndfile-1.0.21.orig/src/sndfile.h	Thu Jan  1 02:00:00 1970
+++ libsndfile-1.0.21/src/sndfile.h	Wed Jul  7 17:50:42 2010
@@ -0,0 +1,663 @@
+/*
+** Copyright (C) 1999-2009 Erik de Castro Lopo <erikd@mega-nerd.com>
+**
+** This program is free software; you can redistribute it and/or modify
+** it under the terms of the GNU Lesser General Public License as published by
+** the Free Software Foundation; either version 2.1 of the License, or
+** (at your option) any later version.
+**
+** This program is distributed in the hope that it will be useful,
+** but WITHOUT ANY WARRANTY; without even the implied warranty of
+** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+** GNU Lesser General Public License for more details.
+**
+** You should have received a copy of the GNU Lesser General Public License
+** along with this program; if not, write to the Free Software
+** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*/
+
+/*
+** sndfile.h -- system-wide definitions
+**
+** API documentation is in the doc/ directory of the source code tarball
+** and at http://www.mega-nerd.com/libsndfile/api.html.
+*/
+
+#ifndef SNDFILE_H
+#define SNDFILE_H
+
+/* This is the version 1.0.X header file. */
+#define	SNDFILE_1
+
+#include <stdio.h>
+#include <sys/types.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif	/* __cplusplus */
+
+/* The following file types can be read and written.
+** A file type would consist of a major type (ie SF_FORMAT_WAV) bitwise
+** ORed with a minor type (ie SF_FORMAT_PCM). SF_FORMAT_TYPEMASK and
+** SF_FORMAT_SUBMASK can be used to separate the major and minor file
+** types.
+*/
+
+enum
+{	/* Major formats. */
+	SF_FORMAT_WAV			= 0x010000,		/* Microsoft WAV format (little endian default). */
+	SF_FORMAT_AIFF			= 0x020000,		/* Apple/SGI AIFF format (big endian). */
+	SF_FORMAT_AU			= 0x030000,		/* Sun/NeXT AU format (big endian). */
+	SF_FORMAT_RAW			= 0x040000,		/* RAW PCM data. */
+	SF_FORMAT_PAF			= 0x050000,		/* Ensoniq PARIS file format. */
+	SF_FORMAT_SVX			= 0x060000,		/* Amiga IFF / SVX8 / SV16 format. */
+	SF_FORMAT_NIST			= 0x070000,		/* Sphere NIST format. */
+	SF_FORMAT_VOC			= 0x080000,		/* VOC files. */
+	SF_FORMAT_IRCAM			= 0x0A0000,		/* Berkeley/IRCAM/CARL */
+	SF_FORMAT_W64			= 0x0B0000,		/* Sonic Foundry's 64 bit RIFF/WAV */
+	SF_FORMAT_MAT4			= 0x0C0000,		/* Matlab (tm) V4.2 / GNU Octave 2.0 */
+	SF_FORMAT_MAT5			= 0x0D0000,		/* Matlab (tm) V5.0 / GNU Octave 2.1 */
+	SF_FORMAT_PVF			= 0x0E0000,		/* Portable Voice Format */
+	SF_FORMAT_XI			= 0x0F0000,		/* Fasttracker 2 Extended Instrument */
+	SF_FORMAT_HTK			= 0x100000,		/* HMM Tool Kit format */
+	SF_FORMAT_SDS			= 0x110000,		/* Midi Sample Dump Standard */
+	SF_FORMAT_AVR			= 0x120000,		/* Audio Visual Research */
+	SF_FORMAT_WAVEX			= 0x130000,		/* MS WAVE with WAVEFORMATEX */
+	SF_FORMAT_SD2			= 0x160000,		/* Sound Designer 2 */
+	SF_FORMAT_FLAC			= 0x170000,		/* FLAC lossless file format */
+	SF_FORMAT_CAF			= 0x180000,		/* Core Audio File format */
+	SF_FORMAT_WVE			= 0x190000,		/* Psion WVE format */
+	SF_FORMAT_OGG			= 0x200000,		/* Xiph OGG container */
+	SF_FORMAT_MPC2K			= 0x210000,		/* Akai MPC 2000 sampler */
+	SF_FORMAT_RF64			= 0x220000,		/* RF64 WAV file */
+
+	/* Subtypes from here on. */
+
+	SF_FORMAT_PCM_S8		= 0x0001,		/* Signed 8 bit data */
+	SF_FORMAT_PCM_16		= 0x0002,		/* Signed 16 bit data */
+	SF_FORMAT_PCM_24		= 0x0003,		/* Signed 24 bit data */
+	SF_FORMAT_PCM_32		= 0x0004,		/* Signed 32 bit data */
+
+	SF_FORMAT_PCM_U8		= 0x0005,		/* Unsigned 8 bit data (WAV and RAW only) */
+
+	SF_FORMAT_FLOAT			= 0x0006,		/* 32 bit float data */
+	SF_FORMAT_DOUBLE		= 0x0007,		/* 64 bit float data */
+
+	SF_FORMAT_ULAW			= 0x0010,		/* U-Law encoded. */
+	SF_FORMAT_ALAW			= 0x0011,		/* A-Law encoded. */
+	SF_FORMAT_IMA_ADPCM		= 0x0012,		/* IMA ADPCM. */
+	SF_FORMAT_MS_ADPCM		= 0x0013,		/* Microsoft ADPCM. */
+
+	SF_FORMAT_GSM610		= 0x0020,		/* GSM 6.10 encoding. */
+	SF_FORMAT_VOX_ADPCM		= 0x0021,		/* OKI / Dialogix ADPCM */
+
+	SF_FORMAT_G721_32		= 0x0030,		/* 32kbs G721 ADPCM encoding. */
+	SF_FORMAT_G723_24		= 0x0031,		/* 24kbs G723 ADPCM encoding. */
+	SF_FORMAT_G723_40		= 0x0032,		/* 40kbs G723 ADPCM encoding. */
+
+	SF_FORMAT_DWVW_12		= 0x0040, 		/* 12 bit Delta Width Variable Word encoding. */
+	SF_FORMAT_DWVW_16		= 0x0041, 		/* 16 bit Delta Width Variable Word encoding. */
+	SF_FORMAT_DWVW_24		= 0x0042, 		/* 24 bit Delta Width Variable Word encoding. */
+	SF_FORMAT_DWVW_N		= 0x0043, 		/* N bit Delta Width Variable Word encoding. */
+
+	SF_FORMAT_DPCM_8		= 0x0050,		/* 8 bit differential PCM (XI only) */
+	SF_FORMAT_DPCM_16		= 0x0051,		/* 16 bit differential PCM (XI only) */
+
+	SF_FORMAT_VORBIS		= 0x0060,		/* Xiph Vorbis encoding. */
+
+	/* Endian-ness options. */
+
+	SF_ENDIAN_FILE			= 0x00000000,	/* Default file endian-ness. */
+	SF_ENDIAN_LITTLE		= 0x10000000,	/* Force little endian-ness. */
+	SF_ENDIAN_BIG			= 0x20000000,	/* Force big endian-ness. */
+	SF_ENDIAN_CPU			= 0x30000000,	/* Force CPU endian-ness. */
+
+	SF_FORMAT_SUBMASK		= 0x0000FFFF,
+	SF_FORMAT_TYPEMASK		= 0x0FFF0000,
+	SF_FORMAT_ENDMASK		= 0x30000000
+} ;
+
+/*
+** The following are the valid command numbers for the sf_command()
+** interface.  The use of these commands is documented in the file
+** command.html in the doc directory of the source code distribution.
+*/
+
+enum
+{	SFC_GET_LIB_VERSION				= 0x1000,
+	SFC_GET_LOG_INFO				= 0x1001,
+	SFC_GET_CURRENT_SF_INFO			= 0x1002,
+
+
+	SFC_GET_NORM_DOUBLE				= 0x1010,
+	SFC_GET_NORM_FLOAT				= 0x1011,
+	SFC_SET_NORM_DOUBLE				= 0x1012,
+	SFC_SET_NORM_FLOAT				= 0x1013,
+	SFC_SET_SCALE_FLOAT_INT_READ	= 0x1014,
+	SFC_SET_SCALE_INT_FLOAT_WRITE	= 0x1015,
+
+	SFC_GET_SIMPLE_FORMAT_COUNT		= 0x1020,
+	SFC_GET_SIMPLE_FORMAT			= 0x1021,
+
+	SFC_GET_FORMAT_INFO				= 0x1028,
+
+	SFC_GET_FORMAT_MAJOR_COUNT		= 0x1030,
+	SFC_GET_FORMAT_MAJOR			= 0x1031,
+	SFC_GET_FORMAT_SUBTYPE_COUNT	= 0x1032,
+	SFC_GET_FORMAT_SUBTYPE			= 0x1033,
+
+	SFC_CALC_SIGNAL_MAX				= 0x1040,
+	SFC_CALC_NORM_SIGNAL_MAX		= 0x1041,
+	SFC_CALC_MAX_ALL_CHANNELS		= 0x1042,
+	SFC_CALC_NORM_MAX_ALL_CHANNELS	= 0x1043,
+	SFC_GET_SIGNAL_MAX				= 0x1044,
+	SFC_GET_MAX_ALL_CHANNELS		= 0x1045,
+
+	SFC_SET_ADD_PEAK_CHUNK			= 0x1050,
+	SFC_SET_ADD_HEADER_PAD_CHUNK	= 0x1051,
+
+	SFC_UPDATE_HEADER_NOW			= 0x1060,
+	SFC_SET_UPDATE_HEADER_AUTO		= 0x1061,
+
+	SFC_FILE_TRUNCATE				= 0x1080,
+
+	SFC_SET_RAW_START_OFFSET		= 0x1090,
+
+	SFC_SET_DITHER_ON_WRITE			= 0x10A0,
+	SFC_SET_DITHER_ON_READ			= 0x10A1,
+
+	SFC_GET_DITHER_INFO_COUNT		= 0x10A2,
+	SFC_GET_DITHER_INFO				= 0x10A3,
+
+	SFC_GET_EMBED_FILE_INFO			= 0x10B0,
+
+	SFC_SET_CLIPPING				= 0x10C0,
+	SFC_GET_CLIPPING				= 0x10C1,
+
+	SFC_GET_INSTRUMENT				= 0x10D0,
+	SFC_SET_INSTRUMENT				= 0x10D1,
+
+	SFC_GET_LOOP_INFO				= 0x10E0,
+
+	SFC_GET_BROADCAST_INFO			= 0x10F0,
+	SFC_SET_BROADCAST_INFO			= 0x10F1,
+
+	SFC_GET_CHANNEL_MAP_INFO		= 0x1100,
+	SFC_SET_CHANNEL_MAP_INFO		= 0x1101,
+
+	SFC_RAW_DATA_NEEDS_ENDSWAP		= 0x1110,
+
+	/* Support for Wavex Ambisonics Format */
+	SFC_WAVEX_SET_AMBISONIC			= 0x1200,
+	SFC_WAVEX_GET_AMBISONIC			= 0x1201,
+
+	SFC_SET_VBR_ENCODING_QUALITY	= 0x1300,
+
+	/* Following commands for testing only. */
+	SFC_TEST_IEEE_FLOAT_REPLACE		= 0x6001,
+
+	/*
+	** SFC_SET_ADD_* values are deprecated and will disappear at some
+	** time in the future. They are guaranteed to be here up to and
+	** including version 1.0.8 to avoid breakage of existng software.
+	** They currently do nothing and will continue to do nothing.
+	*/
+	SFC_SET_ADD_DITHER_ON_WRITE		= 0x1070,
+	SFC_SET_ADD_DITHER_ON_READ		= 0x1071
+} ;
+
+
+/*
+** String types that can be set and read from files. Not all file types
+** support this and even the file types which support one, may not support
+** all string types.
+*/
+
+enum
+{	SF_STR_TITLE					= 0x01,
+	SF_STR_COPYRIGHT				= 0x02,
+	SF_STR_SOFTWARE					= 0x03,
+	SF_STR_ARTIST					= 0x04,
+	SF_STR_COMMENT					= 0x05,
+	SF_STR_DATE						= 0x06,
+	SF_STR_ALBUM					= 0x07,
+	SF_STR_LICENSE					= 0x08
+} ;
+
+/*
+** Use the following as the start and end index when doing metadata
+** transcoding.
+*/
+
+#define	SF_STR_FIRST	SF_STR_TITLE
+#define	SF_STR_LAST		SF_STR_LICENSE
+
+enum
+{	/* True and false */
+	SF_FALSE	= 0,
+	SF_TRUE		= 1,
+
+	/* Modes for opening files. */
+	SFM_READ	= 0x10,
+	SFM_WRITE	= 0x20,
+	SFM_RDWR	= 0x30,
+
+	SF_AMBISONIC_NONE		= 0x40,
+	SF_AMBISONIC_B_FORMAT	= 0x41
+} ;
+
+/* Public error values. These are guaranteed to remain unchanged for the duration
+** of the library major version number.
+** There are also a large number of private error numbers which are internal to
+** the library which can change at any time.
+*/
+
+enum
+{	SF_ERR_NO_ERROR				= 0,
+	SF_ERR_UNRECOGNISED_FORMAT	= 1,
+	SF_ERR_SYSTEM				= 2,
+	SF_ERR_MALFORMED_FILE		= 3,
+	SF_ERR_UNSUPPORTED_ENCODING	= 4
+} ;
+
+
+/* Channel map values (used with SFC_SET/GET_CHANNEL_MAP).
+*/
+
+enum
+{	SF_CHANNEL_MAP_INVALID = 0,
+	SF_CHANNEL_MAP_MONO = 1,
+	SF_CHANNEL_MAP_LEFT,					/* Apple calls this 'Left' */
+	SF_CHANNEL_MAP_RIGHT,					/* Apple calls this 'Right' */
+	SF_CHANNEL_MAP_CENTER,					/* Apple calls this 'Center' */
+	SF_CHANNEL_MAP_FRONT_LEFT,
+	SF_CHANNEL_MAP_FRONT_RIGHT,
+	SF_CHANNEL_MAP_FRONT_CENTER,
+	SF_CHANNEL_MAP_REAR_CENTER,				/* Apple calls this 'Center Surround', Msft calls this 'Back Center' */
+	SF_CHANNEL_MAP_REAR_LEFT,				/* Apple calls this 'Left Surround', Msft calls this 'Back Left' */
+	SF_CHANNEL_MAP_REAR_RIGHT,				/* Apple calls this 'Right Surround', Msft calls this 'Back Right' */
+	SF_CHANNEL_MAP_LFE,						/* Apple calls this 'LFEScreen', Msft calls this 'Low Frequency'  */
+	SF_CHANNEL_MAP_FRONT_LEFT_OF_CENTER,	/* Apple calls this 'Left Center' */
+	SF_CHANNEL_MAP_FRONT_RIGHT_OF_CENTER,	/* Apple calls this 'Right Center */
+	SF_CHANNEL_MAP_SIDE_LEFT,				/* Apple calls this 'Left Surround Direct' */
+	SF_CHANNEL_MAP_SIDE_RIGHT,				/* Apple calls this 'Right Surround Direct' */
+	SF_CHANNEL_MAP_TOP_CENTER,				/* Apple calls this 'Top Center Surround' */
+	SF_CHANNEL_MAP_TOP_FRONT_LEFT,			/* Apple calls this 'Vertical Height Left' */
+	SF_CHANNEL_MAP_TOP_FRONT_RIGHT,			/* Apple calls this 'Vertical Height Right' */
+	SF_CHANNEL_MAP_TOP_FRONT_CENTER,		/* Apple calls this 'Vertical Height Center' */
+	SF_CHANNEL_MAP_TOP_REAR_LEFT,			/* Apple and MS call this 'Top Back Left' */
+	SF_CHANNEL_MAP_TOP_REAR_RIGHT,			/* Apple and MS call this 'Top Back Right' */
+	SF_CHANNEL_MAP_TOP_REAR_CENTER,			/* Apple and MS call this 'Top Back Center' */
+
+	SF_CHANNEL_MAP_AMBISONIC_B_W,
+	SF_CHANNEL_MAP_AMBISONIC_B_X,
+	SF_CHANNEL_MAP_AMBISONIC_B_Y,
+	SF_CHANNEL_MAP_AMBISONIC_B_Z,
+
+	SF_CHANNEL_MAP_MAX,
+} ;
+
+
+/* A SNDFILE* pointer can be passed around much like stdio.h's FILE* pointer. */
+
+typedef	struct SNDFILE_tag	SNDFILE ;
+
+/* The following typedef is system specific and is defined when libsndfile is
+** compiled. sf_count_t can be one of loff_t (Linux), off_t (*BSD), off64_t 
+** (Solaris), __int64 (Win32) etc. On windows, we need to allow the same
+** header file to be compiler by both GCC and the microsoft compiler.
+*/
+
+#if (defined (_MSCVER) || defined (_MSC_VER))
+typedef __int64		sf_count_t ;
+#define SF_COUNT_MAX		0x7fffffffffffffffi64
+#else
+typedef @TYPEOF_SF_COUNT_T@	sf_count_t ;
+#define SF_COUNT_MAX		@SF_COUNT_MAX@
+#endif
+
+
+/* A pointer to a SF_INFO structure is passed to sf_open () and filled in.
+** On write, the SF_INFO structure is filled in by the user and passed into
+** sf_open ().
+*/
+
+struct SF_INFO
+{	sf_count_t	frames ;		/* Used to be called samples.  Changed to avoid confusion. */
+	int			samplerate ;
+	int			channels ;
+	int			format ;
+	int			sections ;
+	int			seekable ;
+} ;
+
+typedef	struct SF_INFO SF_INFO ;
+
+/* The SF_FORMAT_INFO struct is used to retrieve information about the sound
+** file formats libsndfile supports using the sf_command () interface.
+**
+** Using this interface will allow applications to support new file formats
+** and encoding types when libsndfile is upgraded, without requiring
+** re-compilation of the application.
+**
+** Please consult the libsndfile documentation (particularly the information
+** on the sf_command () interface) for examples of its use.
+*/
+
+typedef struct
+{	int			format ;
+	const char	*name ;
+	const char	*extension ;
+} SF_FORMAT_INFO ;
+
+/*
+** Enums and typedefs for adding dither on read and write.
+** See the html documentation for sf_command(), SFC_SET_DITHER_ON_WRITE
+** and SFC_SET_DITHER_ON_READ.
+*/
+
+enum
+{	SFD_DEFAULT_LEVEL	= 0,
+	SFD_CUSTOM_LEVEL	= 0x40000000,
+
+	SFD_NO_DITHER		= 500,
+	SFD_WHITE			= 501,
+	SFD_TRIANGULAR_PDF	= 502
+} ;
+
+typedef struct
+{	int			type ;
+	double		level ;
+	const char	*name ;
+} SF_DITHER_INFO ;
+
+/* Struct used to retrieve information about a file embedded within a
+** larger file. See SFC_GET_EMBED_FILE_INFO.
+*/
+
+typedef struct
+{	sf_count_t	offset ;
+	sf_count_t	length ;
+} SF_EMBED_FILE_INFO ;
+
+/*
+**	Structs used to retrieve music sample information from a file.
+*/
+
+enum
+{	/*
+	**	The loop mode field in SF_INSTRUMENT will be one of the following.
+	*/
+	SF_LOOP_NONE = 800,
+	SF_LOOP_FORWARD,
+	SF_LOOP_BACKWARD,
+	SF_LOOP_ALTERNATING
+} ;
+
+typedef struct
+{	int gain ;
+	char basenote, detune ;
+	char velocity_lo, velocity_hi ;
+	char key_lo, key_hi ;
+	int loop_count ;
+
+	struct
+	{	int mode ;
+		unsigned int start ;
+		unsigned int end ;
+		unsigned int count ;
+	} loops [16] ; /* make variable in a sensible way */
+} SF_INSTRUMENT ;
+
+
+
+/* Struct used to retrieve loop information from a file.*/
+typedef struct
+{
+	short	time_sig_num ;	/* any positive integer    > 0  */
+	short	time_sig_den ;	/* any positive power of 2 > 0  */
+	int		loop_mode ;		/* see SF_LOOP enum             */
+
+	int		num_beats ;		/* this is NOT the amount of quarter notes !!!*/
+							/* a full bar of 4/4 is 4 beats */
+							/* a full bar of 7/8 is 7 beats */
+
+	float	bpm ;			/* suggestion, as it can be calculated using other fields:*/
+							/* file's lenght, file's sampleRate and our time_sig_den*/
+							/* -> bpms are always the amount of _quarter notes_ per minute */
+
+	int	root_key ;			/* MIDI note, or -1 for None */
+	int future [6] ;
+} SF_LOOP_INFO ;
+
+
+/*	Struct used to retrieve broadcast (EBU) information from a file.
+**	Strongly (!) based on EBU "bext" chunk format used in Broadcast WAVE.
+*/
+#define	SF_BROADCAST_INFO_VAR(coding_hist_size) \
+			struct \
+			{	char			description [256] ; \
+				char			originator [32] ; \
+				char			originator_reference [32] ; \
+				char			origination_date [10] ; \
+				char			origination_time [8] ; \
+				unsigned int	time_reference_low ; \
+				unsigned int	time_reference_high ; \
+				short			version ; \
+				char			umid [64] ; \
+				char			reserved [190] ; \
+				unsigned int	coding_history_size ; \
+				char			coding_history [coding_hist_size] ; \
+			}
+
+/* SF_BROADCAST_INFO is the above struct with coding_history field of 256 bytes. */
+typedef SF_BROADCAST_INFO_VAR (256) SF_BROADCAST_INFO ;
+
+
+/*	Virtual I/O functionality. */
+
+typedef sf_count_t		(*sf_vio_get_filelen)	(void *user_data) ;
+typedef sf_count_t		(*sf_vio_seek)		(sf_count_t offset, int whence, void *user_data) ;
+typedef sf_count_t		(*sf_vio_read)		(void *ptr, sf_count_t count, void *user_data) ;
+typedef sf_count_t		(*sf_vio_write)		(const void *ptr, sf_count_t count, void *user_data) ;
+typedef sf_count_t		(*sf_vio_tell)		(void *user_data) ;
+
+struct SF_VIRTUAL_IO
+{	sf_vio_get_filelen	get_filelen ;
+	sf_vio_seek			seek ;
+	sf_vio_read			read ;
+	sf_vio_write		write ;
+	sf_vio_tell			tell ;
+} ;
+
+typedef	struct SF_VIRTUAL_IO SF_VIRTUAL_IO ;
+
+
+/* Open the specified file for read, write or both. On error, this will
+** return a NULL pointer. To find the error number, pass a NULL SNDFILE
+** to sf_strerror ().
+** All calls to sf_open() should be matched with a call to sf_close().
+*/
+
+SNDFILE* 	sf_open		(const char *path, int mode, SF_INFO *sfinfo) ;
+
+
+/* Use the existing file descriptor to create a SNDFILE object. If close_desc
+** is TRUE, the file descriptor will be closed when sf_close() is called. If
+** it is FALSE, the descritor will not be closed.
+** When passed a descriptor like this, the library will assume that the start
+** of file header is at the current file offset. This allows sound files within
+** larger container files to be read and/or written.
+** On error, this will return a NULL pointer. To find the error number, pass a
+** NULL SNDFILE to sf_strerror ().
+** All calls to sf_open_fd() should be matched with a call to sf_close().
+
+*/
+
+SNDFILE* 	sf_open_fd	(int fd, int mode, SF_INFO *sfinfo, int close_desc) ;
+
+SNDFILE* 	sf_open_virtual	(SF_VIRTUAL_IO *sfvirtual, int mode, SF_INFO *sfinfo, void *user_data) ;
+
+
+/* sf_error () returns a error number which can be translated to a text
+** string using sf_error_number().
+*/
+
+int		sf_error		(SNDFILE *sndfile) ;
+
+
+/* sf_strerror () returns to the caller a pointer to the current error message for
+** the given SNDFILE.
+*/
+
+const char* sf_strerror (SNDFILE *sndfile) ;
+
+
+/* sf_error_number () allows the retrieval of the error string for each internal
+** error number.
+**
+*/
+
+const char*	sf_error_number	(int errnum) ;
+
+
+/* The following two error functions are deprecated but they will remain in the
+** library for the forseeable future. The function sf_strerror() should be used
+** in their place.
+*/
+
+int		sf_perror		(SNDFILE *sndfile) ;
+int		sf_error_str	(SNDFILE *sndfile, char* str, size_t len) ;
+
+
+/* Return TRUE if fields of the SF_INFO struct are a valid combination of values. */
+
+int		sf_command	(SNDFILE *sndfile, int command, void *data, int datasize) ;
+
+
+/* Return TRUE if fields of the SF_INFO struct are a valid combination of values. */
+
+int		sf_format_check	(const SF_INFO *info) ;
+
+
+/* Seek within the waveform data chunk of the SNDFILE. sf_seek () uses
+** the same values for whence (SEEK_SET, SEEK_CUR and SEEK_END) as
+** stdio.h function fseek ().
+** An offset of zero with whence set to SEEK_SET will position the
+** read / write pointer to the first data sample.
+** On success sf_seek returns the current position in (multi-channel)
+** samples from the start of the file.
+** Please see the libsndfile documentation for moving the read pointer
+** separately from the write pointer on files open in mode SFM_RDWR.
+** On error all of these functions return -1.
+*/
+
+sf_count_t	sf_seek 		(SNDFILE *sndfile, sf_count_t frames, int whence) ;
+
+
+/* Functions for retrieving and setting string data within sound files.
+** Not all file types support this features; AIFF and WAV do. For both
+** functions, the str_type parameter must be one of the SF_STR_* values
+** defined above.
+** On error, sf_set_string() returns non-zero while sf_get_string()
+** returns NULL.
+*/
+
+int sf_set_string (SNDFILE *sndfile, int str_type, const char* str) ;
+
+const char* sf_get_string (SNDFILE *sndfile, int str_type) ;
+
+
+/* Return the library version string. */
+
+const char * sf_version_string (void) ;
+
+
+/* Functions for reading/writing the waveform data of a sound file.
+*/
+
+sf_count_t	sf_read_raw		(SNDFILE *sndfile, void *ptr, sf_count_t bytes) ;
+sf_count_t	sf_write_raw 	(SNDFILE *sndfile, const void *ptr, sf_count_t bytes) ;
+
+
+/* Functions for reading and writing the data chunk in terms of frames.
+** The number of items actually read/written = frames * number of channels.
+**     sf_xxxx_raw		read/writes the raw data bytes from/to the file
+**     sf_xxxx_short	passes data in the native short format
+**     sf_xxxx_int		passes data in the native int format
+**     sf_xxxx_float	passes data in the native float format
+**     sf_xxxx_double	passes data in the native double format
+** All of these read/write function return number of frames read/written.
+*/
+
+sf_count_t	sf_readf_short	(SNDFILE *sndfile, short *ptr, sf_count_t frames) ;
+sf_count_t	sf_writef_short	(SNDFILE *sndfile, const short *ptr, sf_count_t frames) ;
+
+sf_count_t	sf_readf_int	(SNDFILE *sndfile, int *ptr, sf_count_t frames) ;
+sf_count_t	sf_writef_int 	(SNDFILE *sndfile, const int *ptr, sf_count_t frames) ;
+
+sf_count_t	sf_readf_float	(SNDFILE *sndfile, float *ptr, sf_count_t frames) ;
+sf_count_t	sf_writef_float	(SNDFILE *sndfile, const float *ptr, sf_count_t frames) ;
+
+sf_count_t	sf_readf_double		(SNDFILE *sndfile, double *ptr, sf_count_t frames) ;
+sf_count_t	sf_writef_double	(SNDFILE *sndfile, const double *ptr, sf_count_t frames) ;
+
+
+/* Functions for reading and writing the data chunk in terms of items.
+** Otherwise similar to above.
+** All of these read/write function return number of items read/written.
+*/
+
+sf_count_t	sf_read_short	(SNDFILE *sndfile, short *ptr, sf_count_t items) ;
+sf_count_t	sf_write_short	(SNDFILE *sndfile, const short *ptr, sf_count_t items) ;
+
+sf_count_t	sf_read_int		(SNDFILE *sndfile, int *ptr, sf_count_t items) ;
+sf_count_t	sf_write_int 	(SNDFILE *sndfile, const int *ptr, sf_count_t items) ;
+
+sf_count_t	sf_read_float	(SNDFILE *sndfile, float *ptr, sf_count_t items) ;
+sf_count_t	sf_write_float	(SNDFILE *sndfile, const float *ptr, sf_count_t items) ;
+
+sf_count_t	sf_read_double	(SNDFILE *sndfile, double *ptr, sf_count_t items) ;
+sf_count_t	sf_write_double	(SNDFILE *sndfile, const double *ptr, sf_count_t items) ;
+
+
+/* Close the SNDFILE and clean up all memory allocations associated with this
+** file.
+** Returns 0 on success, or an error number.
+*/
+
+int		sf_close		(SNDFILE *sndfile) ;
+
+
+/* If the file is opened SFM_WRITE or SFM_RDWR, call fsync() on the file
+** to force the writing of data to disk. If the file is opened SFM_READ
+** no action is taken.
+*/
+
+void	sf_write_sync	(SNDFILE *sndfile) ;
+
+
+
+/* The function sf_wchar_open() is Windows Only!
+** Open a file passing in a Windows Unicode filename. Otherwise, this is
+** the same as sf_open().
+**
+** In order for this to work, you need to do the following:
+**
+**		#include <windows.h>
+**		#define ENABLE_SNDFILE_WINDOWS_PROTOTYPES 1
+**		#including <sndfile.h>
+*/
+
+#if ENABLE_SNDFILE_WINDOWS_PROTOTYPES
+SNDFILE* sf_wchar_open (LPCWSTR wpath, int mode, SF_INFO *sfinfo) ;
+#endif
+
+
+
+#ifdef __cplusplus
+}		/* extern "C" */
+#endif	/* __cplusplus */
+
+#endif	/* SNDFILE_H */
+
diff -Nru libsndfile-1.0.21.orig/src/sndfile.h.in libsndfile-1.0.21/src/sndfile.h.in
--- libsndfile-1.0.21.orig/src/sndfile.h.in	Thu Dec 10 20:49:31 2009
+++ libsndfile-1.0.21/src/sndfile.h.in	Thu Jan  1 02:00:00 1970
@@ -1,663 +0,0 @@
-/*
-** Copyright (C) 1999-2009 Erik de Castro Lopo <erikd@mega-nerd.com>
-**
-** This program is free software; you can redistribute it and/or modify
-** it under the terms of the GNU Lesser General Public License as published by
-** the Free Software Foundation; either version 2.1 of the License, or
-** (at your option) any later version.
-**
-** This program is distributed in the hope that it will be useful,
-** but WITHOUT ANY WARRANTY; without even the implied warranty of
-** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-** GNU Lesser General Public License for more details.
-**
-** You should have received a copy of the GNU Lesser General Public License
-** along with this program; if not, write to the Free Software
-** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
-*/
-
-/*
-** sndfile.h -- system-wide definitions
-**
-** API documentation is in the doc/ directory of the source code tarball
-** and at http://www.mega-nerd.com/libsndfile/api.html.
-*/
-
-#ifndef SNDFILE_H
-#define SNDFILE_H
-
-/* This is the version 1.0.X header file. */
-#define	SNDFILE_1
-
-#include <stdio.h>
-#include <sys/types.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif	/* __cplusplus */
-
-/* The following file types can be read and written.
-** A file type would consist of a major type (ie SF_FORMAT_WAV) bitwise
-** ORed with a minor type (ie SF_FORMAT_PCM). SF_FORMAT_TYPEMASK and
-** SF_FORMAT_SUBMASK can be used to separate the major and minor file
-** types.
-*/
-
-enum
-{	/* Major formats. */
-	SF_FORMAT_WAV			= 0x010000,		/* Microsoft WAV format (little endian default). */
-	SF_FORMAT_AIFF			= 0x020000,		/* Apple/SGI AIFF format (big endian). */
-	SF_FORMAT_AU			= 0x030000,		/* Sun/NeXT AU format (big endian). */
-	SF_FORMAT_RAW			= 0x040000,		/* RAW PCM data. */
-	SF_FORMAT_PAF			= 0x050000,		/* Ensoniq PARIS file format. */
-	SF_FORMAT_SVX			= 0x060000,		/* Amiga IFF / SVX8 / SV16 format. */
-	SF_FORMAT_NIST			= 0x070000,		/* Sphere NIST format. */
-	SF_FORMAT_VOC			= 0x080000,		/* VOC files. */
-	SF_FORMAT_IRCAM			= 0x0A0000,		/* Berkeley/IRCAM/CARL */
-	SF_FORMAT_W64			= 0x0B0000,		/* Sonic Foundry's 64 bit RIFF/WAV */
-	SF_FORMAT_MAT4			= 0x0C0000,		/* Matlab (tm) V4.2 / GNU Octave 2.0 */
-	SF_FORMAT_MAT5			= 0x0D0000,		/* Matlab (tm) V5.0 / GNU Octave 2.1 */
-	SF_FORMAT_PVF			= 0x0E0000,		/* Portable Voice Format */
-	SF_FORMAT_XI			= 0x0F0000,		/* Fasttracker 2 Extended Instrument */
-	SF_FORMAT_HTK			= 0x100000,		/* HMM Tool Kit format */
-	SF_FORMAT_SDS			= 0x110000,		/* Midi Sample Dump Standard */
-	SF_FORMAT_AVR			= 0x120000,		/* Audio Visual Research */
-	SF_FORMAT_WAVEX			= 0x130000,		/* MS WAVE with WAVEFORMATEX */
-	SF_FORMAT_SD2			= 0x160000,		/* Sound Designer 2 */
-	SF_FORMAT_FLAC			= 0x170000,		/* FLAC lossless file format */
-	SF_FORMAT_CAF			= 0x180000,		/* Core Audio File format */
-	SF_FORMAT_WVE			= 0x190000,		/* Psion WVE format */
-	SF_FORMAT_OGG			= 0x200000,		/* Xiph OGG container */
-	SF_FORMAT_MPC2K			= 0x210000,		/* Akai MPC 2000 sampler */
-	SF_FORMAT_RF64			= 0x220000,		/* RF64 WAV file */
-
-	/* Subtypes from here on. */
-
-	SF_FORMAT_PCM_S8		= 0x0001,		/* Signed 8 bit data */
-	SF_FORMAT_PCM_16		= 0x0002,		/* Signed 16 bit data */
-	SF_FORMAT_PCM_24		= 0x0003,		/* Signed 24 bit data */
-	SF_FORMAT_PCM_32		= 0x0004,		/* Signed 32 bit data */
-
-	SF_FORMAT_PCM_U8		= 0x0005,		/* Unsigned 8 bit data (WAV and RAW only) */
-
-	SF_FORMAT_FLOAT			= 0x0006,		/* 32 bit float data */
-	SF_FORMAT_DOUBLE		= 0x0007,		/* 64 bit float data */
-
-	SF_FORMAT_ULAW			= 0x0010,		/* U-Law encoded. */
-	SF_FORMAT_ALAW			= 0x0011,		/* A-Law encoded. */
-	SF_FORMAT_IMA_ADPCM		= 0x0012,		/* IMA ADPCM. */
-	SF_FORMAT_MS_ADPCM		= 0x0013,		/* Microsoft ADPCM. */
-
-	SF_FORMAT_GSM610		= 0x0020,		/* GSM 6.10 encoding. */
-	SF_FORMAT_VOX_ADPCM		= 0x0021,		/* OKI / Dialogix ADPCM */
-
-	SF_FORMAT_G721_32		= 0x0030,		/* 32kbs G721 ADPCM encoding. */
-	SF_FORMAT_G723_24		= 0x0031,		/* 24kbs G723 ADPCM encoding. */
-	SF_FORMAT_G723_40		= 0x0032,		/* 40kbs G723 ADPCM encoding. */
-
-	SF_FORMAT_DWVW_12		= 0x0040, 		/* 12 bit Delta Width Variable Word encoding. */
-	SF_FORMAT_DWVW_16		= 0x0041, 		/* 16 bit Delta Width Variable Word encoding. */
-	SF_FORMAT_DWVW_24		= 0x0042, 		/* 24 bit Delta Width Variable Word encoding. */
-	SF_FORMAT_DWVW_N		= 0x0043, 		/* N bit Delta Width Variable Word encoding. */
-
-	SF_FORMAT_DPCM_8		= 0x0050,		/* 8 bit differential PCM (XI only) */
-	SF_FORMAT_DPCM_16		= 0x0051,		/* 16 bit differential PCM (XI only) */
-
-	SF_FORMAT_VORBIS		= 0x0060,		/* Xiph Vorbis encoding. */
-
-	/* Endian-ness options. */
-
-	SF_ENDIAN_FILE			= 0x00000000,	/* Default file endian-ness. */
-	SF_ENDIAN_LITTLE		= 0x10000000,	/* Force little endian-ness. */
-	SF_ENDIAN_BIG			= 0x20000000,	/* Force big endian-ness. */
-	SF_ENDIAN_CPU			= 0x30000000,	/* Force CPU endian-ness. */
-
-	SF_FORMAT_SUBMASK		= 0x0000FFFF,
-	SF_FORMAT_TYPEMASK		= 0x0FFF0000,
-	SF_FORMAT_ENDMASK		= 0x30000000
-} ;
-
-/*
-** The following are the valid command numbers for the sf_command()
-** interface.  The use of these commands is documented in the file
-** command.html in the doc directory of the source code distribution.
-*/
-
-enum
-{	SFC_GET_LIB_VERSION				= 0x1000,
-	SFC_GET_LOG_INFO				= 0x1001,
-	SFC_GET_CURRENT_SF_INFO			= 0x1002,
-
-
-	SFC_GET_NORM_DOUBLE				= 0x1010,
-	SFC_GET_NORM_FLOAT				= 0x1011,
-	SFC_SET_NORM_DOUBLE				= 0x1012,
-	SFC_SET_NORM_FLOAT				= 0x1013,
-	SFC_SET_SCALE_FLOAT_INT_READ	= 0x1014,
-	SFC_SET_SCALE_INT_FLOAT_WRITE	= 0x1015,
-
-	SFC_GET_SIMPLE_FORMAT_COUNT		= 0x1020,
-	SFC_GET_SIMPLE_FORMAT			= 0x1021,
-
-	SFC_GET_FORMAT_INFO				= 0x1028,
-
-	SFC_GET_FORMAT_MAJOR_COUNT		= 0x1030,
-	SFC_GET_FORMAT_MAJOR			= 0x1031,
-	SFC_GET_FORMAT_SUBTYPE_COUNT	= 0x1032,
-	SFC_GET_FORMAT_SUBTYPE			= 0x1033,
-
-	SFC_CALC_SIGNAL_MAX				= 0x1040,
-	SFC_CALC_NORM_SIGNAL_MAX		= 0x1041,
-	SFC_CALC_MAX_ALL_CHANNELS		= 0x1042,
-	SFC_CALC_NORM_MAX_ALL_CHANNELS	= 0x1043,
-	SFC_GET_SIGNAL_MAX				= 0x1044,
-	SFC_GET_MAX_ALL_CHANNELS		= 0x1045,
-
-	SFC_SET_ADD_PEAK_CHUNK			= 0x1050,
-	SFC_SET_ADD_HEADER_PAD_CHUNK	= 0x1051,
-
-	SFC_UPDATE_HEADER_NOW			= 0x1060,
-	SFC_SET_UPDATE_HEADER_AUTO		= 0x1061,
-
-	SFC_FILE_TRUNCATE				= 0x1080,
-
-	SFC_SET_RAW_START_OFFSET		= 0x1090,
-
-	SFC_SET_DITHER_ON_WRITE			= 0x10A0,
-	SFC_SET_DITHER_ON_READ			= 0x10A1,
-
-	SFC_GET_DITHER_INFO_COUNT		= 0x10A2,
-	SFC_GET_DITHER_INFO				= 0x10A3,
-
-	SFC_GET_EMBED_FILE_INFO			= 0x10B0,
-
-	SFC_SET_CLIPPING				= 0x10C0,
-	SFC_GET_CLIPPING				= 0x10C1,
-
-	SFC_GET_INSTRUMENT				= 0x10D0,
-	SFC_SET_INSTRUMENT				= 0x10D1,
-
-	SFC_GET_LOOP_INFO				= 0x10E0,
-
-	SFC_GET_BROADCAST_INFO			= 0x10F0,
-	SFC_SET_BROADCAST_INFO			= 0x10F1,
-
-	SFC_GET_CHANNEL_MAP_INFO		= 0x1100,
-	SFC_SET_CHANNEL_MAP_INFO		= 0x1101,
-
-	SFC_RAW_DATA_NEEDS_ENDSWAP		= 0x1110,
-
-	/* Support for Wavex Ambisonics Format */
-	SFC_WAVEX_SET_AMBISONIC			= 0x1200,
-	SFC_WAVEX_GET_AMBISONIC			= 0x1201,
-
-	SFC_SET_VBR_ENCODING_QUALITY	= 0x1300,
-
-	/* Following commands for testing only. */
-	SFC_TEST_IEEE_FLOAT_REPLACE		= 0x6001,
-
-	/*
-	** SFC_SET_ADD_* values are deprecated and will disappear at some
-	** time in the future. They are guaranteed to be here up to and
-	** including version 1.0.8 to avoid breakage of existng software.
-	** They currently do nothing and will continue to do nothing.
-	*/
-	SFC_SET_ADD_DITHER_ON_WRITE		= 0x1070,
-	SFC_SET_ADD_DITHER_ON_READ		= 0x1071
-} ;
-
-
-/*
-** String types that can be set and read from files. Not all file types
-** support this and even the file types which support one, may not support
-** all string types.
-*/
-
-enum
-{	SF_STR_TITLE					= 0x01,
-	SF_STR_COPYRIGHT				= 0x02,
-	SF_STR_SOFTWARE					= 0x03,
-	SF_STR_ARTIST					= 0x04,
-	SF_STR_COMMENT					= 0x05,
-	SF_STR_DATE						= 0x06,
-	SF_STR_ALBUM					= 0x07,
-	SF_STR_LICENSE					= 0x08
-} ;
-
-/*
-** Use the following as the start and end index when doing metadata
-** transcoding.
-*/
-
-#define	SF_STR_FIRST	SF_STR_TITLE
-#define	SF_STR_LAST		SF_STR_LICENSE
-
-enum
-{	/* True and false */
-	SF_FALSE	= 0,
-	SF_TRUE		= 1,
-
-	/* Modes for opening files. */
-	SFM_READ	= 0x10,
-	SFM_WRITE	= 0x20,
-	SFM_RDWR	= 0x30,
-
-	SF_AMBISONIC_NONE		= 0x40,
-	SF_AMBISONIC_B_FORMAT	= 0x41
-} ;
-
-/* Public error values. These are guaranteed to remain unchanged for the duration
-** of the library major version number.
-** There are also a large number of private error numbers which are internal to
-** the library which can change at any time.
-*/
-
-enum
-{	SF_ERR_NO_ERROR				= 0,
-	SF_ERR_UNRECOGNISED_FORMAT	= 1,
-	SF_ERR_SYSTEM				= 2,
-	SF_ERR_MALFORMED_FILE		= 3,
-	SF_ERR_UNSUPPORTED_ENCODING	= 4
-} ;
-
-
-/* Channel map values (used with SFC_SET/GET_CHANNEL_MAP).
-*/
-
-enum
-{	SF_CHANNEL_MAP_INVALID = 0,
-	SF_CHANNEL_MAP_MONO = 1,
-	SF_CHANNEL_MAP_LEFT,					/* Apple calls this 'Left' */
-	SF_CHANNEL_MAP_RIGHT,					/* Apple calls this 'Right' */
-	SF_CHANNEL_MAP_CENTER,					/* Apple calls this 'Center' */
-	SF_CHANNEL_MAP_FRONT_LEFT,
-	SF_CHANNEL_MAP_FRONT_RIGHT,
-	SF_CHANNEL_MAP_FRONT_CENTER,
-	SF_CHANNEL_MAP_REAR_CENTER,				/* Apple calls this 'Center Surround', Msft calls this 'Back Center' */
-	SF_CHANNEL_MAP_REAR_LEFT,				/* Apple calls this 'Left Surround', Msft calls this 'Back Left' */
-	SF_CHANNEL_MAP_REAR_RIGHT,				/* Apple calls this 'Right Surround', Msft calls this 'Back Right' */
-	SF_CHANNEL_MAP_LFE,						/* Apple calls this 'LFEScreen', Msft calls this 'Low Frequency'  */
-	SF_CHANNEL_MAP_FRONT_LEFT_OF_CENTER,	/* Apple calls this 'Left Center' */
-	SF_CHANNEL_MAP_FRONT_RIGHT_OF_CENTER,	/* Apple calls this 'Right Center */
-	SF_CHANNEL_MAP_SIDE_LEFT,				/* Apple calls this 'Left Surround Direct' */
-	SF_CHANNEL_MAP_SIDE_RIGHT,				/* Apple calls this 'Right Surround Direct' */
-	SF_CHANNEL_MAP_TOP_CENTER,				/* Apple calls this 'Top Center Surround' */
-	SF_CHANNEL_MAP_TOP_FRONT_LEFT,			/* Apple calls this 'Vertical Height Left' */
-	SF_CHANNEL_MAP_TOP_FRONT_RIGHT,			/* Apple calls this 'Vertical Height Right' */
-	SF_CHANNEL_MAP_TOP_FRONT_CENTER,		/* Apple calls this 'Vertical Height Center' */
-	SF_CHANNEL_MAP_TOP_REAR_LEFT,			/* Apple and MS call this 'Top Back Left' */
-	SF_CHANNEL_MAP_TOP_REAR_RIGHT,			/* Apple and MS call this 'Top Back Right' */
-	SF_CHANNEL_MAP_TOP_REAR_CENTER,			/* Apple and MS call this 'Top Back Center' */
-
-	SF_CHANNEL_MAP_AMBISONIC_B_W,
-	SF_CHANNEL_MAP_AMBISONIC_B_X,
-	SF_CHANNEL_MAP_AMBISONIC_B_Y,
-	SF_CHANNEL_MAP_AMBISONIC_B_Z,
-
-	SF_CHANNEL_MAP_MAX,
-} ;
-
-
-/* A SNDFILE* pointer can be passed around much like stdio.h's FILE* pointer. */
-
-typedef	struct SNDFILE_tag	SNDFILE ;
-
-/* The following typedef is system specific and is defined when libsndfile is
-** compiled. sf_count_t can be one of loff_t (Linux), off_t (*BSD), off64_t 
-** (Solaris), __int64 (Win32) etc. On windows, we need to allow the same
-** header file to be compiler by both GCC and the microsoft compiler.
-*/
-
-#if (defined (_MSCVER) || defined (_MSC_VER))
-typedef __int64		sf_count_t ;
-#define SF_COUNT_MAX		0x7fffffffffffffffi64
-#else
-typedef @TYPEOF_SF_COUNT_T@	sf_count_t ;
-#define SF_COUNT_MAX		@SF_COUNT_MAX@
-#endif
-
-
-/* A pointer to a SF_INFO structure is passed to sf_open () and filled in.
-** On write, the SF_INFO structure is filled in by the user and passed into
-** sf_open ().
-*/
-
-struct SF_INFO
-{	sf_count_t	frames ;		/* Used to be called samples.  Changed to avoid confusion. */
-	int			samplerate ;
-	int			channels ;
-	int			format ;
-	int			sections ;
-	int			seekable ;
-} ;
-
-typedef	struct SF_INFO SF_INFO ;
-
-/* The SF_FORMAT_INFO struct is used to retrieve information about the sound
-** file formats libsndfile supports using the sf_command () interface.
-**
-** Using this interface will allow applications to support new file formats
-** and encoding types when libsndfile is upgraded, without requiring
-** re-compilation of the application.
-**
-** Please consult the libsndfile documentation (particularly the information
-** on the sf_command () interface) for examples of its use.
-*/
-
-typedef struct
-{	int			format ;
-	const char	*name ;
-	const char	*extension ;
-} SF_FORMAT_INFO ;
-
-/*
-** Enums and typedefs for adding dither on read and write.
-** See the html documentation for sf_command(), SFC_SET_DITHER_ON_WRITE
-** and SFC_SET_DITHER_ON_READ.
-*/
-
-enum
-{	SFD_DEFAULT_LEVEL	= 0,
-	SFD_CUSTOM_LEVEL	= 0x40000000,
-
-	SFD_NO_DITHER		= 500,
-	SFD_WHITE			= 501,
-	SFD_TRIANGULAR_PDF	= 502
-} ;
-
-typedef struct
-{	int			type ;
-	double		level ;
-	const char	*name ;
-} SF_DITHER_INFO ;
-
-/* Struct used to retrieve information about a file embedded within a
-** larger file. See SFC_GET_EMBED_FILE_INFO.
-*/
-
-typedef struct
-{	sf_count_t	offset ;
-	sf_count_t	length ;
-} SF_EMBED_FILE_INFO ;
-
-/*
-**	Structs used to retrieve music sample information from a file.
-*/
-
-enum
-{	/*
-	**	The loop mode field in SF_INSTRUMENT will be one of the following.
-	*/
-	SF_LOOP_NONE = 800,
-	SF_LOOP_FORWARD,
-	SF_LOOP_BACKWARD,
-	SF_LOOP_ALTERNATING
-} ;
-
-typedef struct
-{	int gain ;
-	char basenote, detune ;
-	char velocity_lo, velocity_hi ;
-	char key_lo, key_hi ;
-	int loop_count ;
-
-	struct
-	{	int mode ;
-		unsigned int start ;
-		unsigned int end ;
-		unsigned int count ;
-	} loops [16] ; /* make variable in a sensible way */
-} SF_INSTRUMENT ;
-
-
-
-/* Struct used to retrieve loop information from a file.*/
-typedef struct
-{
-	short	time_sig_num ;	/* any positive integer    > 0  */
-	short	time_sig_den ;	/* any positive power of 2 > 0  */
-	int		loop_mode ;		/* see SF_LOOP enum             */
-
-	int		num_beats ;		/* this is NOT the amount of quarter notes !!!*/
-							/* a full bar of 4/4 is 4 beats */
-							/* a full bar of 7/8 is 7 beats */
-
-	float	bpm ;			/* suggestion, as it can be calculated using other fields:*/
-							/* file's lenght, file's sampleRate and our time_sig_den*/
-							/* -> bpms are always the amount of _quarter notes_ per minute */
-
-	int	root_key ;			/* MIDI note, or -1 for None */
-	int future [6] ;
-} SF_LOOP_INFO ;
-
-
-/*	Struct used to retrieve broadcast (EBU) information from a file.
-**	Strongly (!) based on EBU "bext" chunk format used in Broadcast WAVE.
-*/
-#define	SF_BROADCAST_INFO_VAR(coding_hist_size) \
-			struct \
-			{	char			description [256] ; \
-				char			originator [32] ; \
-				char			originator_reference [32] ; \
-				char			origination_date [10] ; \
-				char			origination_time [8] ; \
-				unsigned int	time_reference_low ; \
-				unsigned int	time_reference_high ; \
-				short			version ; \
-				char			umid [64] ; \
-				char			reserved [190] ; \
-				unsigned int	coding_history_size ; \
-				char			coding_history [coding_hist_size] ; \
-			}
-
-/* SF_BROADCAST_INFO is the above struct with coding_history field of 256 bytes. */
-typedef SF_BROADCAST_INFO_VAR (256) SF_BROADCAST_INFO ;
-
-
-/*	Virtual I/O functionality. */
-
-typedef sf_count_t		(*sf_vio_get_filelen)	(void *user_data) ;
-typedef sf_count_t		(*sf_vio_seek)		(sf_count_t offset, int whence, void *user_data) ;
-typedef sf_count_t		(*sf_vio_read)		(void *ptr, sf_count_t count, void *user_data) ;
-typedef sf_count_t		(*sf_vio_write)		(const void *ptr, sf_count_t count, void *user_data) ;
-typedef sf_count_t		(*sf_vio_tell)		(void *user_data) ;
-
-struct SF_VIRTUAL_IO
-{	sf_vio_get_filelen	get_filelen ;
-	sf_vio_seek			seek ;
-	sf_vio_read			read ;
-	sf_vio_write		write ;
-	sf_vio_tell			tell ;
-} ;
-
-typedef	struct SF_VIRTUAL_IO SF_VIRTUAL_IO ;
-
-
-/* Open the specified file for read, write or both. On error, this will
-** return a NULL pointer. To find the error number, pass a NULL SNDFILE
-** to sf_strerror ().
-** All calls to sf_open() should be matched with a call to sf_close().
-*/
-
-SNDFILE* 	sf_open		(const char *path, int mode, SF_INFO *sfinfo) ;
-
-
-/* Use the existing file descriptor to create a SNDFILE object. If close_desc
-** is TRUE, the file descriptor will be closed when sf_close() is called. If
-** it is FALSE, the descritor will not be closed.
-** When passed a descriptor like this, the library will assume that the start
-** of file header is at the current file offset. This allows sound files within
-** larger container files to be read and/or written.
-** On error, this will return a NULL pointer. To find the error number, pass a
-** NULL SNDFILE to sf_strerror ().
-** All calls to sf_open_fd() should be matched with a call to sf_close().
-
-*/
-
-SNDFILE* 	sf_open_fd	(int fd, int mode, SF_INFO *sfinfo, int close_desc) ;
-
-SNDFILE* 	sf_open_virtual	(SF_VIRTUAL_IO *sfvirtual, int mode, SF_INFO *sfinfo, void *user_data) ;
-
-
-/* sf_error () returns a error number which can be translated to a text
-** string using sf_error_number().
-*/
-
-int		sf_error		(SNDFILE *sndfile) ;
-
-
-/* sf_strerror () returns to the caller a pointer to the current error message for
-** the given SNDFILE.
-*/
-
-const char* sf_strerror (SNDFILE *sndfile) ;
-
-
-/* sf_error_number () allows the retrieval of the error string for each internal
-** error number.
-**
-*/
-
-const char*	sf_error_number	(int errnum) ;
-
-
-/* The following two error functions are deprecated but they will remain in the
-** library for the forseeable future. The function sf_strerror() should be used
-** in their place.
-*/
-
-int		sf_perror		(SNDFILE *sndfile) ;
-int		sf_error_str	(SNDFILE *sndfile, char* str, size_t len) ;
-
-
-/* Return TRUE if fields of the SF_INFO struct are a valid combination of values. */
-
-int		sf_command	(SNDFILE *sndfile, int command, void *data, int datasize) ;
-
-
-/* Return TRUE if fields of the SF_INFO struct are a valid combination of values. */
-
-int		sf_format_check	(const SF_INFO *info) ;
-
-
-/* Seek within the waveform data chunk of the SNDFILE. sf_seek () uses
-** the same values for whence (SEEK_SET, SEEK_CUR and SEEK_END) as
-** stdio.h function fseek ().
-** An offset of zero with whence set to SEEK_SET will position the
-** read / write pointer to the first data sample.
-** On success sf_seek returns the current position in (multi-channel)
-** samples from the start of the file.
-** Please see the libsndfile documentation for moving the read pointer
-** separately from the write pointer on files open in mode SFM_RDWR.
-** On error all of these functions return -1.
-*/
-
-sf_count_t	sf_seek 		(SNDFILE *sndfile, sf_count_t frames, int whence) ;
-
-
-/* Functions for retrieving and setting string data within sound files.
-** Not all file types support this features; AIFF and WAV do. For both
-** functions, the str_type parameter must be one of the SF_STR_* values
-** defined above.
-** On error, sf_set_string() returns non-zero while sf_get_string()
-** returns NULL.
-*/
-
-int sf_set_string (SNDFILE *sndfile, int str_type, const char* str) ;
-
-const char* sf_get_string (SNDFILE *sndfile, int str_type) ;
-
-
-/* Return the library version string. */
-
-const char * sf_version_string (void) ;
-
-
-/* Functions for reading/writing the waveform data of a sound file.
-*/
-
-sf_count_t	sf_read_raw		(SNDFILE *sndfile, void *ptr, sf_count_t bytes) ;
-sf_count_t	sf_write_raw 	(SNDFILE *sndfile, const void *ptr, sf_count_t bytes) ;
-
-
-/* Functions for reading and writing the data chunk in terms of frames.
-** The number of items actually read/written = frames * number of channels.
-**     sf_xxxx_raw		read/writes the raw data bytes from/to the file
-**     sf_xxxx_short	passes data in the native short format
-**     sf_xxxx_int		passes data in the native int format
-**     sf_xxxx_float	passes data in the native float format
-**     sf_xxxx_double	passes data in the native double format
-** All of these read/write function return number of frames read/written.
-*/
-
-sf_count_t	sf_readf_short	(SNDFILE *sndfile, short *ptr, sf_count_t frames) ;
-sf_count_t	sf_writef_short	(SNDFILE *sndfile, const short *ptr, sf_count_t frames) ;
-
-sf_count_t	sf_readf_int	(SNDFILE *sndfile, int *ptr, sf_count_t frames) ;
-sf_count_t	sf_writef_int 	(SNDFILE *sndfile, const int *ptr, sf_count_t frames) ;
-
-sf_count_t	sf_readf_float	(SNDFILE *sndfile, float *ptr, sf_count_t frames) ;
-sf_count_t	sf_writef_float	(SNDFILE *sndfile, const float *ptr, sf_count_t frames) ;
-
-sf_count_t	sf_readf_double		(SNDFILE *sndfile, double *ptr, sf_count_t frames) ;
-sf_count_t	sf_writef_double	(SNDFILE *sndfile, const double *ptr, sf_count_t frames) ;
-
-
-/* Functions for reading and writing the data chunk in terms of items.
-** Otherwise similar to above.
-** All of these read/write function return number of items read/written.
-*/
-
-sf_count_t	sf_read_short	(SNDFILE *sndfile, short *ptr, sf_count_t items) ;
-sf_count_t	sf_write_short	(SNDFILE *sndfile, const short *ptr, sf_count_t items) ;
-
-sf_count_t	sf_read_int		(SNDFILE *sndfile, int *ptr, sf_count_t items) ;
-sf_count_t	sf_write_int 	(SNDFILE *sndfile, const int *ptr, sf_count_t items) ;
-
-sf_count_t	sf_read_float	(SNDFILE *sndfile, float *ptr, sf_count_t items) ;
-sf_count_t	sf_write_float	(SNDFILE *sndfile, const float *ptr, sf_count_t items) ;
-
-sf_count_t	sf_read_double	(SNDFILE *sndfile, double *ptr, sf_count_t items) ;
-sf_count_t	sf_write_double	(SNDFILE *sndfile, const double *ptr, sf_count_t items) ;
-
-
-/* Close the SNDFILE and clean up all memory allocations associated with this
-** file.
-** Returns 0 on success, or an error number.
-*/
-
-int		sf_close		(SNDFILE *sndfile) ;
-
-
-/* If the file is opened SFM_WRITE or SFM_RDWR, call fsync() on the file
-** to force the writing of data to disk. If the file is opened SFM_READ
-** no action is taken.
-*/
-
-void	sf_write_sync	(SNDFILE *sndfile) ;
-
-
-
-/* The function sf_wchar_open() is Windows Only!
-** Open a file passing in a Windows Unicode filename. Otherwise, this is
-** the same as sf_open().
-**
-** In order for this to work, you need to do the following:
-**
-**		#include <windows.h>
-**		#define ENABLE_SNDFILE_WINDOWS_PROTOTYPES 1
-**		#including <sndfile.h>
-*/
-
-#if ENABLE_SNDFILE_WINDOWS_PROTOTYPES
-SNDFILE* sf_wchar_open (LPCWSTR wpath, int mode, SF_INFO *sfinfo) ;
-#endif
-
-
-
-#ifdef __cplusplus
-}		/* extern "C" */
-#endif	/* __cplusplus */
-
-#endif	/* SNDFILE_H */
-
diff -Nru libsndfile-1.0.21.orig/src/strings.c libsndfile-1.0.21/src/strings.c
--- libsndfile-1.0.21.orig/src/strings.c	Fri Sep 25 11:35:26 2009
+++ libsndfile-1.0.21/src/strings.c	Wed Jul  7 18:17:14 2010
@@ -25,6 +25,8 @@
 #include	"sndfile.h"
 #include	"common.h"
 
+#define __func__ __FUNCTION__
+
 #define STRINGS_DEBUG 0
 #if STRINGS_DEBUG
 static void hexdump (void *data, int len) ;
diff -Nru libsndfile-1.0.21.orig/src/wav.c libsndfile-1.0.21/src/wav.c
--- libsndfile-1.0.21.orig/src/wav.c	Thu Dec 10 20:49:31 2009
+++ libsndfile-1.0.21/src/wav.c	Wed Jul  7 18:32:52 2010
@@ -24,13 +24,14 @@
 #include	<string.h>
 #include	<ctype.h>
 #include	<time.h>
-#include	<inttypes.h>
 
 #include	"sndfile.h"
 #include	"sfendian.h"
 #include	"common.h"
 #include	"wav_w64.h"
 
+#define snprintf _snprintf
+
 /*------------------------------------------------------------------------------
  * Macros to handle big/little endian issues.
  */
@@ -492,7 +493,7 @@
 						psf->peak_info->peaks [dword].value = value ;
 						psf->peak_info->peaks [dword].position = position ;
 
-						snprintf (cptr, sizeof (psf->u.cbuf), "    %2d   %-12" PRId64 "   %g\n",
+						snprintf (cptr, sizeof (psf->u.cbuf), "    %2d   %-12" "%lld" "   %g\n",
 								dword, psf->peak_info->peaks [dword].position, psf->peak_info->peaks [dword].value) ;
 						cptr [sizeof (psf->u.cbuf) - 1] = 0 ;
 						psf_log_printf (psf, "%s", cptr) ;
